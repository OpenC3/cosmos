#compdef openc3.sh

# Zsh completion script for openc3.sh

_openc3_util() {
    local curcontext="$curcontext"

    # First argument to util command
    if (( CURRENT == 1 )); then
        local -a util_commands
        util_commands=(
            'encode:encode a string to base64'
            'hash:hash a string using SHA-256'
            'save:save images to a tar file'
            'load:load images from a tar file'
            'tag:tag images'
            'push:push images'
            'clean:remove node_modules, coverage, etc'
            'hostsetup:configure host for redis'
            'hostenter:sh into vm host'
        )
        _describe 'util commands' util_commands
        return
    fi

    # Subsequent arguments depend on the util subcommand
    local util_cmd=$words[1]
    case $util_cmd in
        encode|hash)
            _message -r 'STRING'
            return 0
            ;;
        save)
            if (( CURRENT == 2 )); then
                _message -r 'REPO (e.g., docker.io)'
                return 0
            elif (( CURRENT == 3 )); then
                _message -r 'NAMESPACE (e.g., openc3inc)'
                return 0
            elif (( CURRENT == 4 )); then
                _message -r 'TAG (e.g., latest)'
                return 0
            elif (( CURRENT == 5 )); then
                _message 'SUFFIX (optional)'
                return 0
            fi
            ;;
        load)
            if (( CURRENT == 2 )); then
                _message 'TAG (optional, default: latest)'
                return 0
            elif (( CURRENT == 3 )); then
                _message 'SUFFIX (optional)'
                return 0
            fi
            ;;
        tag)
            if (( CURRENT == 2 )); then
                _message -r 'REPO1 (e.g., docker.io)'
                return 0
            elif (( CURRENT == 3 )); then
                _message -r 'REPO2 (e.g., localhost:12345)'
                return 0
            elif (( CURRENT == 4 )); then
                _message -r 'NAMESPACE1 (e.g., openc3inc)'
                return 0
            elif (( CURRENT == 5 )); then
                _message -r 'TAG1 (e.g., latest)'
                return 0
            elif (( CURRENT == 6 )); then
                _message 'NAMESPACE2 (optional, defaults to NAMESPACE1)'
                return 0
            elif (( CURRENT == 7 )); then
                _message 'TAG2 (optional, defaults to TAG1)'
                return 0
            elif (( CURRENT == 8 )); then
                _message 'SUFFIX (optional)'
                return 0
            fi
            ;;
        push)
            if (( CURRENT == 2 )); then
                _message -r 'REPO (e.g., localhost:12345)'
                return 0
            elif (( CURRENT == 3 )); then
                _message -r 'NAMESPACE (e.g., openc3inc)'
                return 0
            elif (( CURRENT == 4 )); then
                _message -r 'TAG (e.g., latest)'
                return 0
            elif (( CURRENT == 5 )); then
                _message 'SUFFIX (optional)'
                return 0
            fi
            ;;
        hostsetup)
            if (( CURRENT == 2 )); then
                _message -r 'REPO (e.g., docker.io)'
                return 0
            elif (( CURRENT == 3 )); then
                _message -r 'NAMESPACE (e.g., openc3inc)'
                return 0
            elif (( CURRENT == 4 )); then
                _message -r 'TAG (e.g., latest)'
                return 0
            fi
            ;;
        clean|hostenter)
            # These commands don't take arguments
            ;;
    esac
}

_openc3_cli() {
    local curcontext="$curcontext"

    # First argument to cli command
    if (( CURRENT == 1 )); then
        local -a cli_commands
        cli_commands=(
            'help:display help information'
            'rake:run rake in the local directory'
            'irb:run irb in the local directory'
            'script:interact with scripts'
            'validate:validate a COSMOS plugin gem file'
            'load:load a COSMOS plugin gem file'
            'list:list installed plugins'
            'unload:unload a plugin'
            'generate:generate various COSMOS entities'
            'bridge:run COSMOS host bridge'
            'bridgegem:run bridge using gem bridge.txt'
            'bridgesetup:create a default config file'
            'pkginstall:install loaded package'
            'pkguninstall:uninstall loaded package'
            'geminstall:install gem package'
            'gemuninstall:uninstall gem package'
            'rubysloc:DEPRECATED - use scc'
            'xtce_converter:convert to/from XTCE format'
            'cstol_converter:convert CSTOL files to COSMOS'
            'redis:interact with redis database'
            'removebase:remove tool base plugins'
            'removeenterprise:remove enterprise plugins'
            'createqueue:create a queue'
            'destroyscope:destroy a scope'
            'localinit:initialize local mode'
            'initbuckets:initialize buckets'
            'runmigrations:run database migrations'
        )
        _describe 'cli commands' cli_commands
        return
    fi

    # Subsequent arguments depend on the cli subcommand
    local cli_cmd=$words[1]
    case $cli_cmd in
        script)
            if (( CURRENT == 2 )); then
                local -a script_commands
                script_commands=(
                    'init:initialize running scripts (Enterprise Only)'
                    'list:list scripts in the specified scope'
                    'spawn:spawn script and return script ID'
                    'run:run script and print output'
                    'running:get list of all running scripts'
                    'status:get status for running script'
                    'stop:stop running script'
                )
                _describe 'script commands' script_commands
            else
                case $words[2] in
                    spawn|run)
                        _files
                        ;;
                    status|stop)
                        _message 'script ID'
                        ;;
                    running)
                        _message 'limit and offset'
                        ;;
                esac
            fi
            ;;
        validate)
            if (( CURRENT == 2 )); then
                _files -g "*.gem"
            elif (( CURRENT == 3 )); then
                _message 'SCOPE (default: DEFAULT)'
            else
                _files -g "*.json"
            fi
            ;;
        load)
            if (( CURRENT == 2 )); then
                _files -g "*.gem"
            elif (( CURRENT == 3 )); then
                _message 'SCOPE (default: DEFAULT)'
            elif (( CURRENT == 4 )); then
                _files -g "*.json"
            else
                _values 'options' '--variables[variables JSON file]' 'force[force install]'
            fi
            ;;
        list)
            _message 'SCOPE (default: DEFAULT)'
            ;;
        unload)
            if (( CURRENT == 2 )); then
                _message 'PLUGIN_NAME'
            else
                _message 'SCOPE (default: DEFAULT)'
            fi
            ;;
        generate)
            local gen_type=$words[2]

            if (( CURRENT == 2 )); then
                local -a generate_types
                generate_types=(
                    'plugin:generate a new plugin (requires NAME)'
                    'target:generate a new target (requires NAME)'
                    'microservice:generate a new microservice (requires NAME)'
                    'widget:generate a new widget (requires NameWidget)'
                    'conversion:generate a conversion (requires TARGET NAME)'
                    'processor:generate a processor (requires TARGET NAME)'
                    'limits_response:generate a limits response (requires TARGET NAME)'
                    'command_validator:generate a command validator (requires TARGET NAME)'
                    'tool:generate a tool (requires "Tool Name")'
                    'tool_vue:generate a Vue tool (requires "Tool Name")'
                    'tool_angular:generate an Angular tool (requires "Tool Name")'
                    'tool_react:generate a React tool (requires "Tool Name")'
                    'tool_svelte:generate a Svelte tool (requires "Tool Name")'
                )
                _describe 'generate types' generate_types
            elif (( CURRENT == 3 )); then
                # Different generators have different requirements
                case $gen_type in
                    conversion|processor|limits_response|command_validator)
                        # These require TARGET as first arg
                        _message -r 'TARGET (required)'
                        return 0
                        ;;
                    plugin|target|microservice|widget|tool|tool_vue|tool_angular|tool_react|tool_svelte)
                        # These require NAME as first arg
                        _message -r 'NAME (required)'
                        return 0
                        ;;
                esac
            elif (( CURRENT == 4 )); then
                case $gen_type in
                    conversion|processor|limits_response|command_validator)
                        # After TARGET, need NAME
                        _message -r 'NAME (required)'
                        return 0
                        ;;
                    *)
                        # After NAME, offer language flags
                        if [[ ! " ${words[*]} " =~ " --ruby " ]] && [[ ! " ${words[*]} " =~ " --python " ]]; then
                            local -a options
                            options=('--ruby:generate Ruby code' '--python:generate Python code')
                            _describe 'language options (required)' options
                        fi
                        ;;
                esac
            else
                # CURRENT >= 5
                # Check if language flag already provided
                if [[ ! " ${words[*]} " =~ " --ruby " ]] && [[ ! " ${words[*]} " =~ " --python " ]]; then
                    local -a options
                    options=('--ruby:generate Ruby code' '--python:generate Python code')
                    _describe 'language options (required)' options
                fi
            fi
            ;;
        bridge)
            if (( CURRENT == 2 )); then
                _files
            else
                _message 'variable=value'
            fi
            ;;
        bridgegem)
            if (( CURRENT == 2 )); then
                _message 'gem_name'
            else
                _message 'variable=value'
            fi
            ;;
        bridgesetup)
            _files
            ;;
        pkginstall|geminstall)
            if (( CURRENT == 2 )); then
                _files -g "*.gem"
            else
                _message 'SCOPE (default: DEFAULT)'
            fi
            ;;
        pkguninstall|gemuninstall)
            if (( CURRENT == 2 )); then
                _message 'PACKAGE_FILENAME'
            else
                _message 'SCOPE (default: DEFAULT)'
            fi
            ;;
        xtce_converter)
            _arguments \
                '(-h --help)'{-h,--help}'[show help message]' \
                '(-i --import)'{-i,--import}'[import .xtce file]:file:_files -g "*.xtce"' \
                '(-o --output)'{-o,--output}'[output directory]:directory:_directories' \
                '(-p --plugin)'{-p,--plugin}'[export from plugin]:plugin:_files -g "*.gem"' \
                '(-v --variables)'{-v,--variables}'[variables file]:file:_files'
            ;;
        cstol_converter)
            _arguments \
                '(-h --help)'{-h,--help}'[show help message]' \
                '*: :_files -g "*.prc"'
            ;;
        redis)
            if (( CURRENT == 2 )); then
                local -a redis_commands
                redis_commands=(
                    'keys:list all redis keys'
                    'hget:get hash value'
                )
                _describe 'redis commands' redis_commands
            else
                _message 'REDIS_KEY or HASH_FIELD'
            fi
            ;;
        createqueue)
            if (( CURRENT == 2 )); then
                _message 'QUEUE_NAME'
            else
                _message 'SCOPE'
            fi
            ;;
        destroyscope)
            _message 'SCOPE_NAME'
            ;;
        runmigrations)
            _directories
            ;;
        rake)
            if (( CURRENT == 2 )); then
                local -a rake_tasks
                rake_tasks=('build:build the plugin gem')
                _describe 'rake tasks' rake_tasks
            elif (( CURRENT == 3 )); then
                if [[ $words[2] == "build" ]]; then
                    _message -r 'VERSION=<version> (e.g. VERSION=1.0.0)'
                    return 0
                fi
            fi
            ;;
        irb|help|removebase|removeenterprise|localinit|initbuckets|rubysloc)
            # These commands don't have specific completions
            ;;
    esac
}

_openc3() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    _arguments -C \
        '1: :->command' \
        '*: :->args'

    case $state in
        command)
            local -a commands
            commands=(
                'cli:run a cli command as the default user'
                'start:build and run'
                'stop:stop the containers'
                'cleanup:REMOVE volumes / data'
                'build:build the containers'
                'run:run the containers'
                'test:test openc3'
                'util:various helper commands'
                'start-ubi:build and run UBI images'
                'build-ubi:build UBI containers'
                'run-ubi:run UBI containers'
            )
            _describe 'openc3.sh commands' commands
            ;;
        args)
            case $line[1] in
                cleanup)
                    _values 'cleanup options' \
                        'local[also cleanup local plugin files]' \
                        'force[skip confirmation prompt]'
                    ;;
                cli)
                    # Adjust words array to make it relative to cli subcommand
                    local -a cli_words
                    cli_words=("${words[@]:2}")  # Remove 'openc3.sh' and 'cli'
                    local cli_current=$((CURRENT - 2))

                    # Save original values
                    local save_words=("${words[@]}")
                    local save_current=$CURRENT

                    # Set context for cli completion
                    words=("${cli_words[@]}")
                    CURRENT=$cli_current

                    _openc3_cli

                    # Restore original values
                    words=("${save_words[@]}")
                    CURRENT=$save_current
                    ;;
                util)
                    # Adjust words array to make it relative to util subcommand
                    local -a util_words
                    util_words=("${words[@]:2}")  # Remove 'openc3.sh' and 'util'
                    local util_current=$((CURRENT - 2))

                    # Save original values
                    local save_words=("${words[@]}")
                    local save_current=$CURRENT

                    # Set context for util completion
                    words=("${util_words[@]}")
                    CURRENT=$util_current

                    _openc3_util

                    # Restore original values
                    words=("${save_words[@]}")
                    CURRENT=$save_current
                    ;;
                test)
                    # These accept variable arguments, provide file completion
                    _files
                    ;;
                start|stop|build|run|start-ubi|build-ubi|run-ubi)
                    # These commands don't take arguments
                    ;;
            esac
            ;;
    esac
}

_openc3 "$@"
