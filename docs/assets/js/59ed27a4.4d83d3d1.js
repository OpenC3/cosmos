"use strict";(self.webpackChunkdocs_openc3_com=self.webpackChunkdocs_openc3_com||[]).push([["2553"],{4787:function(e,s,r){r.r(s),r.d(s,{frontMatter:()=>i,toc:()=>l,default:()=>h,metadata:()=>o,assets:()=>c,contentTitle:()=>a});var o=JSON.parse('{"id":"configuration/processors","title":"Processors","description":"Processors execute code every time a packet is received to calculate values","source":"@site/docs/configuration/processors.md","sourceDirName":"configuration","slug":"/configuration/processors","permalink":"/docs/configuration/processors","draft":false,"unlisted":false,"editUrl":"https://github.com/OpenC3/cosmos/tree/main/docs.openc3.com/docs/configuration/processors.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10,"title":"Processors","description":"Processors execute code every time a packet is received to calculate values","sidebar_custom_props":{"myEmoji":"\u{1F9EE}"}},"sidebar":"defaultSidebar","previous":{"title":"Conversions","permalink":"/docs/configuration/conversions"},"next":{"title":"Limits Response","permalink":"/docs/configuration/limits-response"}}'),n=r(7259),t=r(677);let i={sidebar_position:10,title:"Processors",description:"Processors execute code every time a packet is received to calculate values",sidebar_custom_props:{myEmoji:"\u{1F9EE}"}},a="Overview",c={},l=[{value:"Custom Processors",id:"custom-processors",level:2},{value:"<strong>init</strong>",id:"init",level:3},{value:"call",id:"call",level:3},{value:"reset",id:"reset",level:3},{value:"Instantiate Processor",id:"instantiate-processor",level:3},{value:"WATERMARK_PROCESSOR",id:"watermark_processor",level:2},{value:"STATISTICS_PROCESSOR",id:"statistics_processor",level:2}];function d(e){let s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,t.R)(),...e.components},{TabItem:r,Tabs:o}=s;return r||p("TabItem",!0),o||p("Tabs",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"overview",children:"Overview"})}),"\n",(0,n.jsxs)(s.p,{children:["Processors execute code every time a packet is received to calculate values that can be retrieved by a ",(0,n.jsx)(s.a,{href:"/docs/configuration/conversions#processor_conversion",children:"ProcessorConversion"}),". Processors are applied using the ",(0,n.jsx)(s.a,{href:"/docs/configuration/telemetry#processor",children:"PROCESSOR"})," keyword and generate values unique to the processor."]}),"\n",(0,n.jsxs)(s.p,{children:["If you only want to perform calculations using a single packet to modify a telemetry value you probably want to use a ",(0,n.jsx)(s.a,{href:"/docs/configuration/conversions",children:"Conversion"}),". Processors are used when you're deriving a number of values from a single telemetry item."]}),"\n",(0,n.jsx)(s.h2,{id:"custom-processors",children:"Custom Processors"}),"\n",(0,n.jsxs)(s.p,{children:["You can easily create your own custom processors by using the ",(0,n.jsx)(s.a,{href:"/docs/getting-started/generators#processor-generator",children:"Processor Code Generator"}),". To generate a process you must be inside an existing COSMOS plugin. The generator takes both a target name and the processor name. For example if your plugin is called ",(0,n.jsx)(s.code,{children:"openc3-cosmos-gse"})," and you have an existing target named ",(0,n.jsx)(s.code,{children:"GSE"}),":"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-bash",children:"openc3-cosmos-gse % openc3.sh cli generate processor GSE slope --python\nProcessor targets/GSE/lib/slope_processor.py successfully generated!\nTo use the processor add the following to a telemetry packet:\n  PROCESSOR SLOPE slope_processor.py <PARAMS...>\n"})}),"\n",(0,n.jsxs)(s.p,{children:["Note: To create a Ruby processor simply replace ",(0,n.jsx)(s.code,{children:"--python"})," with ",(0,n.jsx)(s.code,{children:"--ruby"}),"."]}),"\n",(0,n.jsxs)(s.p,{children:["The above command creates a processor called ",(0,n.jsx)(s.code,{children:"slope_processor.py"})," at ",(0,n.jsx)(s.code,{children:"targets/GSE/lib/slope_processor.py"}),". The code which is generated looks like the following:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"import math\nfrom openc3.processors.processor import Processor\n\n# Custom processor class\n# See https://docs.openc3.com/docs/configuration/processors\nclass SlopeProcessor(Processor):\n    def __init__(self, item_name, num_samples, value_type='CONVERTED'):\n        super().__init__(value_type)\n        self.item_name = item_name.upper()\n        self.num_samples = int(num_samples)\n        self.reset()\n\n    def call(self, value, packet, buffer):\n        value = packet.read(self.item_name, self.value_type, buffer)\n        # Don't process NaN or Infinite values\n        if math.isnan(value) or math.isinf(value):\n            return\n\n        self.samples.append(value)\n        if len(self.samples) > self.num_samples:\n            self.samples = self.samples[-self.num_samples :]\n\n        if len(self.samples) > 1:\n            self.results['RATE_OF_CHANGE'] = (self.samples[-1] - self.samples[0]) / (len(self.samples) - 1)\n        else:\n            self.results['RATE_OF_CHANGE'] = None\n\n    def reset(self):\n        self.samples = []\n        self.results['RATE_OF_CHANGE'] = None\n"})}),"\n",(0,n.jsx)(s.h3,{id:"init",children:(0,n.jsx)(s.strong,{children:"init"})}),"\n",(0,n.jsxs)(s.p,{children:["The ",(0,n.jsx)(s.strong,{children:"init"})," method is where the processor is initialized. The parameters specified are the parameters given in the configuration file when creating the processor. So for our example, the telemetry configuration file will look like:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"# Calculate the slope of TEMP1 over the last 60 samples (1 minute)\nPROCESSOR SLOPE slope_processor.py TEMP1 60\n"})}),"\n",(0,n.jsx)(s.h3,{id:"call",children:"call"}),"\n",(0,n.jsxs)(s.p,{children:["The call method is where the actual processor logic is implemented. In our case we want to calculate the rate of change from the first sample to the last sample. There are certainly more efficient ways to calculate a single rate of change value (you really only need 2 values) but this example shows how to keep a running list of values. Also note that if you're only performing a single calculation you might be better off using a ",(0,n.jsx)(s.a,{href:"/docs/configuration/conversions",children:"Conversion"}),"."]}),"\n",(0,n.jsx)(s.h3,{id:"reset",children:"reset"}),"\n",(0,n.jsxs)(s.p,{children:["The reset method initializes the samples and clears any state by setting the results to ",(0,n.jsx)(s.code,{children:"None"}),"."]}),"\n",(0,n.jsx)(s.h3,{id:"instantiate-processor",children:"Instantiate Processor"}),"\n",(0,n.jsxs)(s.p,{children:["Now that we have implemented the processor logic we need to create the processor by adding it to a telemetry packet with the line ",(0,n.jsx)(s.code,{children:"PROCESSOR SLOPE slope_processor.py"})," in the ",(0,n.jsx)(s.a,{href:"/docs/configuration/telemetry",children:"telemetry"})," definition file. We also need a ",(0,n.jsx)(s.a,{href:"/docs/configuration/conversions#processor_conversion",children:"ProcessorConversion"})," to pull the calculated values out of the processor and into a ",(0,n.jsx)(s.a,{href:"/docs/configuration/telemetry#derived-items",children:"derived"})," telemetry item. This could look something like this:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-bash",children:'TELEMETRY GSE DATA BIG_ENDIAN "Data packet"\n  ... # Telemetry items\n  ITEM TEMP1SLOPE 0 0 DERIVED "Rate of change for the last 60 samples of TEMP1"\n    READ_CONVERSION openc3/conversions/processor_conversion.py SLOPE RATE_OF_CHANGE\n  # Calculate the slope of TEMP1 over the last 60 samples (1 minute)\n  PROCESSOR SLOPE slope_processor.py TEMP1 60\n'})}),"\n",(0,n.jsx)(s.p,{children:"If you have multiple values you're calculating you simply add additional ITEMs with READ_COVERSIONs and read the various values the processor calculates in the results."}),"\n",(0,n.jsx)(s.h1,{id:"built-in-processors",children:"Built-in Processors"}),"\n",(0,n.jsx)(s.h2,{id:"watermark_processor",children:"WATERMARK_PROCESSOR"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"Calculates high and low values for a given item"})}),"\n",(0,n.jsxs)(s.p,{children:["Stores high and low values for a given item as HIGH_WATER and LOW_WATER.\nValues are retrieved using a ",(0,n.jsx)(s.a,{href:"/docs/configuration/conversions#processor_conversion",children:"ProcessorConversion"}),"."]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Parameter"}),(0,n.jsx)(s.th,{children:"Description"}),(0,n.jsx)(s.th,{children:"Required"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Item Name"}),(0,n.jsx)(s.td,{children:"The item name to calculate high and low values for"}),(0,n.jsx)(s.td,{children:"True"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Value Type"}),(0,n.jsxs)(s.td,{children:["The type of the value to display. Default is CONVERTED.",(0,n.jsx)("br",{}),(0,n.jsx)("br",{}),"Valid Values: ",(0,n.jsx)("span",{class:"values",children:"RAW, CONVERTED"})]}),(0,n.jsx)(s.td,{children:"False"})]})]})]}),"\n",(0,n.jsxs)(o,{groupId:"script-language",children:[(0,n.jsx)(r,{value:"python",label:"Python",children:(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'PROCESSOR TEMP1WATER openc3/conversions/watermark_processor.py TEMP1\nITEM TEMP1HIGH 0 0 DERIVED "High-water mark for TEMP1"\n  READ_CONVERSION openc3/conversions/processor_conversion.py TEMP1WATER HIGH_WATER\n'})})}),(0,n.jsx)(r,{value:"ruby",label:"Ruby",children:(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-ruby",children:'PROCESSOR TEMP1WATER watermark_processor.rb TEMP1\nITEM TEMP1HIGH 0 0 DERIVED "High-water mark for TEMP1"\n  READ_CONVERSION processor_conversion.rb TEMP1WATER HIGH_WATER\n'})})})]}),"\n",(0,n.jsx)(s.h2,{id:"statistics_processor",children:"STATISTICS_PROCESSOR"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"Calculates statistics for a given item"})}),"\n",(0,n.jsxs)(s.p,{children:["This processor calculates statistics for a given item as MIN, MAX, MEAN, and STDDEV\nover a specified number of samples. Values are retrieved using a ",(0,n.jsx)(s.a,{href:"/docs/configuration/conversions#processor_conversion",children:"ProcessorConversion"}),"."]}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Parameter"}),(0,n.jsx)(s.th,{children:"Description"}),(0,n.jsx)(s.th,{children:"Required"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Item Name"}),(0,n.jsx)(s.td,{children:"The item name to calculate statistics for"}),(0,n.jsx)(s.td,{children:"True"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Samples to Average"}),(0,n.jsx)(s.td,{children:"The number of samples to average for statistics"}),(0,n.jsx)(s.td,{children:"True"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"Value Type"}),(0,n.jsxs)(s.td,{children:["The type of the value to display. Default is CONVERTED.",(0,n.jsx)("br",{}),(0,n.jsx)("br",{}),"Valid Values: ",(0,n.jsx)("span",{class:"values",children:"RAW, CONVERTED"})]}),(0,n.jsx)(s.td,{children:"False"})]})]})]}),"\n",(0,n.jsxs)(o,{groupId:"script-language",children:[(0,n.jsx)(r,{value:"python",label:"Python",children:(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'PROCESSOR TEMP1STAT openc3/conversions/statistics_processor.py TEMP1 100\nITEM TEMP1STDDEV 0 0 DERIVED "Stddev of most recent 100 samples for TEMP1"\n  READ_CONVERSION openc3/conversions/processor_conversion.py TEMP1STAT STDDEV FLOAT 64\n'})})}),(0,n.jsx)(r,{value:"ruby",label:"Ruby",children:(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-ruby",children:'PROCESSOR TEMP1STAT statistics_processor.rb TEMP1 100\nITEM TEMP1STDDEV 0 0 DERIVED "Stddev of most recent 100 samples for TEMP1"\n  READ_CONVERSION processor_conversion.rb TEMP1STAT STDDEV FLOAT 64\n'})})})]})]})}function h(e={}){let{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}function p(e,s){throw Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},677:function(e,s,r){r.d(s,{R:()=>i,x:()=>a});var o=r(6363);let n={},t=o.createContext(n);function i(e){let s=o.useContext(t);return o.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),o.createElement(t.Provider,{value:s},e.children)}}}]);