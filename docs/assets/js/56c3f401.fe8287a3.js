"use strict";(self.webpackChunkdocs_openc3_com=self.webpackChunkdocs_openc3_com||[]).push([["7380"],{1908:function(e,s,t){t.r(s),t.d(s,{metadata:()=>n,default:()=>h,frontMatter:()=>o,contentTitle:()=>a,toc:()=>d,assets:()=>c});var n=JSON.parse('{"id":"getting-started/architecture","title":"Architecture","description":"Architecture, Projects, Containerization, Frontend, Backend","source":"@site/docs/getting-started/architecture.md","sourceDirName":"getting-started","slug":"/getting-started/architecture","permalink":"/docs/getting-started/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/OpenC3/cosmos/tree/main/docs.openc3.com/docs/getting-started/architecture.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Architecture","description":"Architecture, Projects, Containerization, Frontend, Backend","sidebar_custom_props":{"myEmoji":"\u{1F3D7}\uFE0F"}},"sidebar":"defaultSidebar","previous":{"title":"Getting Started","permalink":"/docs/getting-started"},"next":{"title":"Installation","permalink":"/docs/getting-started/installation"}}'),r=t(2615),i=t(9496);let o={sidebar_position:1,title:"Architecture",description:"Architecture, Projects, Containerization, Frontend, Backend",sidebar_custom_props:{myEmoji:"\u{1F3D7}\uFE0F"}},a="OpenC3 COSMOS Architecture",c={},d=[{value:"COSMOS Core Architecture",id:"cosmos-core-architecture",level:2},{value:"COSMOS Enterprise Architecture",id:"cosmos-enterprise-architecture",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Projects",id:"projects",level:2},{value:"Containerization",id:"containerization",level:2},{value:"Images",id:"images",level:3},{value:"Containers",id:"containers",level:3},{value:"Docker Compose",id:"docker-compose",level:3},{value:"Environment File",id:"environment-file",level:3},{value:"Kubernetes",id:"kubernetes",level:3},{value:"Frontend",id:"frontend",level:2},{value:"Vue.js",id:"vuejs",level:3},{value:"Single-Spa",id:"single-spa",level:3},{value:"Astro UX",id:"astro-ux",level:3},{value:"Backend",id:"backend",level:2},{value:"Valkey",id:"valkey",level:3},{value:"Versitygw",id:"versitygw",level:3},{value:"Ruby on Rails",id:"ruby-on-rails",level:3},{value:"QuestDB",id:"questdb",level:3},{value:"Data Type Mapping",id:"data-type-mapping",level:4},{value:"Special Float Value Handling",id:"special-float-value-handling",level:4},{value:"Other Limitations",id:"other-limitations",level:4},{value:"Historical Data Migration",id:"historical-data-migration",level:4},{value:"Keycloak (Enterprise)",id:"keycloak-enterprise",level:3},{value:"Access Token",id:"access-token",level:4},{value:"Refresh Token",id:"refresh-token",level:4},{value:"Offline Access Token",id:"offline-access-token",level:4},{value:"Token Lifecycle",id:"token-lifecycle",level:4},{value:"Automatic Token Refresh",id:"automatic-token-refresh",level:4},{value:"Default Token Lifespans",id:"default-token-lifespans",level:4}];function l(e){let s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"openc3-cosmos-architecture",children:"OpenC3 COSMOS Architecture"})}),"\n",(0,r.jsx)(s.h2,{id:"cosmos-core-architecture",children:"COSMOS Core Architecture"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{alt:"COSMOS Core Architecture",src:t(8738).A+"",width:"478",height:"822"})}),"\n",(0,r.jsxs)(s.p,{children:["COSMOS Core is a cloud native, containerized, microservice oriented command and control system deployed with Docker Compose. The ",(0,r.jsx)(s.strong,{children:"init"})," container seeds the initial configuration and plugin data into the system on startup. The ",(0,r.jsx)(s.strong,{children:"operator"})," manages the lifecycle of all COSMOS microservices including interfaces that connect to external embedded systems (Targets). Two Rails-based APIs power the system: ",(0,r.jsx)(s.strong,{children:"cmd-tlm-api"})," provides the REST API for command and telemetry operations, while ",(0,r.jsx)(s.strong,{children:"script-runner-api"})," handles script execution. The ",(0,r.jsx)(s.strong,{children:"traefik"})," reverse proxy routes all user browser traffic to the appropriate API. Two ",(0,r.jsx)(s.strong,{children:"Valkey"})," (Redis) data stores are used: ",(0,r.jsx)(s.strong,{children:"redis"})," holds persistent configuration and the current value table, while ",(0,r.jsx)(s.strong,{children:"redis-ephemeral"})," handles real-time data streams. The ",(0,r.jsx)(s.strong,{children:"buckets"})," service provides S3-compatible object storage (powered by Versitygw) for plugins, targets, configuration data, text logs, and binary logs of all raw data. The time-series database (",(0,r.jsx)(s.strong,{children:"tsdb"}),"), powered by ",(0,r.jsx)(s.a,{href:"https://questdb.io/",children:"QuestDB"}),", stores all decommutated command and telemetry data for fast historical queries."]}),"\n",(0,r.jsx)(s.h2,{id:"cosmos-enterprise-architecture",children:"COSMOS Enterprise Architecture"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{alt:"COSMOS Enterprise Architecture",src:t(3934).A+"",width:"864",height:"1172"})}),"\n",(0,r.jsxs)(s.p,{children:["COSMOS Enterprise extends Core with additional services and is optionally deployed on a Kubernetes cluster using ",(0,r.jsx)(s.strong,{children:"Helm"})," charts as shown above. The core services (cmd-tlm-api, script-runner-api, traefik, init, operator) remain the same and are deployed by the ",(0,r.jsx)(s.strong,{children:"openc3"})," chart. Data services (tsdb, buckets, redis, redis-ephemeral) are deployed by a separate ",(0,r.jsx)(s.strong,{children:"openc3-db"})," chart. Enterprise adds ",(0,r.jsx)(s.strong,{children:"Keycloak"})," for full identity and access management with role-based permissions, backed by a ",(0,r.jsx)(s.strong,{children:"PostgreSQL"})," database. A ",(0,r.jsx)(s.strong,{children:"Grafana"})," instance and ",(0,r.jsx)(s.strong,{children:"metrics"})," collector provide system monitoring and observability dashboards. The ",(0,r.jsx)(s.strong,{children:"COSMOS NFS"})," chart provides shared network file storage across the cluster. All services are orchestrated by Kubernetes, enabling horizontal scaling, high availability, and production-grade deployment."]}),"\n",(0,r.jsx)(s.h2,{id:"terminology",children:"Terminology"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Term"}),(0,r.jsx)(s.th,{children:"Definition"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/docs/configuration/target",children:"Target"})}),(0,r.jsx)(s.td,{children:"A COSMOS target is an embedded system that the COSMOS Command and Telemetry Server connects to using an interface in order to send commands to and/or receive telemetry from."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/docs/configuration/command",children:"Command"})}),(0,r.jsx)(s.td,{children:"A packet of information telling a target to perform an action of some sort."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/docs/configuration/telemetry",children:"Telemetry"})}),(0,r.jsx)(s.td,{children:"A packet of information providing status from a target."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/docs/configuration/interfaces",children:"Interface"})}),(0,r.jsx)(s.td,{children:"A physical connection to a target that sends commands to and/or receives telemetry from a target. COSMOS comes with interfaces that support TCP/IP, UDP, and serial connections. Custom interfaces are easy to add to the system."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/docs/configuration",children:"Configuration Files"})}),(0,r.jsx)(s.td,{children:"COSMOS uses simple plain text configuration files to define commands and telemetry packets, and to configure each COSMOS application. These files are easily human readable/editable and machine readable/editable."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.a,{href:"/docs/tools",children:"Tool"})}),(0,r.jsx)(s.td,{children:"Another name for a COSMOS application."})]})]})]}),"\n",(0,r.jsx)(s.p,{children:"Key aspects of this architecture:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["COSMOS can connect to many different kinds of targets. The examples include things like Flight software (FSW), Ground Support Equipment (GSE), Labview, and COTS targets such as an Agilent power supply. Any embedded system that provides a communication interface can be connected to COSMOS. The flexibility of ",(0,r.jsx)(s.a,{href:"/docs/configuration/interfaces",children:"interfaces"}),", ",(0,r.jsx)(s.a,{href:"/docs/configuration/protocols",children:"protocols"}),", and ",(0,r.jsx)(s.a,{href:"/docs/configuration/accessors",children:"accessors"})," mean we adapt to your hardware, not the other way around!"]}),"\n",(0,r.jsx)(s.li,{children:"All realtime communication with targets flows through the COSMOS system. This ensures all commands and telemetry are logged."}),"\n",(0,r.jsx)(s.li,{children:"Every tool is configured with plain text configuration files."}),"\n",(0,r.jsx)(s.li,{children:"Program specific tools can be written using the COSMOS libraries that can interact with the realtime command and telemetry streams and can process logged data."}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"projects",children:"Projects"}),"\n",(0,r.jsxs)(s.p,{children:["The main COSMOS ",(0,r.jsx)(s.a,{href:"https://github.com/OpenC3/cosmos",children:"repo"})," contains all the source code used to build and run COSMOS. However, users (not developers) of COSMOS should use the COSMOS ",(0,r.jsx)(s.a,{href:"https://github.com/OpenC3/cosmos-project",children:"project"})," to launch COSMOS. The project consists of the ",(0,r.jsx)(s.a,{href:"https://github.com/OpenC3/cosmos-project/blob/main/openc3.sh",children:"openc3.sh"})," and ",(0,r.jsx)(s.a,{href:"https://github.com/OpenC3/cosmos-project/blob/main/openc3.bat",children:"openc3.bat"})," files for starting and stopping COSMOS, the ",(0,r.jsx)(s.a,{href:"https://github.com/OpenC3/cosmos-project/blob/main/compose.yaml",children:"compose.yaml"})," for configuring the COSMOS containers, and the ",(0,r.jsx)(s.a,{href:"https://github.com/OpenC3/cosmos-project/blob/main/.env",children:".env"})," file for setting runtime variables. Additionally, the COSMOS project contains user modifiable config files for both Redis and Traefik."]}),"\n",(0,r.jsx)(s.h2,{id:"containerization",children:"Containerization"}),"\n",(0,r.jsx)(s.h3,{id:"images",children:"Images"}),"\n",(0,r.jsxs)(s.p,{children:["Per ",(0,r.jsx)(s.a,{href:"https://docs.docker.com/get-started/overview/#images",children:"Docker"}),', "An image is a read-only template with instructions for creating a Docker container." The base operating system COSMOS uses is called ',(0,r.jsx)(s.a,{href:"https://www.alpinelinux.org/",children:"Alpine Linux"}),". It is a simple and compact image with a full package system that allows us to install our dependencies. Starting with Alpine, we create a ",(0,r.jsx)(s.a,{href:"https://docs.docker.com/engine/reference/builder/",children:"Dockerfile"})," to add Ruby and Python and a few other packages to create our own docker image. We further build upon that image to create a NodeJS image to support our frontend and additional images to support our backend."]}),"\n",(0,r.jsxs)(s.p,{children:["The following diagram shows all the COSMOS Core and Enterprise container images. Images are built from the bottom up in the Dockerfile using ",(0,r.jsx)(s.a,{href:"https://docs.docker.com/reference/dockerfile/#from",children:"FROM"}),'. Images referenced with "Uses" are used during the build stage.']}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{alt:"COSMOS Images",src:t(5114).A+"",width:"711",height:"401"})}),"\n",(0,r.jsx)(s.h3,{id:"containers",children:"Containers"}),"\n",(0,r.jsxs)(s.p,{children:["Per ",(0,r.jsx)(s.a,{href:"https://www.docker.com/resources/what-container/",children:"Docker"}),', "a container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another." Also per ',(0,r.jsx)(s.a,{href:"https://docs.docker.com/guides/walkthroughs/what-is-a-container/",children:"Docker"}),', "A container is an isolated environment for your code. This means that a container has no knowledge of your operating system, or your files. It runs on the environment provided to you by Docker Desktop. Containers have everything that your code needs in order to run, down to a base operating system." COSMOS utilizes containers to provide a consistent runtime environment. Containers make it easy to deploy to local on-prem servers, cloud environments, or air-gapped networks.']}),"\n",(0,r.jsx)(s.p,{children:"The COSMOS Core containers consist of the following:"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Name"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-openc3-cosmos-init-1"}),(0,r.jsx)(s.td,{children:"Run migrations, installs the COSMOS tools, and then exits"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-openc3-operator-1"}),(0,r.jsx)(s.td,{children:"Main COSMOS container that runs the interfaces and target microservices"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-openc3-traefik-1"}),(0,r.jsx)(s.td,{children:"Provides a reverse proxy and load balancer with routes to the COSMOS endpoints"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-openc3-cosmos-cmd-tlm-api-1"}),(0,r.jsx)(s.td,{children:"Rails server that provides all the COSMOS API endpoints"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-openc3-cosmos-script-runner-api-1"}),(0,r.jsx)(s.td,{children:"Rails server that provides the Script API endpoints"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-openc3-buckets-1"}),(0,r.jsx)(s.td,{children:"Provides a S3 like bucket storage interface and also serves as a static webserver for the tool files"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-openc3-redis-1"}),(0,r.jsx)(s.td,{children:"Serves the static target configuration and Current Value Table"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-openc3-redis-ephemeral-1"}),(0,r.jsxs)(s.td,{children:["Serves the ",(0,r.jsx)(s.a,{href:"https://valkey.io/topics/streams-intro/",children:"streams"})," containing the raw and decomutated data"]})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-openc3-tsdb-1"}),(0,r.jsxs)(s.td,{children:[(0,r.jsx)(s.a,{href:"https://questdb.io/",children:"QuestDB"})," time-series database for long-term storage of decommutated data"]})]})]})]}),"\n",(0,r.jsxs)(s.p,{children:["The container list for ",(0,r.jsx)(s.a,{href:"https://openc3.com/enterprise",children:"COSMOS Enterprise"})," consists of the following:"]}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Name"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-enterprise-openc3-grafana-1"}),(0,r.jsxs)(s.td,{children:[(0,r.jsx)(s.a,{href:"https://grafana.com/",children:"Grafana"})," container preconfigured with the COSMOS Data Source"]})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-enterprise-openc3-metrics-1"}),(0,r.jsx)(s.td,{children:"Rails server that provides metrics on COSMOS performance"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-enterprise-openc3-keycloak-1"}),(0,r.jsx)(s.td,{children:"Single-Sign On service for authentication"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"cosmos-enterprise-openc3-postgresql-1"}),(0,r.jsx)(s.td,{children:"SQL Database for use by Keycloak"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"openc3-nfs *"}),(0,r.jsx)(s.td,{children:"Network File System pod only for use in Kubernetes to share code libraries between containers"})]})]})]}),"\n",(0,r.jsx)(s.p,{children:"A diagram of the running containers is shown below:"}),"\n",(0,r.jsx)(s.p,{children:(0,r.jsx)(s.img,{alt:"COSMOS Images",src:t(1400).A+"",width:"641",height:"321"})}),"\n",(0,r.jsx)(s.h3,{id:"docker-compose",children:"Docker Compose"}),"\n",(0,r.jsxs)(s.p,{children:["Per ",(0,r.jsx)(s.a,{href:"https://docs.docker.com/compose/",children:"Docker"}),', "Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application\'s services. Then, with a single command, you create and start all the services from your configuration." OpenC3 uses compose files to both build and run COSMOS. The ',(0,r.jsx)(s.a,{href:"https://github.com/OpenC3/cosmos-project/blob/main/compose.yaml",children:"compose.yaml"})," is where ports are exposed and environment variables are used."]}),"\n",(0,r.jsx)(s.h3,{id:"environment-file",children:"Environment File"}),"\n",(0,r.jsxs)(s.p,{children:["COSMOS uses an ",(0,r.jsx)(s.a,{href:"https://docs.docker.com/compose/environment-variables/env-file/",children:"environment file"})," along with Docker Compose to pass environment variables into the COSMOS runtime. This ",(0,r.jsx)(s.a,{href:"https://github.com/OpenC3/cosmos-project/blob/main/.env",children:".env"})," file consists of simple key value pairs that contain the version of COSMOS deployed, usernames and passwords, and much more."]}),"\n",(0,r.jsx)(s.h3,{id:"kubernetes",children:"Kubernetes"}),"\n",(0,r.jsxs)(s.p,{children:["Per ",(0,r.jsx)(s.a,{href:"https://kubernetes.io/",children:"Kubernetes.io"}),', "Kubernetes, also known as K8s, is an open-source system for automating deployment, scaling, and management of containerized applications. It groups containers that make up an application into logical units for easy management and discovery." ',(0,r.jsx)(s.a,{href:"https://openc3.com/enterprise",children:"COSMOS Enterprise"})," provides ",(0,r.jsx)(s.a,{href:"https://helm.sh/docs/topics/charts/",children:"Helm charts"})," for easy deployment to Kubernetes in various cloud environments."]}),"\n",(0,r.jsx)(s.p,{children:"COSMOS Enterprise also provides configuration to deploy COSMOS infrastructure on various cloud environments (e.g. CloudFormation template on AWS)."}),"\n",(0,r.jsx)(s.h2,{id:"frontend",children:"Frontend"}),"\n",(0,r.jsx)(s.h3,{id:"vuejs",children:"Vue.js"}),"\n",(0,r.jsxs)(s.p,{children:["The COSMOS frontend is fully browser native and is implemented in the Vue.js framework. Per ",(0,r.jsx)(s.a,{href:"https://vuejs.org/guide/introduction.html",children:"Vue.js"}),', "Vue is a JavaScript framework for building user interfaces. It builds on top of standard HTML, CSS, and JavaScript and provides a declarative and component-based programming model that helps you efficiently develop user interfaces, be they simple or complex." COSMOS utilizes Vue.js and the ',(0,r.jsx)(s.a,{href:"https://vuetifyjs.com/en/",children:"Vuetify"})," Component Framework UI library to build all the COSMOS tools which run in the browser of your choice. COSMOS 5 utilized Vue.js 2.x and Vuetify 2.x while COSMOS 6 utilizes Vue.js 3.x and Vuetify 3.x."]}),"\n",(0,r.jsx)(s.h3,{id:"single-spa",children:"Single-Spa"}),"\n",(0,r.jsxs)(s.p,{children:["While COSMOS itself is written in Vue.js, we utilize a technology called ",(0,r.jsx)(s.a,{href:"https://single-spa.js.org/",children:"single-spa"})," to allow COSMOS developers to create applications in any javascript framework they choose. Single-spa is a micro frontend framework and acts as a top level router to render the application being requested. COSMOS provides sample applications ready to plug into single-spa in Angular, React, Svelte, and Vue."]}),"\n",(0,r.jsx)(s.h3,{id:"astro-ux",children:"Astro UX"}),"\n",(0,r.jsxs)(s.p,{children:["Per ",(0,r.jsx)(s.a,{href:"https://www.astrouxds.com/",children:"AstroUXDS"}),', "The Astro Space UX Design System enables developers and designers to build rich space app experiences with established interaction patterns and best practices." COSMOS utilizes the Astro design guidelines for color, typograpy, and iconograpy. In some cases, e.g. ',(0,r.jsx)(s.a,{href:"https://www.astrouxds.com/components/clock/",children:"Astro Clock"}),", COSMOS directly incorporates Astro components."]}),"\n",(0,r.jsx)(s.h2,{id:"backend",children:"Backend"}),"\n",(0,r.jsx)(s.h3,{id:"valkey",children:"Valkey"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.a,{href:"https://valkey.io/",children:"Valkey"})," is an in-memory data store with support for strings, hashes, lists, sets, sorted sets, streams, and more. COSMOS uses Valkey to store both our configuration and data. If you look back at our ",(0,r.jsx)(s.a,{href:"/docs/getting-started/architecture#containers",children:"container list"})," you'll notice two valkey containers: cosmos-openc3-redis-1 and cosmos-openc3-redis-ephemeral-1 (still named Redis after the original). The ephemeral container contains all the real-time data pushed into ",(0,r.jsx)(s.a,{href:"https://valkey.io/topics/streams-intro/",children:"streams"}),". The other container contains COSMOS configuration that is meant to persist. ",(0,r.jsx)(s.a,{href:"https://openc3.com/enterprise",children:"COSMOS Enterprise"})," provides helm charts that setup ",(0,r.jsx)(s.a,{href:"https://valkey.io/topics/cluster-tutorial/",children:"Valkey Cluster"})," to perform horizontal scaling where data is shared across multiple nodes."]}),"\n",(0,r.jsx)(s.h3,{id:"versitygw",children:"Versitygw"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.a,{href:"https://github.com/versity/versitygw/",children:"Versitygw"})," is a high-performance, S3 compatible object store. COSMOS uses this storage technology to host both the COSMOS tools themselves and the long term log files. ",(0,r.jsx)(s.a,{href:"https://openc3.com/enterprise",children:"COSMOS Enterprise"})," deployed in a cloud environment uses the available cloud native bucket storage technology, e.g. AWS S3, GCP Buckets, and Azure Blob Storage. Using bucket storage allows COSMOS to directly serve the tools as a static website and thus we don't need to deploy Tomcat or Nginx for example."]}),"\n",(0,r.jsx)(s.h3,{id:"ruby-on-rails",children:"Ruby on Rails"}),"\n",(0,r.jsxs)(s.p,{children:["The COSMOS API and Script Runner backends are powered by ",(0,r.jsx)(s.a,{href:"https://rubyonrails.org/",children:"Ruby on Rails"}),". Rails is a web application development framework written in the Ruby programming language. Rails (and our familiarity with Ruby) allows us to write less code while accomplishing more than many other languages and frameworks."]}),"\n",(0,r.jsx)(s.h3,{id:"questdb",children:"QuestDB"}),"\n",(0,r.jsxs)(s.p,{children:["COSMOS uses ",(0,r.jsx)(s.a,{href:"https://questdb.io/",children:"QuestDB"})," as its time-series database (TSDB) for long-term telemetry storage. QuestDB is a high-performance database optimized for time-series data, offering fast ingestion rates and efficient querying of large datasets. Data is ingested into QuestDB via the ",(0,r.jsx)(s.a,{href:"https://questdb.io/docs/reference/api/ilp/overview/",children:"ILP HTTP protocol"}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["While Valkey stores real-time streaming data and the current value table, QuestDB provides persistent storage for historical telemetry. This enables users to query telemetry data over extended time periods using standard SQL syntax. Each telemetry and command packet gets its own QuestDB table using the naming convention ",(0,r.jsx)(s.code,{children:"TLM__TARGET__PACKET"})," or ",(0,r.jsx)(s.code,{children:"CMD__TARGET__PACKET"}),"."]}),"\n",(0,r.jsx)(s.h4,{id:"data-type-mapping",children:"Data Type Mapping"}),"\n",(0,r.jsx)(s.p,{children:"COSMOS maps its data types to QuestDB column types as follows:"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"COSMOS Type"}),(0,r.jsx)(s.th,{children:"Bit Size"}),(0,r.jsx)(s.th,{children:"QuestDB Type"}),(0,r.jsx)(s.th,{children:"Notes"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"INT"}),(0,r.jsx)(s.td,{children:"< 32"}),(0,r.jsx)(s.td,{children:"int"}),(0,r.jsx)(s.td,{children:"Small signed integers and bitfields"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"INT"}),(0,r.jsx)(s.td,{children:"32"}),(0,r.jsx)(s.td,{children:"long"}),(0,r.jsx)(s.td,{children:"Promoted to long (QuestDB uses int MIN as NULL)"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"INT"}),(0,r.jsx)(s.td,{children:"64"}),(0,r.jsx)(s.td,{children:"DECIMAL(20, 0)"}),(0,r.jsx)(s.td,{children:"Full 64-bit signed range"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"UINT"}),(0,r.jsx)(s.td,{children:"< 32"}),(0,r.jsx)(s.td,{children:"int"}),(0,r.jsx)(s.td,{children:"Fits in signed int"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"UINT"}),(0,r.jsx)(s.td,{children:"32"}),(0,r.jsx)(s.td,{children:"long"}),(0,r.jsx)(s.td,{children:"Needs 33 bits for full unsigned range"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"UINT"}),(0,r.jsx)(s.td,{children:"64"}),(0,r.jsx)(s.td,{children:"DECIMAL(20, 0)"}),(0,r.jsx)(s.td,{children:"Full 64-bit unsigned range"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"FLOAT"}),(0,r.jsx)(s.td,{children:"32"}),(0,r.jsx)(s.td,{children:"float"}),(0,r.jsx)(s.td,{children:"IEEE 754 single precision"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"FLOAT"}),(0,r.jsx)(s.td,{children:"64"}),(0,r.jsx)(s.td,{children:"double"}),(0,r.jsx)(s.td,{children:"IEEE 754 double precision"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"STRING"}),(0,r.jsx)(s.td,{children:"var"}),(0,r.jsx)(s.td,{children:"varchar"}),(0,r.jsx)(s.td,{children:"Variable-length text"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"BLOCK"}),(0,r.jsx)(s.td,{children:"var"}),(0,r.jsx)(s.td,{children:"varchar"}),(0,r.jsx)(s.td,{children:"Base64-encoded binary"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"ARRAY"}),(0,r.jsx)(s.td,{children:"var"}),(0,r.jsx)(s.td,{children:"varchar"}),(0,r.jsx)(s.td,{children:"JSON-serialized arrays"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"DERIVED"}),(0,r.jsx)(s.td,{children:"var"}),(0,r.jsx)(s.td,{children:"varies"}),(0,r.jsx)(s.td,{children:"Based on converted_type/bit_size; defaults to varchar"})]})]})]}),"\n",(0,r.jsx)(s.h4,{id:"special-float-value-handling",children:"Special Float Value Handling"}),"\n",(0,r.jsx)(s.p,{children:"QuestDB does not support IEEE 754 special values directly. The following sentinel values are used:"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Special Value"}),(0,r.jsx)(s.th,{children:"64-bit (double) Sentinel"}),(0,r.jsx)(s.th,{children:"32-bit (float) Sentinel"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"Infinity"})}),(0,r.jsxs)(s.td,{children:[(0,r.jsx)(s.code,{children:"1.7976931348623155e+308"})," (near ",(0,r.jsx)(s.code,{children:"DBL_MAX"}),")"]}),(0,r.jsxs)(s.td,{children:[(0,r.jsx)(s.code,{children:"3.4028233e+38"})," (near ",(0,r.jsx)(s.code,{children:"FLT_MAX"}),")"]})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"-Infinity"})}),(0,r.jsxs)(s.td,{children:[(0,r.jsx)(s.code,{children:"-1.7976931348623155e+308"})," (near ",(0,r.jsx)(s.code,{children:"-DBL_MAX"}),")"]}),(0,r.jsxs)(s.td,{children:[(0,r.jsx)(s.code,{children:"-3.4028233e+38"})," (near ",(0,r.jsx)(s.code,{children:"-FLT_MAX"}),")"]})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.code,{children:"NaN"})}),(0,r.jsxs)(s.td,{children:[(0,r.jsx)(s.code,{children:"-1.7976931348623153e+308"})," (negative, near ",(0,r.jsx)(s.code,{children:"-DBL_MAX"}),")"]}),(0,r.jsxs)(s.td,{children:[(0,r.jsx)(s.code,{children:"-3.4028231e+38"})," (negative, near ",(0,r.jsx)(s.code,{children:"-FLT_MAX"}),")"]})]})]})]}),"\n",(0,r.jsx)(s.p,{children:"These sentinels allow special float values to be stored and retrieved without data loss."}),"\n",(0,r.jsx)(s.h4,{id:"other-limitations",children:"Other Limitations"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Integer ",(0,r.jsx)(s.code,{children:"MIN_VALUE"})," is used as NULL sentinel in QuestDB"]}),"\n",(0,r.jsx)(s.li,{children:"Arrays are always stored as JSON-serialized strings for consistency"}),"\n",(0,r.jsx)(s.li,{children:"64-bit integer values are sent as strings via ILP; QuestDB casts them to DECIMAL"}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"historical-data-migration",children:"Historical Data Migration"}),"\n",(0,r.jsxs)(s.p,{children:["COSMOS provides a ",(0,r.jsx)(s.a,{href:"https://store.openc3.com/cosmos_plugins/21",children:"migration plugin"})," for ingesting historical decommutated telemetry and command data from binary log files into QuestDB. The plugin reads COSMOS binary packet log files (",(0,r.jsx)(s.code,{children:".bin"})," and ",(0,r.jsx)(s.code,{children:".bin.gz"}),") from S3-compatible storage and batch-ingests the data into QuestDB. It processes files in reverse chronological order (newest first) and rate-limits ingestion to avoid overwhelming operational systems."]}),"\n",(0,r.jsx)(s.h3,{id:"keycloak-enterprise",children:"Keycloak (Enterprise)"}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.a,{href:"https://openc3.com/enterprise",children:"COSMOS Enterprise"})," uses ",(0,r.jsx)(s.a,{href:"https://www.keycloak.org/",children:"Keycloak"})," as its Single Sign-On (SSO) solution. Keycloak is an open-source Identity and Access Management system that provides authentication, authorization, and user federation capabilities. Keycloak implements the OAuth 2.0 and OpenID Connect protocols and issues several types of tokens to manage user sessions."]}),"\n",(0,r.jsx)(s.h4,{id:"access-token",children:"Access Token"}),"\n",(0,r.jsxs)(s.p,{children:["The access token is a short-lived JSON Web Token (JWT) used to authenticate API requests. It is included in the ",(0,r.jsx)(s.code,{children:"Authorization: Bearer <token>"})," header of HTTP requests and contains user identity and permissions (claims). When an access token expires, the client must obtain a new one using a refresh token. COSMOS Enterprise default: ",(0,r.jsx)(s.strong,{children:"5 minutes"}),"."]}),"\n",(0,r.jsx)(s.h4,{id:"refresh-token",children:"Refresh Token"}),"\n",(0,r.jsxs)(s.p,{children:["The refresh token is a longer-lived token used solely to obtain new access tokens. It is never sent to resource servers\u2014only to Keycloak's token endpoint. Each refresh request typically returns a new refresh token (token rotation). The refresh token expires after a period of inactivity (SSO Session Idle) or after a maximum lifespan (SSO Session Max), at which point the user must re-authenticate. COSMOS Enterprise defaults: ",(0,r.jsx)(s.strong,{children:"30 minutes"})," idle timeout, ",(0,r.jsx)(s.strong,{children:"10 hours"})," max lifespan."]}),"\n",(0,r.jsx)(s.h4,{id:"offline-access-token",children:"Offline Access Token"}),"\n",(0,r.jsxs)(s.p,{children:["The offline access token is a special type of refresh token designed for long-lived sessions lasting days, weeks, or indefinitely. It is obtained by requesting the ",(0,r.jsx)(s.code,{children:"offline_access"}),' scope during authentication. Unlike regular refresh tokens, offline access tokens survive Keycloak server restarts and user session logouts. They are useful for automated scripts or services that need persistent access without user interaction. Offline tokens have separate configuration settings: "Offline Session Idle" and "Offline Session Max". COSMOS Enterprise defaults: ',(0,r.jsx)(s.strong,{children:"30 days"})," idle timeout, max lifespan not enforced (tokens can last indefinitely if used regularly)."]}),"\n",(0,r.jsx)(s.h4,{id:"token-lifecycle",children:"Token Lifecycle"}),"\n",(0,r.jsx)(s.p,{children:"The typical token lifecycle works as follows:"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsx)(s.li,{children:"User authenticates with Keycloak and receives an access token and refresh token"}),"\n",(0,r.jsx)(s.li,{children:"Client uses the access token for API calls"}),"\n",(0,r.jsx)(s.li,{children:"Access token expires and client sends the refresh token to Keycloak"}),"\n",(0,r.jsx)(s.li,{children:"Keycloak issues a new access token and new refresh token"}),"\n",(0,r.jsx)(s.li,{children:"Steps 2-4 repeat until the refresh token expires or the user logs out"}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["For examples of using these tokens with curl see ",(0,r.jsx)(s.a,{href:"/docs/guides/curl",children:"Testing with Curl"}),"."]}),"\n",(0,r.jsx)(s.h4,{id:"automatic-token-refresh",children:"Automatic Token Refresh"}),"\n",(0,r.jsx)(s.p,{children:"COSMOS Enterprise automatically refreshes tokens to maintain user sessions. Every 60 seconds, the application checks if the access token will expire within the next 2 minutes. If so, it sends the current refresh token to Keycloak's token endpoint and receives both a new access token and a new refresh token."}),"\n",(0,r.jsx)(s.p,{children:"With the default 5-minute access token lifespan, this results in token refreshes approximately every 3-4 minutes. Each refresh resets the refresh token's idle timeout, keeping the session alive as long as the user has the application open."}),"\n",(0,r.jsx)(s.p,{children:"Important notes on idle timeout behavior:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"The refresh token idle timeout is only reset when the application communicates with Keycloak (i.e., during token refresh)"}),"\n",(0,r.jsxs)(s.li,{children:["Making API calls using the access token does ",(0,r.jsx)(s.strong,{children:"not"})," reset the refresh token idle timeout, because those requests never reach Keycloak"]}),"\n",(0,r.jsx)(s.li,{children:"If a user closes the browser for longer than the idle timeout (default 30 minutes), they must re-authenticate"}),"\n"]}),"\n",(0,r.jsx)(s.h4,{id:"default-token-lifespans",children:"Default Token Lifespans"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"Token Type"}),(0,r.jsx)(s.th,{children:"Setting"}),(0,r.jsx)(s.th,{children:"Default Value"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Access Token"}),(0,r.jsx)(s.td,{children:"Lifespan"}),(0,r.jsx)(s.td,{children:"5 minutes"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Refresh Token"}),(0,r.jsx)(s.td,{children:"Idle Timeout"}),(0,r.jsx)(s.td,{children:"30 minutes"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Refresh Token"}),(0,r.jsx)(s.td,{children:"Max Lifespan"}),(0,r.jsx)(s.td,{children:"10 hours"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Offline Token"}),(0,r.jsx)(s.td,{children:"Idle Timeout"}),(0,r.jsx)(s.td,{children:"30 days"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"Offline Token"}),(0,r.jsx)(s.td,{children:"Max Lifespan"}),(0,r.jsx)(s.td,{children:"Not enforced"})]})]})]})]})}function h(e={}){let{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8738:function(e,s,t){t.d(s,{A:()=>n});let n=t.p+"assets/images/core-architecture-192b1c75dfd8a01f6eda9db65ca5f30f1572b8102ed8c9130d0d1fc36fde3df7.png"},1400:function(e,s,t){t.d(s,{A:()=>n});let n=t.p+"assets/images/cosmos-containers-6754f5128cfa944405a0a09076dc79de5b147756ec98504f5800e0ba74287228.png"},5114:function(e,s,t){t.d(s,{A:()=>n});let n=t.p+"assets/images/cosmos-images-b4c0e15d1daf7324b9995197faaf6d4da8ad5e0457fe0d93300a28d610566845.png"},3934:function(e,s,t){t.d(s,{A:()=>n});let n=t.p+"assets/images/enterprise-architecture-b10f2bb71acf3bc88294ccd52fab60d77b008a8a8db9fb6b26620c0d0403c738.png"},9496:function(e,s,t){t.d(s,{R:()=>o,x:()=>a});var n=t(9471);let r={},i=n.createContext(r);function o(e){let s=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);