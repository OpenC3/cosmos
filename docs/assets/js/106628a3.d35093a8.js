"use strict";(self.webpackChunkdocs_openc3_com=self.webpackChunkdocs_openc3_com||[]).push([["6111"],{1722:function(e,t,n){n.r(t),n.d(t,{metadata:()=>a,default:()=>p,frontMatter:()=>r,contentTitle:()=>c,toc:()=>l,assets:()=>o});var a=JSON.parse('{"id":"guides/subpackets","title":"Subpackets and Channels","description":"How COSMOS handles channelized telemetry and different time series","source":"@site/docs/guides/subpackets.md","sourceDirName":"guides","slug":"/guides/subpackets","permalink":"/docs/guides/subpackets","draft":false,"unlisted":false,"editUrl":"https://github.com/OpenC3/cosmos/tree/main/docs.openc3.com/docs/guides/subpackets.md","tags":[],"version":"current","frontMatter":{"title":"Subpackets and Channels","description":"How COSMOS handles channelized telemetry and different time series","sidebar_custom_props":{"myEmoji":"\u{1F9E9}"}},"sidebar":"defaultSidebar","previous":{"title":"Scripting API Guide","permalink":"/docs/guides/scripting-api"},"next":{"title":"Troubleshooting","permalink":"/docs/guides/troubleshooting"}}'),s=n(2615),i=n(9496);let r={title:"Subpackets and Channels",description:"How COSMOS handles channelized telemetry and different time series",sidebar_custom_props:{myEmoji:"\u{1F9E9}"}},c,o={},l=[{value:"Channelized Telemetry",id:"channelized-telemetry",level:2},{value:"Repeated Values in the Same Packet",id:"repeated-values-in-the-same-packet",level:2},{value:"Optional content",id:"optional-content",level:2},{value:"Defining a Subpacket",id:"defining-a-subpacket",level:2},{value:"Defining a Subpacketizer",id:"defining-a-subpacketizer",level:2}];function d(e){let t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components},{TabItem:n,Tabs:a}=t;return n||h("TabItem",!0),a||h("Tabs",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"The unit of processing within COSMOS is a packet. Telemetry packets coming into COSMOS are delineated and identified in Interfaces, and sometimes the same is done for commands being received by Routers."}),"\n",(0,s.jsx)(t.p,{children:"Packets are also the unit of data that COSMOS keeps track of with timestamps. Each packet has a received time (the time that COSMOS received the packet), and a packet time (the real time that the packet data was generated which is usually derived from the packet's own data). If no packet time is available then packet time is set to the received time."}),"\n",(0,s.jsxs)(t.p,{children:["Each packet item therefore is part of a time-series with one sample per packet which can be graphed in ",(0,s.jsx)(t.a,{href:"/docs/tools/tlm-grapher",children:"Telemetry Grapher"}),", extracted by ",(0,s.jsx)(t.a,{href:"/docs/tools/data-extractor",children:"Data Extractor"})," or played back in ",(0,s.jsx)(t.a,{href:"/docs/tools/tlm-viewer",children:"Telemetry Viewer"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"However there are three primary use cases where this abstraction doesn't work as well as desired."}),"\n",(0,s.jsx)(t.h2,{id:"channelized-telemetry",children:"Channelized Telemetry"}),"\n",(0,s.jsx)(t.p,{children:"Systems that produce channelized telemetry generally send down a single packet of telemetry that has variable content. The content within these packets are called channels."}),"\n",(0,s.jsx)(t.p,{children:"Each channel has some form of id field that allows you to identify the channel data. Sometimes each channel has its own timestamp and sometimes the packet timestamp is applied to each channel."}),"\n",(0,s.jsx)(t.p,{children:"For example, you might have a 32-bit id field, followed by a 64-bit timestamp field, followed by a structure that is unknown until you look up what the 32-bit id field references."}),"\n",(0,s.jsx)(t.p,{children:"Channelized telemetry packets are therefore very dynamic and until COSMOS 6.10 were very difficult to define."}),"\n",(0,s.jsxs)(t.p,{children:["COSMOS 6.10 introduced the concepts of ",(0,s.jsx)(t.a,{href:"/docs/configuration/telemetry#subpacket",children:"SUBPACKET"})," and ",(0,s.jsx)(t.a,{href:"/docs/configuration/telemetry#subpacketizer",children:"SUBPACKETIZER"})," in order to handle channelized telemetry (and the other use case described below)."]}),"\n",(0,s.jsx)(t.h2,{id:"repeated-values-in-the-same-packet",children:"Repeated Values in the Same Packet"}),"\n",(0,s.jsx)(t.p,{children:"The other use case for subpackets is when you have a single packet that has a lot of samples of the same data point in the same packet. Historically COSMOS would put all of these samples into an array item but that has several downsides."}),"\n",(0,s.jsxs)(t.p,{children:["The primary downside is that you couldn't graph the data like a time series in ",(0,s.jsx)(t.a,{href:"/docs/tools/tlm-grapher",children:"Telemetry Grapher"}),". Each of the samples generally has its own timestamp (typically derived from a known data rate), but that wasn't usable in ",(0,s.jsx)(t.a,{href:"/docs/tools/tlm-grapher",children:"Telemetry Grapher"}),", because there is only one timestamp per packet."]}),"\n",(0,s.jsxs)(t.p,{children:["Using a ",(0,s.jsx)(t.a,{href:"/docs/configuration/telemetry#subpacketizer",children:"SUBPACKETIZER"})," to breakup each sample into its own ",(0,s.jsx)(t.a,{href:"/docs/configuration/telemetry#subpacket",children:"SUBPACKET"})," solves this problem, and makes the entire series of subpackets available to ",(0,s.jsx)(t.a,{href:"/docs/tools/tlm-grapher",children:"Telemetry Grapher"})," to graph."]}),"\n",(0,s.jsx)(t.h2,{id:"optional-content",children:"Optional content"}),"\n",(0,s.jsx)(t.p,{children:"COSMOS packet definitions expect every item in the packet to be present. Subpackets can also be used for optional content by having the Subpacketizer only return the optional content if it is present."}),"\n",(0,s.jsx)(t.h2,{id:"defining-a-subpacket",children:"Defining a Subpacket"}),"\n",(0,s.jsxs)(t.p,{children:["Defining a ",(0,s.jsx)(t.a,{href:"/docs/configuration/telemetry#subpacket",children:"SUBPACKET"})," is easy. All it requires is adding the SUBPACKET keyword to the packet definition. Note that both commands and telemetry packets can be marked as ",(0,s.jsx)(t.a,{href:"/docs/configuration/telemetry#subpacket",children:"SUBPACKET"}),", but only telemetry is currently processed in any meaningful way."]}),"\n",(0,s.jsx)(t.p,{children:"Subpackets will generally have id fields that the subpacketizer code can use to differentiate them."}),"\n",(0,s.jsxs)(t.p,{children:["Here is an example of what would be one of many possible subpackets in a channelized telemetry scenario in F-Prime. Note that the packet has the ",(0,s.jsx)(t.a,{href:"/docs/configuration/telemetry#subpacket",children:"SUBPACKET"})," marking, and includes ID items:"]}),"\n",(0,s.jsxs)(a,{groupId:"script-language",children:[(0,s.jsx)(n,{value:"python",label:"Python Subpacketizer",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'TELEMETRY <%= target_name %> ServerDeployment.rateGroup3.RgMaxTime BIG_ENDIAN "Max execution time rate group"\n  SUBPACKET\n  APPEND_ID_ITEM FPRIME_CHANNEL_ID 32 UINT 1024\n  APPEND_ITEM FPRIME_TIMEBASE 16 UINT\n    STATE TB_NONE 0 # No time base has been established\n    STATE TB_PROC_TIME 1 # Indicates time is processor cycle time. Not tied to external time\n    STATE TB_WORKSTATION_TIME 2 # Time as reported on workstation where software is running\n    STATE TB_DONT_CARE 0xFFFF\n  APPEND_ITEM FPRIME_CONTEXT 8 UINT\n  APPEND_ITEM FPRIME_TIME_SEC 32 UINT\n  APPEND_ITEM FPRIME_TIME_USEC 32 UINT\n  APPEND_ITEM RgMaxTime 32 UINT "Max execution time rate group"\n  ITEM PACKET_TIME 0 0 DERIVED "Python time based on FPRIME_TIME_SEC and FPRIME_TIME_USEC"\n    READ_CONVERSION openc3/conversions/unix_time_conversion.py FPRIME_TIME_SEC FPRIME_TIME_USEC\n'})})}),(0,s.jsx)(n,{value:"ruby",label:"Ruby Subpacketizer",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ruby",children:'TELEMETRY <%= target_name %> ServerDeployment.rateGroup3.RgMaxTime BIG_ENDIAN "Max execution time rate group"\n  SUBPACKET\n  APPEND_ID_ITEM FPRIME_CHANNEL_ID 32 UINT 1024\n  APPEND_ITEM FPRIME_TIMEBASE 16 UINT\n    STATE TB_NONE 0 # No time base has been established\n    STATE TB_PROC_TIME 1 # Indicates time is processor cycle time. Not tied to external time\n    STATE TB_WORKSTATION_TIME 2 # Time as reported on workstation where software is running\n    STATE TB_DONT_CARE 0xFFFF\n  APPEND_ITEM FPRIME_CONTEXT 8 UINT\n  APPEND_ITEM FPRIME_TIME_SEC 32 UINT\n  APPEND_ITEM FPRIME_TIME_USEC 32 UINT\n  APPEND_ITEM RgMaxTime 32 UINT "Max execution time rate group"\n  ITEM PACKET_TIME 0 0 DERIVED "Ruby time based on FPRIME_TIME_SEC and FPRIME_TIME_USEC"\n    READ_CONVERSION unix_time_conversion.rb FPRIME_TIME_SEC FPRIME_TIME_USEC\n'})})})]}),"\n",(0,s.jsx)(t.h2,{id:"defining-a-subpacketizer",children:"Defining a Subpacketizer"}),"\n",(0,s.jsxs)(t.p,{children:["A ",(0,s.jsx)(t.a,{href:"/docs/configuration/telemetry#subpacketizer",children:"SUBPACKETIZER"})," is added to the parent packet with the code necessary to break it up into any internal subpackets."]}),"\n",(0,s.jsx)(t.p,{children:"Subpackets receive the parent packet as input and return an array of packets and subpackets as output. They can return as many subpackets as necessary, including no subpackets. Note that if the parent packet is not returned, then it will not be processed."}),"\n",(0,s.jsx)(t.p,{children:"The following is an example Subpacketizer class that works with the F-Prime Flight Software. Note that this is just one example. A Subpacketizer can contain whatever code necessary to break the packet into subpackets."}),"\n",(0,s.jsxs)(a,{groupId:"script-language",children:[(0,s.jsxs)(n,{value:"python",label:"Python Subpacketizer",children:[(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-python",children:'from openc3.subpacketizers.subpacketizer import Subpacketizer\nfrom openc3.system.system import System\n\nclass FprimeSubpacketizer(Subpacketizer):\n    def call(self, packet):\n        # Create a list of packets to return\n        packets = []\n\n        # Read the packet item "CHANNELS" which contains all the subpackets\n        channels = packet.read("CHANNELS")\n\n        # While we still have data to process\n        while len(channels) > 0:\n            # Identify the next subpacket using the entire block of data\n            subpacket = System.telemetry.identify(channels, target_names=[packet.target_name], subpackets=True)\n\n            if subpacket:\n                # If it identified then breakout the subpacket content based on fixed size\n                # (like the FIXED protocol)\n                subpacket.buffer = channels[:subpacket.defined_length]\n                subpacket = subpacket.clone()\n\n                # Add to list of subpackets to return\n                packets.append(subpacket)\n\n                # Remove this subpacket from the block of data\n                channels = channels[subpacket.defined_length:]\n            else:\n                # If we can\'t identify then just give up\n                break\n\n        # Append the parent packet so it gets processed too\n        packets.append(packet)\n\n        # Return the parent packet and subpackets\n        return packets\n'})}),(0,s.jsx)(t.p,{children:"The Subpacketizer is then referenced in a packet definition like this:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'TELEMETRY <%= target_name %> TELEMETRY BIG_ENDIAN "Channelized Telemetry Packet"\n  SUBPACKETIZER fprime_subpacketizer.py\n  APPEND_ITEM FPRIME_SIZE 32 UINT\n  APPEND_ID_ITEM FPRIME_PACKET_ID 32 UINT 1\n  APPEND_ITEM CHANNELS -32 BLOCK\n    HIDDEN\n  ITEM CRC32 -32 32 UINT\n'})})]}),(0,s.jsxs)(n,{value:"ruby",label:"Ruby Subpacketizer",children:[(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ruby",children:'require "openc3/subpacketizers/subpacketizer"\nrequire "openc3/system/system"\n\nmodule OpenC3\n  class FprimeSubpacketizer < Subpacketizer\n    def call(packet)\n      # Create an array of packets to return\n      packets = []\n\n      # Read the packet item "CHANNELS" which contains all the subpackets\n      channels = packet.read("CHANNELS")\n\n      # While we still have data to process\n      while channels.length > 0\n        # Identify the next subpacket using the entire block of data\n        subpacket = System.telemetry.identify(channels, [packet.target_name], subpackets: true)\n        if subpacket\n          # If it identified then breakout the subpacket content based on fixed size\n          # (like the FIXED protocol)\n          subpacket.buffer = channels[0...subpacket.defined_length]\n          subpacket = subpacket.clone()\n\n          # Add to list of subpackets to return\n          packets << subpacket\n\n          # Remove this subpacket from the block of data\n          channels = channels[subpacket.defined_length..-1]\n        else\n          # If we can\'t identify then just give up\n          break\n        end\n      end\n\n      # Append the parent packet so it gets processed too\n      packets << packet\n\n      # Return the parent packet and subpackets\n      return packets\n    end\n  end\nend\n'})}),(0,s.jsx)(t.p,{children:"The Subpacketizer is then referenced in a packet definition like this:"}),(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:'TELEMETRY <%= target_name %> TELEMETRY BIG_ENDIAN "Channelized Telemetry Packet"\n  SUBPACKETIZER fprime_subpacketizer.rb\n  APPEND_ITEM FPRIME_SIZE 32 UINT\n  APPEND_ID_ITEM FPRIME_PACKET_ID 32 UINT 1\n  APPEND_ITEM CHANNELS -32 BLOCK\n    HIDDEN\n  ITEM CRC32 -32 32 UINT\n'})})]})]})]})}function p(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}function h(e,t){throw Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}},9496:function(e,t,n){n.d(t,{R:()=>r,x:()=>c});var a=n(9471);let s={},i=a.createContext(s);function r(e){let t=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);