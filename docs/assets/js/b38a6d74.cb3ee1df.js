"use strict";(self.webpackChunkdocs_openc3_com=self.webpackChunkdocs_openc3_com||[]).push([["7481"],{6659:function(e,n,s){s.r(n),s.d(n,{frontMatter:()=>t,default:()=>h,toc:()=>a,metadata:()=>r,assets:()=>l,contentTitle:()=>c});var r=JSON.parse('{"id":"configuration/conversions","title":"Conversions","description":"Conversions to apply to command parameters and telemetry items","source":"@site/docs/configuration/conversions.md","sourceDirName":"configuration","slug":"/configuration/conversions","permalink":"/docs/configuration/conversions","draft":false,"unlisted":false,"editUrl":"https://github.com/OpenC3/cosmos/tree/main/docs.openc3.com/docs/configuration/conversions.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"sidebar_position":9,"title":"Conversions","description":"Conversions to apply to command parameters and telemetry items","sidebar_custom_props":{"myEmoji":"\uD83D\uDD04"}},"sidebar":"defaultSidebar","previous":{"title":"Accessors","permalink":"/docs/configuration/accessors"},"next":{"title":"Processors","permalink":"/docs/configuration/processors"}}'),i=s(5893),o=s(65);let t={sidebar_position:9,title:"Conversions",description:"Conversions to apply to command parameters and telemetry items",sidebar_custom_props:{myEmoji:"\uD83D\uDD04"}},c="Overview",l={},a=[{value:"Custom Conversions",id:"custom-conversions",level:2},{value:"converted_type",id:"converted_type",level:3},{value:"converted_bit_size",id:"converted_bit_size",level:3},{value:"call",id:"call",level:3},{value:"Apply Conversion",id:"apply-conversion",level:3},{value:"BIT_REVERSE_CONVERSION",id:"bit_reverse_conversion",level:2},{value:"IP_READ_CONVERSION",id:"ip_read_conversion",level:2},{value:"IP_WRITE_CONVERSION",id:"ip_write_conversion",level:2},{value:"OBJECT_READ_CONVERSION",id:"object_read_conversion",level:2},{value:"OBJECT_WRITE_CONVERSION",id:"object_write_conversion",level:2},{value:"PACKET_TIME_FORMATTED_CONVERSION",id:"packet_time_formatted_conversion",level:2},{value:"PACKET_TIME_SECONDS_CONVERSION",id:"packet_time_seconds_conversion",level:2},{value:"POLYNOMIAL_CONVERSION",id:"polynomial_conversion",level:2},{value:"PROCESSOR_CONVERSION",id:"processor_conversion",level:2},{value:"RECEIVED_COUNT_CONVERSION",id:"received_count_conversion",level:2},{value:"RECEIVED_TIME_FORMATTED_CONVERSION",id:"received_time_formatted_conversion",level:2},{value:"RECEIVED_TIME_SECONDS_CONVERSION",id:"received_time_seconds_conversion",level:2},{value:"SEGMENTED_POLYNOMIAL_CONVERSION",id:"segmented_polynomial_conversion",level:2},{value:"UNIX_TIME_CONVERSION",id:"unix_time_conversion",level:2},{value:"UNIX_TIME_FORMATTED_CONVERSION",id:"unix_time_formatted_conversion",level:2},{value:"UNIX_TIME_SECONDS_CONVERSION",id:"unix_time_seconds_conversion",level:2}];function d(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"overview",children:"Overview"})}),"\n",(0,i.jsxs)(n.p,{children:["Conversions can be applied to both command parameters and telemetry items to modify the values sent to and received from targets. To apply a conversion to a command you use the ",(0,i.jsx)(n.a,{href:"/docs/configuration/command#write_conversion",children:"WRITE_CONVERSION"})," keyword. To apply a conversion to a telemetry item you use the ",(0,i.jsx)(n.a,{href:"/docs/configuration/telemetry#read_conversion",children:"READ_CONVERSION"})," keyword."]}),"\n",(0,i.jsx)(n.h2,{id:"custom-conversions",children:"Custom Conversions"}),"\n",(0,i.jsxs)(n.p,{children:["You can easily create your own custom conversions by using the ",(0,i.jsx)(n.a,{href:"/docs/getting-started/generators#conversion-generator",children:"Conversion Code Generator"}),". To generate a telemetry conversion you must be inside an existing COSMOS plugin. The generator takes both a target name and the conversion name. For example if your plugin is called ",(0,i.jsx)(n.code,{children:"openc3-cosmos-gse"})," and you have an existing target named ",(0,i.jsx)(n.code,{children:"GSE"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"openc3-cosmos-gse % openc3.sh cli generate conversion GSE double --python\nConversion targets/GSE/lib/double_conversion.py successfully generated!\nTo use the conversion add the following to a telemetry item:\n  READ_CONVERSION double_conversion.py\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note: To create a Ruby conversion simply replace ",(0,i.jsx)(n.code,{children:"--python"})," with ",(0,i.jsx)(n.code,{children:"--ruby"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The above command creates a conversion called ",(0,i.jsx)(n.code,{children:"double_conversion.py"})," at ",(0,i.jsx)(n.code,{children:"targets/GSE/lib/double_conversion.py"}),". The code which is generated looks like the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from openc3.conversions.conversion import Conversion\n# Using tlm() requires the following:\n# from openc3.api.tlm_api import tlm\n\n# Custom conversion class\n# See https://docs.openc3.com/docs/configuration/telemetry#read_conversion\nclass DoubleConversion(Conversion):\n    def __init__(self):\n        super().__init__()\n        # Should be one of 'INT', 'UINT', 'FLOAT', 'STRING', 'BLOCK'\n        self.converted_type = 'STRING'\n        # Size of the converted type in bits\n        # Use 0 for 'STRING' or 'BLOCK' where the size can be variable\n        self.converted_bit_size = 0\n\n    # @param value [Object] Value based on the item definition. This could be\n    #   a string, integer, float, or array of values.\n    # @param packet [Packet] The packet object where the conversion is defined\n    # @param buffer [String] The raw packet buffer\n    def call(self, value, packet, buffer):\n        # Read values from the packet and do a conversion\n        # Used for DERIVED items that don't have a value\n        # item1 = packet.read(\"ITEM1\") # returns CONVERTED value (default)\n        # item2 = packet.read(\"ITEM2\", 'RAW') # returns RAW value\n        # return (item1 + item2) / 2\n        #\n        # Perform conversion logic directly on value\n        # Used when conversion is applied to a regular (not DERIVED) item\n        # NOTE: You can also use packet.read(\"ITEM\") to get additional values\n        # return value / 2 * packet.read(\"OTHER_ITEM\")\n        return value\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There are a lot of comments to help you know what to do. The primary things to modify are the ",(0,i.jsx)(n.code,{children:"converted_type"}),", ",(0,i.jsx)(n.code,{children:"converted_bit_size"}),", and ",(0,i.jsx)(n.code,{children:"call"})," method."]}),"\n",(0,i.jsx)(n.h3,{id:"converted_type",children:"converted_type"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"converted_type"})," is the resulting type of the converted value. It lets consumers of the converted value know the resulting type. In our case we're doubling the input value and since this could be applied to an unsigned integer as well as a floating point value we'll choose ",(0,i.jsx)(n.code,{children:"FLOAT"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"    self.converted_type = 'FLOAT'\n"})}),"\n",(0,i.jsx)(n.h3,{id:"converted_bit_size",children:"converted_bit_size"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"converted_bit_size"})," is the resulting size of the converted value. It lets consumers of the converted value know the resulting size. Since we chose ",(0,i.jsx)(n.code,{children:"FLOAT"})," as the type we'll choose ",(0,i.jsx)(n.code,{children:"32"})," as the bit size. We could have also chosen ",(0,i.jsx)(n.code,{children:"64"})," bits. Sometimes you know the type and size of the resulting conversion and can simply hard code them. Other times you need to pass them in as parameters and let the user decide."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"    self.converted_bit_size = 32\n"})}),"\n",(0,i.jsx)(n.h3,{id:"call",children:"call"}),"\n",(0,i.jsx)(n.p,{children:"The call method is where the actual conversion logic is implemented. In our case we want to double the input value so we simply return the value multiplied by 2. The final result with comments removed looks like the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from openc3.conversions.conversion import Conversion\nclass DoubleConversion(Conversion):\n    def __init__(self):\n        super().__init__()\n        self.converted_type = 'FLOAT'\n        self.converted_bit_size = 32\n\n    def call(self, value, packet, buffer):\n        return value * 2\n"})}),"\n",(0,i.jsx)(n.h3,{id:"apply-conversion",children:"Apply Conversion"}),"\n",(0,i.jsxs)(n.p,{children:["Now that we have implemented the conversion logic we need to apply it to a telemetry item by adding the line ",(0,i.jsx)(n.code,{children:"READ_CONVERSION double_conversion.py"})," in the ",(0,i.jsx)(n.a,{href:"/docs/configuration/telemetry",children:"telemetry"})," definition file. This could look something like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'TELEMETRY GSE DATA BIG_ENDIAN "Data packet"\n  ... # Header items\n  APPEND_ITEM VALUE 16 UINT "Value I want to double"\n    READ_CONVERSION double_conversion.py\n'})}),"\n",(0,i.jsx)(n.h1,{id:"built-in-conversions",children:"Built-in Conversions"}),"\n",(0,i.jsx)(n.h2,{id:"bit_reverse_conversion",children:"BIT_REVERSE_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Reverses the bits of the current telemetry item. Can be used as both a read and write conversion."})}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION bit_reverse_conversion.rb\nWRITE_CONVERSION bit_reverse_conversion.rb\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/bit_reverse_conversion.py\nWRITE_CONVERSION openc3/conversions/bit_reverse_conversion.py\n"})}),"\n",(0,i.jsx)(n.h2,{id:"ip_read_conversion",children:"IP_READ_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Reads a packed 32 bit integer into an IP address string"})}),"\n",(0,i.jsx)(n.p,{children:"This command reads a packed 32 bit integer into an IP address string.\nFor example, 0xFFFF8000 would be converted to '255.255.128.0'."}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION ip_read_conversion.rb\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/ip_read_conversion.py\n"})}),"\n",(0,i.jsx)(n.h2,{id:"ip_write_conversion",children:"IP_WRITE_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Write an ip address string into a packed 32 bit integer"})}),"\n",(0,i.jsx)(n.p,{children:"This command writes an IP address string into a packed 32 bit integer. The IP address\nstring should be in the format 'x.x.x.x' where x is a number between 0 and 255.\nFor example, '255.255.128.0' would be converted to 0xFFFF8000."}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"WRITE_CONVERSION ip_write_conversion.rb\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"WRITE_CONVERSION openc3/conversions/ip_write_conversion.py\n"})}),"\n",(0,i.jsx)(n.h2,{id:"object_read_conversion",children:"OBJECT_READ_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Reads values from the given packet object"})}),"\n",(0,i.jsx)(n.p,{children:"This command reads all the values from the given packet object. The values are\nreturned as a Ruby hash or Python dict. The packet object must be defined in the target's configuration."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Required"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Command or Telemetry"}),(0,i.jsxs)(n.td,{children:["Whether the packet is a command or telemetry",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Valid Values: ",(0,i.jsx)("span",{class:"values",children:"CMD, TLM"})]}),(0,i.jsx)(n.td,{children:"True"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Target Name"}),(0,i.jsx)(n.td,{children:"Name of the target"}),(0,i.jsx)(n.td,{children:"True"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Packet Name"}),(0,i.jsx)(n.td,{children:"Name of the packet"}),(0,i.jsx)(n.td,{children:"True"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION object_read_conversion.rb CMD INST COLLECT\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/object_read_conversion.py CMD INST COLLECT\n"})}),"\n",(0,i.jsx)(n.h2,{id:"object_write_conversion",children:"OBJECT_WRITE_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Writes values into the given packet object"})}),"\n",(0,i.jsx)(n.p,{children:"This command writes values into the given packet object. The values are specified\nin a hash format where the keys are the field names in the packet and the values\nare the values to write. The packet object must be defined in the target's configuration."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Required"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Command or Telemetry"}),(0,i.jsxs)(n.td,{children:["Whether the packet is a command or telemetry",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Valid Values: ",(0,i.jsx)("span",{class:"values",children:"CMD, TLM"})]}),(0,i.jsx)(n.td,{children:"True"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Target Name"}),(0,i.jsx)(n.td,{children:"Name of the target"}),(0,i.jsx)(n.td,{children:"True"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Packet Name"}),(0,i.jsx)(n.td,{children:"Name of the packet"}),(0,i.jsx)(n.td,{children:"True"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"WRITE_CONVERSION object_write_conversion.rb CMD INST COLLECT\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"WRITE_CONVERSION openc3/conversions/object_write_conversion.py CMD INST COLLECT\n"})}),"\n",(0,i.jsx)(n.h2,{id:"packet_time_formatted_conversion",children:"PACKET_TIME_FORMATTED_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:['Converts the packet time to a formatted string like "YYYY/MM/DD HH:MM',":SS",'.US"']})}),"\n",(0,i.jsxs)(n.p,{children:["This in an internal conversion which is automatically applied to the\n'PACKET_TIMEFORMATTED' derived telemetry item. It is typically not explicitly used.\nFor more information see the ",(0,i.jsx)(n.a,{href:"/docs/configuration/telemetry#received-time-and-packet-time",children:"Received Time and Packet Time"})," documentation."]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION packet_time_formatted_conversion.rb\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/packet_time_formatted_conversion.py\n"})}),"\n",(0,i.jsx)(n.h2,{id:"packet_time_seconds_conversion",children:"PACKET_TIME_SECONDS_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Converts the packet time to a floating point number of seconds since the epoch"})}),"\n",(0,i.jsxs)(n.p,{children:["This in an internal conversion which is automatically applied to the\n'PACKET_TIMESECONDS' derived telemetry item. It is typically not explicitly used.\nFor more information see the ",(0,i.jsx)(n.a,{href:"/docs/configuration/telemetry#received-time-and-packet-time",children:"Received Time and Packet Time"})," documentation."]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION packet_time_seconds_conversion.rb\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/packet_time_seconds_conversion.py\n"})}),"\n",(0,i.jsx)(n.h2,{id:"polynomial_conversion",children:"POLYNOMIAL_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Adds a polynomial conversion factor to the current item. Can be used as both a read and write conversion."})}),"\n",(0,i.jsx)(n.p,{children:"For commands, the conversion factor is applied to raw value set by the user (via tool or script) before it is written into the binary command packet and sent. For telemetry, the conversion factor is applied to the raw value in the telemetry packet before it is displayed to the user. The user still has the ability to see the raw unconverted value in a details dialog."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Required"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"C0"}),(0,i.jsx)(n.td,{children:"Coefficient"}),(0,i.jsx)(n.td,{children:"True"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Cx"}),(0,i.jsx)(n.td,{children:"Additional coefficient values for the conversion. Any order polynomial conversion may be used so the value of 'x' will vary with the order of the polynomial. Note that larger order polynomials take longer to process than shorter order polynomials, but are sometimes more accurate."}),(0,i.jsx)(n.td,{children:"False"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION polynomial_conversion.rb 10 0.5 0.25\n# Since this is a common conversion it has an alias:\nPOLY_READ_CONVERSION 10 0.5 0.25\n\nWRITE_CONVERSION polynomial_conversion.rb 10 0.5 0.25\n# Since this is a common conversion it has an alias:\nPOLY_WRITE_CONVERSION 10 0.5 0.25\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/polynomial_conversion.py 10 0.5 0.25\n# Since this is a common conversion it has an alias:\nPOLY_READ_CONVERSION 10 0.5 0.25\n\nWRITE_CONVERSION openc3/conversions/polynomial_conversion.py 10 0.5 0.25\n# Since this is a common conversion it has an alias:\nPOLY_WRITE_CONVERSION 10 0.5 0.25\n"})}),"\n",(0,i.jsx)(n.h2,{id:"processor_conversion",children:"PROCESSOR_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Read a value from a processor"})}),"\n",(0,i.jsxs)(n.p,{children:["This command reads a value from a processor. The value is read from the\nprocessor's available values. The processor must be defined in the target's configuration.\nSee the ",(0,i.jsx)(n.a,{href:"/docs/configuration/processors",children:"Processor"})," documentation for more information."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Required"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Processor Name"}),(0,i.jsx)(n.td,{children:"Name of the processor"}),(0,i.jsx)(n.td,{children:"True"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Processor Value"}),(0,i.jsx)(n.td,{children:"Published processor value"}),(0,i.jsx)(n.td,{children:"True"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'PROCESSOR TEMP1WATER watermark_processor.rb TEMP1\nITEM TEMP1HIGH 0 0 DERIVED "High-water mark for TEMP1"\n  READ_CONVERSION processor_conversion.rb TEMP1WATER HIGH_WATER\n'})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'PROCESSOR TEMP1WATER openc3/conversions/watermark_processor.py TEMP1\nITEM TEMP1HIGH 0 0 DERIVED "High-water mark for TEMP1"\n  READ_CONVERSION openc3/conversions/processor_conversion.py TEMP1WATER HIGH_WATER\n'})}),"\n",(0,i.jsx)(n.h2,{id:"received_count_conversion",children:"RECEIVED_COUNT_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Converts the packet received count to a UINT 32 value"})}),"\n",(0,i.jsx)(n.p,{children:"This in an internal conversion which is automatically applied to the\n'RECEIVED_COUNT' derived telemetry item. It is typically not explicitly used."}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION received_count_conversion.rb\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/received_count_conversion.py\n"})}),"\n",(0,i.jsx)(n.h2,{id:"received_time_formatted_conversion",children:"RECEIVED_TIME_FORMATTED_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:['Converts the packet received time to a formatted string like "YYYY/MM/DD HH:MM',":SS",'.US"']})}),"\n",(0,i.jsxs)(n.p,{children:["This in an internal conversion which is automatically applied to the\n'RECEIVED_TIMEFORMATTED' derived telemetry item. It is typically not explicitly used.\nFor more information see the ",(0,i.jsx)(n.a,{href:"/docs/configuration/telemetry#received-time-and-packet-time",children:"Received Time and Packet Time"})," documentation."]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION received_time_formatted_conversion.rb\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/received_time_formatted_conversion.py\n"})}),"\n",(0,i.jsx)(n.h2,{id:"received_time_seconds_conversion",children:"RECEIVED_TIME_SECONDS_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Converts the packet received to a floating point number of seconds since the epoch"})}),"\n",(0,i.jsxs)(n.p,{children:["This in an internal conversion which is automatically applied to the\n'RECEIVED_TIMESECONDS' derived telemetry item. It is typically not explicitly used.\nFor more information see the ",(0,i.jsx)(n.a,{href:"/docs/configuration/telemetry#received-time-and-packet-time",children:"Received Time and Packet Time"})," documentation."]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION received_time_formatted_conversion.rb\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/received_time_formatted_conversion.py\n"})}),"\n",(0,i.jsx)(n.h2,{id:"segmented_polynomial_conversion",children:"SEGMENTED_POLYNOMIAL_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Adds a segmented polynomial conversion factor to the current item. Can be used as both a read and write conversion."})}),"\n",(0,i.jsx)(n.p,{children:"For commands, this conversion factor is applied to the raw value set by the user (via tool or script) before it is written into the binary command packet and sent. For telemetry, the conversion factor is applied to the raw value in the telemetry packet before it is displayed to the user. The user still has the ability to see the raw unconverted value in a details dialog."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Required"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Lower Bound"}),(0,i.jsx)(n.td,{children:"Defines the lower bound of the range of values that this segmented polynomial applies to. Is ignored for the segment with the smallest lower bound."}),(0,i.jsx)(n.td,{children:"True"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"C0"}),(0,i.jsx)(n.td,{children:"Coefficient"}),(0,i.jsx)(n.td,{children:"True"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Cx"}),(0,i.jsx)(n.td,{children:"Additional coefficient values for the conversion. Any order polynomial conversion may be used so the value of 'x' will vary with the order of the polynomial. Note that larger order polynomials take longer to process than shorter order polynomials, but are sometimes more accurate."}),(0,i.jsx)(n.td,{children:"False"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION segmented_polynomial_conversion.rb 0 10 0.5 0.25 # Apply the conversion to all values < 50\n# Since this is a common conversion it has an alias:\nSEG_POLY_READ_CONVERSION 10 0.5 0.25 0 10 0.5 0.25 # Apply the conversion to all values < 50\nSEG_POLY_READ_CONVERSION 50 11 0.5 0.275 # Apply the conversion to all values >= 50 and < 100\nSEG_POLY_READ_CONVERSION 100 12 0.5 0.3 # Apply the conversion to all values >= 100\n\nWRITE_CONVERSION segmented_polynomial_conversion.rb 0 10 0.5 0.25 # Apply the conversion to all values < 50\n# Since this is a common conversion it has an alias:\nSEG_POLY_WRITE_CONVERSION 10 0.5 0.25 0 10 0.5 0.25 # Apply the conversion to all values < 50\nSEG_POLY_WRITE_CONVERSION 50 11 0.5 0.275 # Apply the conversion to all values >= 50 and < 100\nSEG_POLY_WRITE_CONVERSION 100 12 0.5 0.3 # Apply the conversion to all values >= 100\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/segmented_polynomial_conversion.py 0 10 0.5 0.25 # Apply the conversion to all values < 50\n# Since this is a common conversion it has an alias:\nSEG_POLY_READ_CONVERSION 10 0.5 0.25 0 10 0.5 0.25 # Apply the conversion to all values < 50\nSEG_POLY_READ_CONVERSION 50 11 0.5 0.275 # Apply the conversion to all values >= 50 and < 100\nSEG_POLY_READ_CONVERSION 100 12 0.5 0.3 # Apply the conversion to all values >= 100\n\nWRITE_CONVERSION openc3/conversions/segmented_polynomial_conversion.py 0 10 0.5 0.25 # Apply the conversion to all values < 50\n# Since this is a common conversion it has an alias:\nSEG_POLY_WRITE_CONVERSION 10 0.5 0.25 0 10 0.5 0.25 # Apply the conversion to all values < 50\nSEG_POLY_WRITE_CONVERSION 50 11 0.5 0.275 # Apply the conversion to all values >= 50 and < 100\nSEG_POLY_WRITE_CONVERSION 100 12 0.5 0.3 # Apply the conversion to all values >= 100\n"})}),"\n",(0,i.jsx)(n.h2,{id:"unix_time_conversion",children:"UNIX_TIME_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Converts values to a native Ruby or Python time object"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Required"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Seconds Item Name"}),(0,i.jsx)(n.td,{children:"The name of the item which contains the seconds since the epoch."}),(0,i.jsx)(n.td,{children:"True"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Microseconds Item Name"}),(0,i.jsx)(n.td,{children:"The name of the item which contains the microseconds since the epoch."}),(0,i.jsx)(n.td,{children:"False"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Seconds Type"}),(0,i.jsxs)(n.td,{children:["How to read the seconds item. Defaults to 'RAW'.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Valid Values: ",(0,i.jsx)("span",{class:"values",children:"RAW, CONVERTED"})]}),(0,i.jsx)(n.td,{children:"False"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Microseconds Type"}),(0,i.jsxs)(n.td,{children:["How to read the microseconds item. Defaults to 'RAW'.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Valid Values: ",(0,i.jsx)("span",{class:"values",children:"RAW, CONVERTED"})]}),(0,i.jsx)(n.td,{children:"False"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION unix_time_conversion.rb TIMESEC TIMEUS\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/unix_time_conversion.py TIMESEC TIMEUS\n"})}),"\n",(0,i.jsx)(n.h2,{id:"unix_time_formatted_conversion",children:"UNIX_TIME_FORMATTED_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:['Converts values to a formatted time string like "YYYY/MM/DD HH:MM',":SS",'.US"']})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Required"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Seconds Item Name"}),(0,i.jsx)(n.td,{children:"The name of the item which contains the seconds since the epoch."}),(0,i.jsx)(n.td,{children:"True"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Microseconds Item Name"}),(0,i.jsx)(n.td,{children:"The name of the item which contains the microseconds since the epoch."}),(0,i.jsx)(n.td,{children:"False"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Seconds Type"}),(0,i.jsxs)(n.td,{children:["How to read the seconds item. Defaults to 'RAW'.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Valid Values: ",(0,i.jsx)("span",{class:"values",children:"RAW, CONVERTED"})]}),(0,i.jsx)(n.td,{children:"False"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Microseconds Type"}),(0,i.jsxs)(n.td,{children:["How to read the microseconds item. Defaults to 'RAW'.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Valid Values: ",(0,i.jsx)("span",{class:"values",children:"RAW, CONVERTED"})]}),(0,i.jsx)(n.td,{children:"False"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION unix_time_formatted_conversion.rb TIMESEC TIMEUS\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/unix_time_formatted_conversion.py TIMESEC TIMEUS\n"})}),"\n",(0,i.jsx)(n.h2,{id:"unix_time_seconds_conversion",children:"UNIX_TIME_SECONDS_CONVERSION"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Converts values to a floating point number of seconds since the epoch"})}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Parameter"}),(0,i.jsx)(n.th,{children:"Description"}),(0,i.jsx)(n.th,{children:"Required"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Seconds Item Name"}),(0,i.jsx)(n.td,{children:"The name of the item which contains the seconds since the epoch."}),(0,i.jsx)(n.td,{children:"True"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Microseconds Item Name"}),(0,i.jsx)(n.td,{children:"The name of the item which contains the microseconds since the epoch."}),(0,i.jsx)(n.td,{children:"False"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Seconds Type"}),(0,i.jsxs)(n.td,{children:["How to read the seconds item. Defaults to 'RAW'.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Valid Values: ",(0,i.jsx)("span",{class:"values",children:"RAW, CONVERTED"})]}),(0,i.jsx)(n.td,{children:"False"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Microseconds Type"}),(0,i.jsxs)(n.td,{children:["How to read the microseconds item. Defaults to 'RAW'.",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Valid Values: ",(0,i.jsx)("span",{class:"values",children:"RAW, CONVERTED"})]}),(0,i.jsx)(n.td,{children:"False"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Ruby Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"READ_CONVERSION unix_time_seconds_conversion.rb TIMESEC TIMEUS\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"READ_CONVERSION openc3/conversions/unix_time_seconds_conversion.py TIMESEC TIMEUS\n"})})]})}function h(e={}){let{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},65:function(e,n,s){s.d(n,{Z:()=>c,a:()=>t});var r=s(7294);let i={},o=r.createContext(i);function t(e){let n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);