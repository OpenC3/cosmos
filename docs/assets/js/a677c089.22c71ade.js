"use strict";(self.webpackChunkdocs_openc3_com=self.webpackChunkdocs_openc3_com||[]).push([["8519"],{6006:function(e,t,n){n.r(t),n.d(t,{default:()=>h,frontMatter:()=>c,metadata:()=>r,assets:()=>o,toc:()=>l,contentTitle:()=>d});var r=JSON.parse('{"id":"configuration/interfaces","title":"Interfaces","description":"Built-in COSMOS interfaces including how to create one","source":"@site/docs/configuration/interfaces.md","sourceDirName":"configuration","slug":"/configuration/interfaces","permalink":"/docs/configuration/interfaces","draft":false,"unlisted":false,"editUrl":"https://github.com/OpenC3/cosmos/tree/main/docs.openc3.com/docs/configuration/interfaces.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Interfaces","description":"Built-in COSMOS interfaces including how to create one","sidebar_custom_props":{"myEmoji":"\uD83D\uDCA1"}},"sidebar":"defaultSidebar","previous":{"title":"Telemetry","permalink":"/docs/configuration/telemetry"},"next":{"title":"Protocols","permalink":"/docs/configuration/protocols"}}'),i=n("5893"),s=n("65");let c={sidebar_position:6,title:"Interfaces",description:"Built-in COSMOS interfaces including how to create one",sidebar_custom_props:{myEmoji:"\uD83D\uDCA1"}},d=void 0,o={},l=[{value:"Overview",id:"overview",level:2},{value:"Protocols",id:"protocols",level:3},{value:"Accessors",id:"accessors",level:3},{value:"Provided Interfaces",id:"provided-interfaces",level:2},{value:"All Interface Options",id:"all-interface-options",level:4},{value:"TCPIP Client Interface",id:"tcpip-client-interface",level:3},{value:"TCPIP Server Interface",id:"tcpip-server-interface",level:3},{value:"Interface Options",id:"interface-options",level:4},{value:"UDP Interface",id:"udp-interface",level:3},{value:"HTTP Client Interface",id:"http-client-interface",level:3},{value:"HTTP Server Interface",id:"http-server-interface",level:3},{value:"Interface Options",id:"interface-options-1",level:4},{value:"MQTT Interface",id:"mqtt-interface",level:3},{value:"Interface Options",id:"interface-options-2",level:4},{value:"Packet Definitions",id:"packet-definitions",level:4},{value:"MQTT Streaming Interface",id:"mqtt-streaming-interface",level:3},{value:"Interface Options",id:"interface-options-3",level:4},{value:"Packet Definitions",id:"packet-definitions-1",level:4},{value:"Serial Interface",id:"serial-interface",level:3},{value:"Interface Options",id:"interface-options-4",level:4},{value:"SNMP Interface (Enterprise)",id:"snmp-interface-enterprise",level:3},{value:"Interface Options",id:"interface-options-5",level:4},{value:"SNMP Trap Interface (Enterprise)",id:"snmp-trap-interface-enterprise",level:3},{value:"Interface Options",id:"interface-options-6",level:4},{value:"gRPC Interface (Enterprise)",id:"grpc-interface-enterprise",level:3},{value:"Commands",id:"commands",level:4},{value:"Custom Interfaces",id:"custom-interfaces",level:2}];function a(e){let t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(t.p,{children:["Interfaces are the connection to the external embedded systems called ",(0,i.jsx)(t.a,{href:"target",children:"targets"}),". Interfaces are defined by the top level ",(0,i.jsx)(t.a,{href:"/docs/configuration/plugins#interface-1",children:"INTERFACE"})," keyword in the plugin.txt file."]}),"\n",(0,i.jsxs)(t.p,{children:["Interface classes provide the code that COSMOS uses to receive real-time telemetry from targets and to send commands to targets. The interface that a target uses could be anything (TCP/IP, serial, MQTT, SNMP, etc.), therefore it is important that this is a customizable portion of any reusable Command and Telemetry System. Fortunately the most common form of interfaces are over TCP/IP sockets, and COSMOS provides interface solutions for these. This guide will discuss how to use these interface classes, and how to create your own. Note that in most cases you can extend interfaces with ",(0,i.jsx)(t.a,{href:"/docs/configuration/protocols",children:"Protocols"})," rather than implementing a new interface."]}),"\n",(0,i.jsx)(t.admonition,{title:"Interface and Routers Are Very Similar",type:"info",children:(0,i.jsx)(t.p,{children:"Note that Interfaces and Routers are very similar and share the same configuration parameters. Routers are simply Interfaces which route an existing Interface's telemetry data out to the connected target and routes the connected target's commands back to the original Interface's target."})}),"\n",(0,i.jsx)(t.h3,{id:"protocols",children:"Protocols"}),"\n",(0,i.jsxs)(t.p,{children:["Protocols define the behaviour of an Interface, including differentiating packet boundaries and modifying data as necessary. See ",(0,i.jsx)(t.a,{href:"protocols",children:"Protocols"})," for more information."]}),"\n",(0,i.jsx)(t.h3,{id:"accessors",children:"Accessors"}),"\n",(0,i.jsxs)(t.p,{children:["Accessors are responsible for reading and writing the buffer which is transmitted by the interface to the target. See ",(0,i.jsx)(t.a,{href:"accessors",children:"Accessors"})," for more information."]}),"\n",(0,i.jsxs)(t.p,{children:["For more information about how Interfaces fit with Protocols and Accessors see ",(0,i.jsx)(t.a,{href:"https://www.openc3.com/news/interoperability-without-standards",children:"Interoperability Without Standards"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"provided-interfaces",children:"Provided Interfaces"}),"\n",(0,i.jsxs)(t.p,{children:["COSMOS provides the following interfaces: TCPIP Client, TCPIP Server, UDP, HTTP Client, HTTP Server, MQTT and Serial. The interface to use is defined by the ",(0,i.jsx)(t.a,{href:"/docs/configuration/plugins#interface",children:"INTERFACE"})," and ",(0,i.jsx)(t.a,{href:"/docs/configuration/plugins#router",children:"ROUTER"})," keywords. See ",(0,i.jsx)(t.a,{href:"/docs/configuration/plugins#interface-modifiers",children:"Interface Modifiers"})," for a description of the keywords which can follow the INTERFACE keyword."]}),"\n",(0,i.jsx)(t.p,{children:"COSMOS Enterprise provides the following interfaces: SNMP, SNMP Trap, GEMS, InfluxDB."}),"\n",(0,i.jsx)(t.h4,{id:"all-interface-options",children:"All Interface Options"}),"\n",(0,i.jsx)(t.p,{children:"The following options apply to all interfaces. Options are added directly beneath the interface definition as shown in the example."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Option"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"PERIODIC_CMD"}),(0,i.jsx)(t.td,{children:"Command to send at periodic intervals. Takes 3 parameters: LOG/DONT_LOG, the interval in seconds, and the actual command to send as a string."})]})})]}),"\n",(0,i.jsx)(t.p,{children:"Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 10.0\n  # Send the 'INST ABORT' command every 5s and don't log in the CmdTlmServer messages\n  # Note that all commands are logged in the binary logs\n  OPTION PERIODIC_CMD DONT_LOG 5.0 \"INST ABORT\"\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 10.0\n  # Send the 'INST2 COLLECT with TYPE NORMAL' command every 10s and output to the CmdTlmServer messages\n  OPTION PERIODIC_CMD LOG 10.0 \"INST2 COLLECT with TYPE NORMAL\"\n"})}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Option"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"CONNECT_CMD"}),(0,i.jsx)(t.td,{children:"Command to send when the interface connects. Takes 2 parameters: LOG/DONT_LOG and the actual command to send as a string."})]})})]}),"\n",(0,i.jsx)(t.p,{children:"Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 10.0\n  # Send the 'INST ABORT' command on connection and don't log in the CmdTlmServer messages\n  # Note that all commands are logged in the binary logs\n  OPTION CONNECT_CMD DONT_LOG \"INST ABORT\"\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 10.0\n  # Send the 'INST2 COLLECT with TYPE NORMAL' on connection and output to the CmdTlmServer messages\n  OPTION CONNECT_CMD LOG \"INST2 COLLECT with TYPE NORMAL\"\n"})}),"\n",(0,i.jsx)(t.h3,{id:"tcpip-client-interface",children:"TCPIP Client Interface"}),"\n",(0,i.jsx)(t.p,{children:"The TCPIP client interface connects to a TCPIP socket to send commands and receive telemetry. This interface is used for targets which open a socket and wait for a connection. This is the most common type of interface."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Required"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Host"}),(0,i.jsx)(t.td,{children:"Machine name to connect to"}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Write Port"}),(0,i.jsx)(t.td,{children:"Port to write commands to (can be the same as read port). Pass nil / None to make the interface read only."}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Port"}),(0,i.jsx)(t.td,{children:"Port to read telemetry from (can be the same as write port). Pass nil / None to make the interface write only."}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Write Timeout"}),(0,i.jsx)(t.td,{children:"Number of seconds to wait before aborting the write"}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Timeout"}),(0,i.jsx)(t.td,{children:"Number of seconds to wait before aborting the read. Pass nil / None to block on read."}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Protocol Type"}),(0,i.jsx)(t.td,{children:"See Protocols."}),(0,i.jsx)(t.td,{children:"No"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Protocol Arguments"}),(0,i.jsx)(t.td,{children:"See Protocols for the arguments each stream protocol takes."}),(0,i.jsx)(t.td,{children:"No"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Ruby Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8081 10.0 nil LENGTH 0 16 0 1 BIG_ENDIAN 4 0xBA5EBA11\nINTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 nil BURST 4 0xDEADBEEF\nINTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 nil FIXED 6 0 nil true\nINTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 10.0 TERMINATED 0x0D0A 0x0D0A true 0 0xF005BA11\nINTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 10.0 TEMPLATE 0xA 0xA\nINTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 nil PREIDENTIFIED 0xCAFEBABE\nINTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 10.0 # no built-in protocol\n"})}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Python Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8081 10.0 None LENGTH 0 16 0 1 BIG_ENDIAN 4 0xBA5EBA11\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 None BURST 4 0xDEADBEEF\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 None FIXED 6 0 None true\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 10.0 TERMINATED 0x0D0A 0x0D0A true 0 0xF005BA11\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 10.0 TEMPLATE 0xA 0xA\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 None PREIDENTIFIED 0xCAFEBABE\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 10.0 # no built-in protocol\n"})}),"\n",(0,i.jsx)(t.h3,{id:"tcpip-server-interface",children:"TCPIP Server Interface"}),"\n",(0,i.jsx)(t.p,{children:"The TCPIP server interface creates a TCPIP server which listens for incoming connections and dynamically creates sockets which communicate with the target. This interface is used for targets which open a socket and try to connect to a server."}),"\n",(0,i.jsx)(t.p,{children:"NOTE: To receive connections from outside the internal docker network you need to expose the TCP port in the compose.yaml file. For example, to allow connections on port 8080 find the openc3-operator section and modify like the following example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:'openc3-operator:\n  ports:\n    - "127.0.0.1:8080:8080" # Open tcp port 8080\n'})}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Required"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Write Port"}),(0,i.jsx)(t.td,{children:"Port to write commands to (can be the same as read port)"}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Port"}),(0,i.jsx)(t.td,{children:"Port to read telemetry from (can be the same as write port)"}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Write Timeout"}),(0,i.jsx)(t.td,{children:"Number of seconds to wait before aborting the write"}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Timeout"}),(0,i.jsx)(t.td,{children:"Number of seconds to wait before aborting the read. Pass nil / None to block on read."}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Protocol Type"}),(0,i.jsx)(t.td,{children:"See Protocols."}),(0,i.jsx)(t.td,{children:"No"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Protocol Arguments"}),(0,i.jsx)(t.td,{children:"See Protocols for the arguments each stream protocol takes."}),(0,i.jsx)(t.td,{children:"No"})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"interface-options",children:"Interface Options"}),"\n",(0,i.jsx)(t.p,{children:"Options are added directly beneath the interface definition as shown in the example."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Option"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"LISTEN_ADDRESS"}),(0,i.jsx)(t.td,{children:"IP address to accept connections on"}),(0,i.jsx)(t.td,{children:"0.0.0.0"})]})})]}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Ruby Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8081 10.0 nil LENGTH 0 16 0 1 BIG_ENDIAN 4 0xBA5EBA11\nINTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 nil BURST 4 0xDEADBEEF\nINTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 nil FIXED 6 0 nil true\nINTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 10.0 TERMINATED 0x0D0A 0x0D0A true 0 0xF005BA11\nINTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 10.0 TEMPLATE 0xA 0xA\nINTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 nil PREIDENTIFIED 0xCAFEBABE\nINTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 10.0 # no built-in protocol\n  OPTION LISTEN_ADDRESS 127.0.0.1\n"})}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Python Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8081 10.0 None LENGTH 0 16 0 1 BIG_ENDIAN 4 0xBA5EBA11\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 None BURST 4 0xDEADBEEF\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 None FIXED 6 0 None true\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 10.0 TERMINATED 0x0D0A 0x0D0A true 0 0xF005BA11\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 10.0 TEMPLATE 0xA 0xA\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 None PREIDENTIFIED 0xCAFEBABE\nINTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 10.0 # no built-in protocol\n"})}),"\n",(0,i.jsx)(t.h3,{id:"udp-interface",children:"UDP Interface"}),"\n",(0,i.jsx)(t.p,{children:"The UDP interface uses UDP packets to send and receive telemetry from the target."}),"\n",(0,i.jsx)(t.p,{children:"NOTE: To receive UDP packets from outside the internal docker network you need to expose the UDP port in the compose.yaml file. For example, to allow UDP packets on port 8081 find the openc3-operator section and modify like the following example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-yaml",children:'openc3-operator:\n  ports:\n    - "127.0.0.1:8081:8081/udp" # Open udp port 8081\n'})}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Required"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Host"}),(0,i.jsx)(t.td,{children:"Host name or IP address of the machine to send and receive data with"}),(0,i.jsx)(t.td,{children:"Yes"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Write Dest Port"}),(0,i.jsx)(t.td,{children:"Port on the remote machine to send commands to"}),(0,i.jsx)(t.td,{children:"Yes"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Port"}),(0,i.jsx)(t.td,{children:"Port on the remote machine to read telemetry from"}),(0,i.jsx)(t.td,{children:"Yes"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Write Source Port"}),(0,i.jsx)(t.td,{children:"Port on the local machine to send commands from"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"nil (socket is not bound to an outgoing port)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Interface Address"}),(0,i.jsx)(t.td,{children:"If the remote machine supports multicast the interface address is used to configure the outgoing multicast address"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"nil (not used)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"TTL"}),(0,i.jsx)(t.td,{children:"Time to Live. The number of intermediate routers allowed before dropping the packet."}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"128 (Windows)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Write Timeout"}),(0,i.jsx)(t.td,{children:"Number of seconds to wait before aborting the write"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"10.0"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Timeout"}),(0,i.jsx)(t.td,{children:"Number of seconds to wait before aborting the read"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"nil (block on read)"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Ruby Example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME udp_interface.rb host.docker.internal 8080 8081 8082 nil 128 10.0 nil\n"})}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Python Example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME openc3/interfaces/udp_interface.py host.docker.internal 8080 8081 8082 None 128 10.0 None\n"})}),"\n",(0,i.jsx)(t.h3,{id:"http-client-interface",children:"HTTP Client Interface"}),"\n",(0,i.jsxs)(t.p,{children:["The HTTP client interface connects to a HTTP server to send commands and receive telemetry. This interface is commonly used with the ",(0,i.jsx)(t.a,{href:"accessors#http-accessor",children:"HttpAccessor"})," and ",(0,i.jsx)(t.a,{href:"accessors#json-accessor",children:"JsonAccessor"}),". See the ",(0,i.jsx)(t.a,{href:"https://github.com/OpenC3/cosmos/tree/main/examples/openc3-cosmos-http-example",children:"openc3-cosmos-http-example"})," for more information."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Required"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Host"}),(0,i.jsx)(t.td,{children:"Machine name to connect to"}),(0,i.jsx)(t.td,{children:"Yes"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Port"}),(0,i.jsx)(t.td,{children:"Port to write commands to and read telemetry from"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"80"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Protocol"}),(0,i.jsx)(t.td,{children:"HTTP or HTTPS protocol"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"HTTP"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Write Timeout"}),(0,i.jsx)(t.td,{children:"Number of seconds to wait before aborting the write. Pass nil / None to block on write."}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"5"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Timeout"}),(0,i.jsx)(t.td,{children:"Number of seconds to wait before aborting the read. Pass nil / None to block on read."}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"nil / None"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Connect Timeout"}),(0,i.jsx)(t.td,{children:"Number of seconds to wait before aborting the connection"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"5"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Include Request In Response"}),(0,i.jsx)(t.td,{children:"Whether to include the request in the extra data"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"false"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Ruby Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME http_client_interface.rb myserver.com 80\n"})}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Python Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME openc3/interfaces/http_client_interface.py mysecure.com 443 HTTPS\n"})}),"\n",(0,i.jsx)(t.h3,{id:"http-server-interface",children:"HTTP Server Interface"}),"\n",(0,i.jsxs)(t.p,{children:["The HTTP server interface creates a simple unencrypted, unauthenticated HTTP server. This interface is commonly used with the ",(0,i.jsx)(t.a,{href:"accessors#http-accessor",children:"HttpAccessor"})," and ",(0,i.jsx)(t.a,{href:"accessors#json-accessor",children:"JsonAccessor"}),". See the ",(0,i.jsx)(t.a,{href:"https://github.com/OpenC3/cosmos/tree/main/examples/openc3-cosmos-http-example",children:"openc3-cosmos-http-example"})," for more information."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Required"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Port"}),(0,i.jsx)(t.td,{children:"Port to write commands to and read telemetry from"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"80"})]})})]}),"\n",(0,i.jsx)(t.h4,{id:"interface-options-1",children:"Interface Options"}),"\n",(0,i.jsx)(t.p,{children:"Options are added directly beneath the interface definition as shown in the example."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Option"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"LISTEN_ADDRESS"}),(0,i.jsx)(t.td,{children:"IP address to accept connections on"}),(0,i.jsx)(t.td,{children:"0.0.0.0"})]})})]}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Ruby Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME http_server_interface.rb\n  LISTEN_ADDRESS 127.0.0.1\n"})}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Python Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME openc3/interfaces/http_server_interface.py 88\n"})}),"\n",(0,i.jsx)(t.h3,{id:"mqtt-interface",children:"MQTT Interface"}),"\n",(0,i.jsxs)(t.p,{children:["The MQTT interface is typically used for connecting to Internet of Things (IoT) devices. The COSMOS MQTT interface is a client that can both publish and receive messages (commands and telemetry). It has built in support for SSL certificates as well as authentication. It differs from the MQTT Streaming Interface in that the commands and telemetry are transmitted over topics given by ",(0,i.jsx)(t.code,{children:"META TOPIC"})," in the command and telemetry definitions."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Required"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Host"}),(0,i.jsx)(t.td,{children:"Host name or IP address of the MQTT broker"}),(0,i.jsx)(t.td,{children:"Yes"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Port"}),(0,i.jsx)(t.td,{children:"Port on the MQTT broker to connect to. Keep in mind whether you're using SSL or not."}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"1883"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"SSL"}),(0,i.jsx)(t.td,{children:"Whether to use SSL to connect"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"false"})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"interface-options-2",children:"Interface Options"}),"\n",(0,i.jsx)(t.p,{children:"Options are added directly beneath the interface definition as shown in the example."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Option"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"ACK_TIMEOUT"}),(0,i.jsx)(t.td,{children:"Time to wait when connecting to the MQTT broker"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"USERNAME"}),(0,i.jsx)(t.td,{children:"Username for authentication with the MQTT broker"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"PASSWORD"}),(0,i.jsx)(t.td,{children:"Password for authentication with the MQTT broker"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"CERT"}),(0,i.jsx)(t.td,{children:"PEM encoded client certificate filename used with KEY for client TLS based authentication"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"KEY"}),(0,i.jsx)(t.td,{children:"PEM encoded client private keys filename"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"KEYFILE_PASSWORD"}),(0,i.jsx)(t.td,{children:"Password to decrypt the CERT and KEY files (Python only)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"CA_FILE"}),(0,i.jsx)(t.td,{children:"Certificate Authority certificate filename that is to be treated as trusted by this client"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Ruby Example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE MQTT_INT mqtt_interface.rb test.mosquitto.org 1883\n"})}),"\n",(0,i.jsxs)(t.p,{children:["plugin.txt Python Example (Note: This example uses the ",(0,i.jsx)(t.a,{href:"plugins#secret",children:"SECRET"})," keyword to set the PASSWORD option in the Interface):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE MQTT_INT openc3/interfaces/mqtt_interface.py test.mosquitto.org 8884\n  OPTION USERNAME rw\n  # Create an env variable called MQTT_PASSWORD with the secret named PASSWORD\n  # and set an OPTION called PASSWORD with the secret value\n  # For more information about secrets see the Admin Tool page\n  SECRET ENV PASSWORD MQTT_PASSWORD PASSWORD\n"})}),"\n",(0,i.jsx)(t.h4,{id:"packet-definitions",children:"Packet Definitions"}),"\n",(0,i.jsx)(t.p,{children:"The MQTT Interface utilizes 'META TOPIC <topic name>' in the command and telemetry definition files to determine which topics to publish and receive messages from. Thus to send to the topic 'TEST' you would create a command like the following (Note: The command name 'TEST' does NOT have to match the topic name):"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"COMMAND MQTT TEST BIG_ENDIAN \"Test\"\n  META TOPIC TEST # <- The topic name is 'TEST'\n  APPEND_PARAMETER DATA 0 BLOCK '' \"MQTT Data\"\n"})}),"\n",(0,i.jsx)(t.p,{children:"Similarly to receive from the topic 'TEST' you would create a telemetry packet like the following (Note: The telemetry name 'TEST' does NOT have to match the topic name):"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'TELEMETRY MQTT TEST BIG_ENDIAN "Test"\n  META TOPIC TEST # <- The topic name is \'TEST\'\n  APPEND_ITEM DATA 0 BLOCK "MQTT Data"\n'})}),"\n",(0,i.jsxs)(t.p,{children:["For a full example, please see the ",(0,i.jsx)(t.a,{href:"https://github.com/OpenC3/cosmos/tree/main/openc3-cosmos-init/plugins/packages/openc3-cosmos-mqtt-test",children:"openc3-cosmos-mqtt-test"})," in the COSMOS source."]}),"\n",(0,i.jsx)(t.h3,{id:"mqtt-streaming-interface",children:"MQTT Streaming Interface"}),"\n",(0,i.jsx)(t.p,{children:"The MQTT streaming interface is typically used for connecting to Internet of Things (IoT) devices. The COSMOS MQTT streaming interface is a client that can both publish and receive messages (commands and telemetry). It has built in support for SSL certificates as well as authentication. It differs from the MQTT Interface in that all the commands are transmitted on a single topic and all telemetry is received on a single topic."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Required"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Host"}),(0,i.jsx)(t.td,{children:"Host name or IP address of the MQTT broker"}),(0,i.jsx)(t.td,{children:"Yes"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Port"}),(0,i.jsx)(t.td,{children:"Port on the MQTT broker to connect to. Keep in mind whether you're using SSL or not."}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"1883"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"SSL"}),(0,i.jsx)(t.td,{children:"Whether to use SSL to connect"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"false"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Write Topic"}),(0,i.jsx)(t.td,{children:"Name of the write topic for all commands. Pass nil / None to make interface read only."}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"nil / None"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Topic"}),(0,i.jsx)(t.td,{children:"Name of the read topic for all telemetry. Pass nil / None to make interface write only."}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"nil / None"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Protocol Type"}),(0,i.jsx)(t.td,{children:"See Protocols."}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Protocol Arguments"}),(0,i.jsx)(t.td,{children:"See Protocols for the arguments each stream protocol takes."}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"interface-options-3",children:"Interface Options"}),"\n",(0,i.jsx)(t.p,{children:"Options are added directly beneath the interface definition as shown in the example."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Option"}),(0,i.jsx)(t.th,{children:"Description"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"ACK_TIMEOUT"}),(0,i.jsx)(t.td,{children:"Time to wait when connecting to the MQTT broker"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"USERNAME"}),(0,i.jsx)(t.td,{children:"Username for authentication with the MQTT broker"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"PASSWORD"}),(0,i.jsx)(t.td,{children:"Password for authentication with the MQTT broker"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"CERT"}),(0,i.jsx)(t.td,{children:"PEM encoded client certificate filename used with KEY for client TLS based authentication"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"KEY"}),(0,i.jsx)(t.td,{children:"PEM encoded client private keys filename"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"KEYFILE_PASSWORD"}),(0,i.jsx)(t.td,{children:"Password to decrypt the CERT and KEY files (Python only)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"CA_FILE"}),(0,i.jsx)(t.td,{children:"Certificate Authority certificate filename that is to be treated as trusted by this client"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Ruby Example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE MQTT_INT mqtt_stream_interface.rb test.mosquitto.org 1883 false write read\n"})}),"\n",(0,i.jsxs)(t.p,{children:["plugin.txt Python Example (Note: This example uses the ",(0,i.jsx)(t.a,{href:"plugins#secret",children:"SECRET"})," keyword to set the PASSWORD option in the Interface):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE MQTT_INT openc3/interfaces/mqtt_stream_interface.py test.mosquitto.org 8884 False write read\n  OPTION USERNAME rw\n  # Create an env variable called MQTT_PASSWORD with the secret named PASSWORD\n  # and set an OPTION called PASSWORD with the secret value\n  # For more information about secrets see the Admin Tool page\n  SECRET ENV PASSWORD MQTT_PASSWORD PASSWORD\n"})}),"\n",(0,i.jsx)(t.h4,{id:"packet-definitions-1",children:"Packet Definitions"}),"\n",(0,i.jsx)(t.p,{children:"The MQTT Streaming Interface utilizes the topic names passed to the interface so no additional information is necessary in the definition."}),"\n",(0,i.jsxs)(t.p,{children:["For a full example, please see the ",(0,i.jsx)(t.a,{href:"https://github.com/OpenC3/cosmos/tree/main/openc3-cosmos-init/plugins/packages/openc3-cosmos-mqtt-test",children:"openc3-cosmos-mqtt-test"})," in the COSMOS source."]}),"\n",(0,i.jsx)(t.h3,{id:"serial-interface",children:"Serial Interface"}),"\n",(0,i.jsx)(t.p,{children:"The serial interface connects to a target over a serial port. COSMOS provides drivers for both Windows and POSIX drivers for UNIX based systems. The Serial Interface is currently only implemented in Ruby."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Required"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Write Port"}),(0,i.jsx)(t.td,{children:"Name of the serial port to write, e.g. 'COM1' or '/dev/ttyS0'. Pass nil / None to disable writing."}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Port"}),(0,i.jsx)(t.td,{children:"Name of the serial port to read, e.g. 'COM1' or '/dev/ttyS0'. Pass nil / None to disable reading."}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Baud Rate"}),(0,i.jsx)(t.td,{children:"Baud rate to read and write"}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Parity"}),(0,i.jsx)(t.td,{children:"Serial port parity. Must be 'NONE', 'EVEN', or 'ODD'."}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Stop Bits"}),(0,i.jsx)(t.td,{children:"Number of stop bits, e.g. 1."}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Write Timeout"}),(0,i.jsx)(t.td,{children:"Number of seconds to wait before aborting the write"}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Timeout"}),(0,i.jsx)(t.td,{children:"Number of seconds to wait before aborting the read. Pass nil / None to block on read."}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Protocol Type"}),(0,i.jsx)(t.td,{children:"See Protocols."}),(0,i.jsx)(t.td,{children:"No"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Protocol Arguments"}),(0,i.jsx)(t.td,{children:"See Protocols for the arguments each stream protocol takes."}),(0,i.jsx)(t.td,{children:"No"})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"interface-options-4",children:"Interface Options"}),"\n",(0,i.jsx)(t.p,{children:"Options are added directly beneath the interface definition as shown in the example."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Option"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"FLOW_CONTROL"}),(0,i.jsx)(t.td,{children:"Serial port flow control. Must be one of NONE or RTSCTS."}),(0,i.jsx)(t.td,{children:"NONE"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"DATA_BITS"}),(0,i.jsx)(t.td,{children:"Number of data bits."}),(0,i.jsx)(t.td,{children:"8"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Ruby Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE INTERFACE_NAME serial_interface.rb COM1 COM1 9600 NONE 1 10.0 nil LENGTH 0 16 0 1 BIG_ENDIAN 4 0xBA5EBA11\nINTERFACE INTERFACE_NAME serial_interface.rb /dev/ttyS1 /dev/ttyS1 38400 ODD 1 10.0 nil BURST 4 0xDEADBEEF\nINTERFACE INTERFACE_NAME serial_interface.rb COM2 COM2 19200 EVEN 1 10.0 nil FIXED 6 0 nil true\nINTERFACE INTERFACE_NAME serial_interface.rb COM4 COM4 115200 NONE 1 10.0 10.0 TERMINATED 0x0D0A 0x0D0A true 0 0xF005BA11\nINTERFACE INTERFACE_NAME serial_interface.rb COM4 COM4 115200 NONE 1 10.0 10.0 TEMPLATE 0xA 0xA\nINTERFACE INTERFACE_NAME serial_interface.rb /dev/ttyS0 /dev/ttyS0 57600 NONE 1 10.0 nil PREIDENTIFIED 0xCAFEBABE\nINTERFACE INTERFACE_NAME serial_interface.rb COM4 COM4 115200 NONE 1 10.0 10.0 # no built-in protocol\n  OPTION FLOW_CONTROL RTSCTS\n  OPTION DATA_BITS 7\n"})}),"\n",(0,i.jsx)(t.h3,{id:"snmp-interface-enterprise",children:"SNMP Interface (Enterprise)"}),"\n",(0,i.jsx)(t.p,{children:"The SNMP Interface is for connecting to Simple Network Management Protocol devices. The SNMP Interface is currently only implemented in Ruby."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Required"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Host"}),(0,i.jsx)(t.td,{children:"Host name of the SNMP device"}),(0,i.jsx)(t.td,{children:"Yes"}),(0,i.jsx)(t.td,{})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Port"}),(0,i.jsx)(t.td,{children:"Port on the SNMP device"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"161"})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"interface-options-5",children:"Interface Options"}),"\n",(0,i.jsx)(t.p,{children:"Options are added directly beneath the interface definition as shown in the example."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Option"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"VERSION"}),(0,i.jsx)(t.td,{children:"SNMP Version: 1, 2, or 3"}),(0,i.jsx)(t.td,{children:"1"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"COMMUNITY"}),(0,i.jsx)(t.td,{children:"Password or user ID that allows access to a device"}),(0,i.jsx)(t.td,{children:"private"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"USERNAME"}),(0,i.jsx)(t.td,{children:"Username"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"RETRIES"}),(0,i.jsx)(t.td,{children:"Retries when sending requests"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"TIMEOUT"}),(0,i.jsx)(t.td,{children:"Timeout waiting for a response from an agent"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"CONTEXT"}),(0,i.jsx)(t.td,{children:"SNMP context"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"SECURITY_LEVEL"}),(0,i.jsx)(t.td,{children:"Must be one of NO_AUTH, AUTH_PRIV, or AUTH_NO_PRIV"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"AUTH_PROTOCOL"}),(0,i.jsx)(t.td,{children:"Must be one of MD5, SHA, or SHA256"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"PRIV_PROTOCOL"}),(0,i.jsx)(t.td,{children:"Must be one of DES or AES"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"AUTH_PASSWORD"}),(0,i.jsx)(t.td,{children:"Auth password"}),(0,i.jsx)(t.td,{children:"N/A"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"PRIV_PASSWORD"}),(0,i.jsx)(t.td,{children:"Priv password"}),(0,i.jsx)(t.td,{children:"N/A"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Ruby Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE SNMP_INT snmp_interface.rb 192.168.1.249 161\n  OPTION VERSION 1\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For a full example, please see the ",(0,i.jsx)(t.a,{href:"https://github.com/OpenC3/cosmos-enterprise-plugins/tree/main/openc3-cosmos-apc-switched-pdu",children:"openc3-cosmos-apc-switched-pdu"})," in the COSMOS Enterprise Plugins."]}),"\n",(0,i.jsx)(t.h3,{id:"snmp-trap-interface-enterprise",children:"SNMP Trap Interface (Enterprise)"}),"\n",(0,i.jsx)(t.p,{children:"The SNMP Trap Interface is for receiving Simple Network Management Protocol traps. The SNMP Trap Interface is currently only implemented in Ruby."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Required"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Port"}),(0,i.jsx)(t.td,{children:"Port to read from"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"162"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Read Timeout"}),(0,i.jsx)(t.td,{children:"Read timeout"}),(0,i.jsx)(t.td,{children:"No"}),(0,i.jsx)(t.td,{children:"nil"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Bind Address"}),(0,i.jsx)(t.td,{children:"Address to bind UDP port to"}),(0,i.jsx)(t.td,{children:"Yes"}),(0,i.jsx)(t.td,{children:"0.0.0.0"})]})]})]}),"\n",(0,i.jsx)(t.h4,{id:"interface-options-6",children:"Interface Options"}),"\n",(0,i.jsx)(t.p,{children:"Options are added directly beneath the interface definition as shown in the example."}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Option"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Default"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"VERSION"}),(0,i.jsx)(t.td,{children:"SNMP Version: 1, 2, or 3"}),(0,i.jsx)(t.td,{children:"1"})]})})]}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Ruby Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE SNMP_INT snmp_trap_interface.rb 162\n  OPTION VERSION 1\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For a full example, please see the ",(0,i.jsx)(t.a,{href:"https://github.com/OpenC3/cosmos-enterprise-plugins/tree/main/openc3-cosmos-apc-switched-pdu",children:"openc3-cosmos-apc-switched-pdu"})," in the COSMOS Enterprise Plugins."]}),"\n",(0,i.jsx)(t.h3,{id:"grpc-interface-enterprise",children:"gRPC Interface (Enterprise)"}),"\n",(0,i.jsxs)(t.p,{children:["The gRPC Interface is for interacting with ",(0,i.jsx)(t.a,{href:"https://grpc.io/",children:"gRPC"}),". The gRPC Interface is currently only implemented in Ruby."]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Parameter"}),(0,i.jsx)(t.th,{children:"Description"}),(0,i.jsx)(t.th,{children:"Required"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Hostname"}),(0,i.jsx)(t.td,{children:"gRPC server"}),(0,i.jsx)(t.td,{children:"Yes"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Port"}),(0,i.jsx)(t.td,{children:"gRPC port"}),(0,i.jsx)(t.td,{children:"Yes"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"plugin.txt Ruby Examples:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"INTERFACE GRPC_INT grpc_interface.rb my.grpc.org 8080\n"})}),"\n",(0,i.jsx)(t.h4,{id:"commands",children:"Commands"}),"\n",(0,i.jsxs)(t.p,{children:["Using the GrpcInterface for ",(0,i.jsx)(t.a,{href:"command",children:"command definitions"})," requires the use of ",(0,i.jsx)(t.a,{href:"command#meta",children:"META"})," to define a GRPC_METHOD to use for each command."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ruby",children:"COMMAND PROTO GET_USER BIG_ENDIAN 'Get a User'\n  META GRPC_METHOD /example.photoservice.ExamplePhotoService/GetUser\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For a full example, please see the ",(0,i.jsx)(t.a,{href:"https://github.com/OpenC3/cosmos-enterprise-plugins/tree/main/openc3-cosmos-proto-target",children:"openc3-cosmos-proto-target"})," in the COSMOS Enterprise Plugins."]}),"\n",(0,i.jsx)(t.h2,{id:"custom-interfaces",children:"Custom Interfaces"}),"\n",(0,i.jsx)(t.p,{children:"Interfaces have the following methods that must be implemented:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"connect"})," - Open the socket or port or somehow establish the connection to the target. Note: This method may not block indefinitely. Be sure to call super() in your implementation."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"connected?"})," - Return true or false depending on the connection state. Note: This method should return immediately."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"disconnect"})," - Close the socket or port of somehow disconnect from the target. Note: This method may not block indefinitely. Be sure to call super() in your implementation."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"read_interface"})," - Lowest level read of data on the interface. Note: This method should block until data is available or the interface disconnects. On a clean disconnect it should return nil."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"write_interface"})," - Lowest level write of data on the interface. Note: This method may not block indefinitely."]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Interfaces also have the following methods that exist and have default implementations. They can be overridden if necessary but be sure to call super() to allow the default implementation to be executed."}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"read_interface_base"})," - This method should always be called from read_interface(). It updates interface specific variables that are displayed by CmdTLmServer including the bytes read count, the most recent raw data read, and it handles raw logging if enabled."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"write_interface_base"})," - This method should always be called from write_interface(). It updates interface specific variables that are displayed by CmdTLmServer including the bytes written count, the most recent raw data written, and it handles raw logging if enabled."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"read"})," - Read the next packet from the interface. COSMOS implements this method to allow the Protocol system to operate on the data and the packet before it is returned."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"write"})," - Send a packet to the interface. COSMOS implements this method to allow the Protocol system to operate on the packet and the data before it is sent."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"write_raw"})," - Send a raw binary string of data to the target. COSMOS implements this method by basically calling write_interface with the raw data."]}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{title:"Naming Conventions",type:"warning",children:(0,i.jsx)(t.p,{children:'When creating your own interfaces, in most cases they will be subclasses of one of the built-in interfaces described below. It is important to know that both the filename and class name of the interface files must match with correct capitalization or you will receive "class not found" errors when trying to load your new interface. For example, an interface file called labview_interface.rb must contain the class LabviewInterface. If the class was named, LabVIEWInterface, for example, COSMOS would not be able to find the class because of the unexpected capitalization.'})})]})}function h(e={}){let{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},65:function(e,t,n){n.d(t,{Z:function(){return d},a:function(){return c}});var r=n(7294);let i={},s=r.createContext(i);function c(e){let t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);