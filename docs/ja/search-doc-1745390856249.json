{"searchDocs":[{"title":"紹介","type":0,"sectionRef":"#","url":"/ja/docs","content":"","keywords":"","version":"次へ"},{"title":"COSMOSとは具体的に何ですか？​","type":1,"pageTitle":"紹介","url":"/ja/docs#cosmosとは具体的に何ですか","content":" COSMOSは、組み込みシステムのセットを制御するために使用できるアプリケーションスイートです。これらのシステムは、テスト機器（電源装置、オシロスコープ、スイッチ付き電源タップ、UPSデバイスなど）、開発ボード（Arduino、Raspberry Pi、Beagleboneなど）、衛星まで、あらゆるものが対象となります。  ","version":"次へ","tagName":"h2"},{"title":"COSMOSアーキテクチャ​","type":1,"pageTitle":"紹介","url":"/ja/docs#cosmosアーキテクチャ","content":"   COSMOS 6は、クラウドネイティブ、コンテナ化、マイクロサービス指向のコマンド＆コントロールシステムです。すべてのCOSMOSマイクロサービスはDockerコンテナであり、そのためDockerが全体のCOSMOSシステムを含んでいるように表示されています。左側の緑色のボックスは、COSMOSが接続する外部の組み込みシステム（ターゲット）を表しています。Redisデータストアには、すべてのマイクロサービスの構成、現在の値テーブル、および復調されたデータを含むデータストリームが含まれています。Minioデータストアには、プラグイン、ターゲット、構成データ、テキストログ、および生データ、復調データ、削減データのすべてのバイナリログが含まれています。ユーザーはウェブブラウザからCOSMOSと対話し、内部のTraefikロードバランサーを経由します。  各COSMOSツールについての詳細な説明を続けてご覧ください。  ","version":"次へ","tagName":"h3"},{"title":"役立つヒント​","type":1,"pageTitle":"紹介","url":"/ja/docs#役立つヒント","content":" このガイド全体を通じて、COSMOSの使用をより簡単、より興味深く、そして危険の少ないものにするための、小さいながらも便利な情報がいくつかあります。以下に何に注目すべきかを示します。  COSMOSをより活用 COSMOSの達人になるためのヒントとコツです！  便利な情報のメモ COSMOSを理解するために時々必要な追加の豆知識です。  警告は物事を爆発させないために役立ちます これらのメッセージには注意してください。  ドキュメントやCOSMOS自体に問題がありましたか？ COSMOSの使用と改良は、楽しく、シンプルで、簡単であるべきです。もし何らかの理由で問題があると感じた場合は、あなたの経験を説明する問題をGitHubで作成してください。より良いソフトにするために役立ちます。 ","version":"次へ","tagName":"h2"},{"title":"Curlを使用したテスト","type":0,"sectionRef":"#","url":"/ja/docs/development/curl","content":"","keywords":"","version":"次へ"},{"title":"OpenC3 COSMOS オープンソース版でのCurlの例​","type":1,"pageTitle":"Curlを使用したテスト","url":"/ja/docs/development/curl#openc3-cosmos-オープンソース版でのcurlの例","content":" OpenC3 COSMOS オープンソース版は単一のユーザーアカウントしかありませんので、単一のパスワードをトークンとしてリクエストに渡すだけで済みます。  リクエスト:  curl -i -H &quot;Content-Type: application/json-rpc&quot; -H &quot;Authorization: password&quot; -d '{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;tlm&quot;, &quot;params&quot;: [&quot;INST HEALTH_STATUS TEMP1&quot;], &quot;keyword_params&quot;: {&quot;scope&quot;: &quot;DEFAULT&quot;}, &quot;id&quot;: 8}' -X POST http://127.0.0.1:2900/openc3-api/api   レスポンス:  HTTP/1.1 200 OK Cache-Control: max-age=0, private, must-revalidate Content-Length: 51 Content-Type: application/json-rpc Etag: W/&quot;e806aacfdbed0b325e7a5928e3bb5cf4&quot; Vary: Origin X-Request-Id: bbad6c6b-6d22-4374-a86f-b5b0b95e6939 X-Runtime: 0.059044 Date: Sat, 04 Nov 2023 21:34:47 GMT {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:8,&quot;result&quot;:53.26555000000001}   ","version":"次へ","tagName":"h2"},{"title":"OpenC3 COSMOS Enterprise版でのCurlの例​","type":1,"pageTitle":"Curlを使用したテスト","url":"/ja/docs/development/curl#openc3-cosmos-enterprise版でのcurlの例","content":" OpenC3 COSMOS Enterprise版はKeycloakシングルサインオンシステムを使用しているため、リクエストを行う前に、ユーザー名とパスワードのペアを使用してKeycloakからトークンを要求する必要があります。デフォルトでは、このトークンは5分で期限切れになり、次のリクエストの前に期限切れになった場合は更新する必要があります。  Keycloakリクエスト:  # Keycloakからトークンを取得 - ユーザー名とパスワードをあなたのアカウントに更新する必要があります curl -i -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -d 'username=operator&amp;password=operator&amp;client_id=api&amp;grant_type=password&amp;scope=openid' -X POST http://127.0.0.1:2900/auth/realms/openc3/protocol/openid-connect/token   Keycloakレスポンス:  HTTP/1.1 200 OK Cache-Control: no-store Content-Length: 3207 Content-Type: application/json Pragma: no-cache Referrer-Policy: no-referrer Set-Cookie: KEYCLOAK_LOCALE=; Version=1; Comment=Expiring cookie; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Max-Age=0; Path=/auth/realms/openc3/; HttpOnly Set-Cookie: KC_RESTART=; Version=1; Expires=Thu, 01-Jan-1970 00:00:10 GMT; Max-Age=0; Path=/auth/realms/openc3/; HttpOnly Strict-Transport-Security: max-age=31536000; includeSubDomains X-Content-Type-Options: nosniff X-Frame-Options: SAMEORIGIN X-Xss-Protection: 1; mode=block Date: Wed, 10 May 2023 00:40:40 GMT {&quot;access_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJ0cDlERmpNZGFXMy16WXptdlBqVTZnNTVqMVNhWGhkZHJqU0szQVNvaDhVIn0.eyJleHAiOjE2ODM2Nzk1NDAsImlhdCI6MTY4MzY3OTI0MCwianRpIjoiZmVlOTQwYWYtZDY3Ny00MWUyLWIzNWYtZDI5ODhiM2RhZGQ2IiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDoyOTAwL2F1dGgvcmVhbG1zL29wZW5jMyIsInN1YiI6ImFjZTFlNmExLTkzMTktNDc2ZS1iZjQzLTZmM2NhYjllZTJkZSIsInR5cCI6IkJlYXJlciIsImF6cCI6ImFwaSIsInNlc3Npb25fc3RhdGUiOiJmMzc4NTk2Ny0yYTQ2LTRjMTItYWQwYy1jZmY3ZmM0NzdkZjkiLCJhY3IiOiIxIiwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbImRlZmF1bHQtcm9sZXMtb3BlbmMzIiwiQUxMU0NPUEVTX19vcGVyYXRvciIsIm9mZmxpbmVfYWNjZXNzIiwiQUxMU0NPUEVTX192aWV3ZXIiXX0sInNjb3BlIjoib3BlbmlkIHByb2ZpbGUgZW1haWwiLCJzaWQiOiJmMzc4NTk2Ny0yYTQ2LTRjMTItYWQwYy1jZmY3ZmM0NzdkZjkiLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsIm5hbWUiOiJUaGUgT3BlcmF0b3IiLCJwcmVmZXJyZWRfdXNlcm5hbWUiOiJvcGVyYXRvciIsImdpdmVuX25hbWUiOiJUaGUiLCJmYW1pbHlfbmFtZSI6Ik9wZXJhdG9yIn0.eSqSeZrmCTahwltz5jsu5r3w6W15T5h0BvIdqKWQBDcnxAcxKuT-Nwziw_ewySSgHeC172CIWJUpHVp8ACDQG-dfW4KkvA6AcGfSF_f8TBH_rZrVQwlvwwzdA_egGKzhZWcnAC8TDjXRxuaWmnOgWT0aaHZAoW8EvwmKp-1IVz2l0B-hqzfC7dkjMrCI1udLfDvDBza9OtuR-FnKGt8h4nYnRzr8pO2jwebPFyZlR00gVsyK-b411XqprpT-qpRObYZwH5womA-8xIiwRZj9dsfQ1TaHGFkp1LNzxcj_r6pfwVO263bohbeU7ImezQdbvGLJ9NHaglzVNroTui4BXA&quot;,&quot;expires_in&quot;:300,&quot;refresh_expires_in&quot;:1800,&quot;refresh_token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICI5NjNlMjJiMS0wZmYwLTRmZjktYTg0Zi1hOGI4MzcxOWFiMDEifQ.eyJleHAiOjE2ODM2ODEwNDAsImlhdCI6MTY4MzY3OTI0MCwianRpIjoiMmQyYjIyNmItNjJkOS00YjRjLWI3YTYtMGEwYjk4MGQyMjMwIiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDoyOTAwL2F1dGgvcmVhbG1zL29wZW5jMyIsImF1ZCI6Imh0dHA6Ly9sb2NhbGhvc3Q6MjkwMC9hdXRoL3JlYWxtcy9vcGVuYzMiLCJzdWIiOiJhY2UxZTZhMS05MzE5LTQ3NmUtYmY0My02ZjNjYWI5ZWUyZGUiLCJ0eXAiOiJSZWZyZXNoIiwiYXpwIjoiYXBpIiwic2Vzc2lvbl9zdGF0ZSI6ImYzNzg1OTY3LTJhNDYtNGMxMi1hZDBjLWNmZjdmYzQ3N2RmOSIsInNjb3BlIjoib3BlbmlkIHByb2ZpbGUgZW1haWwiLCJzaWQiOiJmMzc4NTk2Ny0yYTQ2LTRjMTItYWQwYy1jZmY3ZmM0NzdkZjkifQ.1HlKdxQkaL5tYuHTXsOceLZFmNNLl9BjoA4oUl70x9M&quot;,&quot;token_type&quot;:&quot;Bearer&quot;,&quot;id_token&quot;:&quot;eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJ0cDlERmpNZGFXMy16WXptdlBqVTZnNTVqMVNhWGhkZHJqU0szQVNvaDhVIn0.eyJleHAiOjE2ODM2Nzk1NDAsImlhdCI6MTY4MzY3OTI0MCwiYXV0aF90aW1lIjowLCJqdGkiOiJhNDJkOTY1ZS1lMzU0LTRiM2QtOTIyYS1hOWE0ZDgwZWYxMTkiLCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjI5MDAvYXV0aC9yZWFsbXMvb3BlbmMzIiwiYXVkIjoiYXBpIiwic3ViIjoiYWNlMWU2YTEtOTMxOS00NzZlLWJmNDMtNmYzY2FiOWVlMmRlIiwidHlwIjoiSUQiLCJhenAiOiJhcGkiLCJzZXNzaW9uX3N0YXRlIjoiZjM3ODU5NjctMmE0Ni00YzEyLWFkMGMtY2ZmN2ZjNDc3ZGY5IiwiYXRfaGFzaCI6IjNBWE9ISkFKYzFPVldLd2Y0a0Q4TkEiLCJhY3IiOiIxIiwic2lkIjoiZjM3ODU5NjctMmE0Ni00YzEyLWFkMGMtY2ZmN2ZjNDc3ZGY5IiwiZW1haWxfdmVyaWZpZWQiOmZhbHNlLCJuYW1lIjoiVGhlIE9wZXJhdG9yIiwicHJlZmVycmVkX3VzZXJuYW1lIjoib3BlcmF0b3IiLCJnaXZlbl9uYW1lIjoiVGhlIiwiZmFtaWx5X25hbWUiOiJPcGVyYXRvciJ9.gdLl6KOKIIAdl6jYEuAXQrGCNvuwLQb3RDnwrHJdqyFXshiwofBiLMFreRsIE-33xXWNBU6pnSLQHPVlQU5Vmzlk0IOfk-b4yNq0dNa1TV1kmnxRl8w1ulTQYVZjdsN-oyLNwe0v3aJcYtbvIA3DP8rgO6bVv0ogkjWtlda6MbkyZN-har8x3raUVSlUPRP2Basy1xSMNNA1jvB-nEM-aubrUZE6r0PjI6PE1hbLPmuPbcX3uuIwXu2-UoXepkB8H7omUuMm-S98aHpRarwszC0mmHD5b_wiXusMVw4xYw8eavFue4zfw-T2IKuTVtxbMTygXIah6iqi4gkpL8Mx1w&quot;,&quot;not-before-policy&quot;:0,&quot;session_state&quot;:&quot;f3785967-2a46-4c12-ad0c-cff7fc477df9&quot;,&quot;scope&quot;:&quot;openid profile email&quot;}   COSMOSリクエスト:  # COSMOSリクエストは次のようになります: curl -i -H &quot;Content-Type: application/json-rpc&quot; -H &quot;Authorization: eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJ0cDlERmpNZGFXMy16WXptdlBqVTZnNTVqMVNhWGhkZHJqU0szQVNvaDhVIn0.eyJleHAiOjE2ODM2Nzk1NDAsImlhdCI6MTY4MzY3OTI0MCwianRpIjoiZmVlOTQwYWYtZDY3Ny00MWUyLWIzNWYtZDI5ODhiM2RhZGQ2IiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDoyOTAwL2F1dGgvcmVhbG1zL29wZW5jMyIsInN1YiI6ImFjZTFlNmExLTkzMTktNDc2ZS1iZjQzLTZmM2NhYjllZTJkZSIsInR5cCI6IkJlYXJlciIsImF6cCI6ImFwaSIsInNlc3Npb25fc3RhdGUiOiJmMzc4NTk2Ny0yYTQ2LTRjMTItYWQwYy1jZmY3ZmM0NzdkZjkiLCJhY3IiOiIxIiwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbImRlZmF1bHQtcm9sZXMtb3BlbmMzIiwiQUxMU0NPUEVTX19vcGVyYXRvciIsIm9mZmxpbmVfYWNjZXNzIiwiQUxMU0NPUEVTX192aWV3ZXIiXX0sInNjb3BlIjoib3BlbmlkIHByb2ZpbGUgZW1haWwiLCJzaWQiOiJmMzc4NTk2Ny0yYTQ2LTRjMTItYWQwYy1jZmY3ZmM0NzdkZjkiLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsIm5hbWUiOiJUaGUgT3BlcmF0b3IiLCJwcmVmZXJyZWRfdXNlcm5hbWUiOiJvcGVyYXRvciIsImdpdmVuX25hbWUiOiJUaGUiLCJmYW1pbHlfbmFtZSI6Ik9wZXJhdG9yIn0.eSqSeZrmCTahwltz5jsu5r3w6W15T5h0BvIdqKWQBDcnxAcxKuT-Nwziw_ewySSgHeC172CIWJUpHVp8ACDQG-dfW4KkvA6AcGfSF_f8TBH_rZrVQwlvwwzdA_egGKzhZWcnAC8TDjXRxuaWmnOgWT0aaHZAoW8EvwmKp-1IVz2l0B-hqzfC7dkjMrCI1udLfDvDBza9OtuR-FnKGt8h4nYnRzr8pO2jwebPFyZlR00gVsyK-b411XqprpT-qpRObYZwH5womA-8xIiwRZj9dsfQ1TaHGFkp1LNzxcj_r6pfwVO263bohbeU7ImezQdbvGLJ9NHaglzVNroTui4BXA&quot; -d '{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;tlm&quot;, &quot;params&quot;: [&quot;INST HEALTH_STATUS TEMP1&quot;], &quot;keyword_params&quot;: {&quot;scope&quot;: &quot;DEFAULT&quot;}, &quot;id&quot;: 8}' -X POST http://127.0.0.1:2900/openc3-api/api   COSMOSレスポンス:  HTTP/1.1 200 OK Cache-Control: max-age=0, private, must-revalidate Content-Type: application/json-rpc Etag: W/&quot;1e44c0878528687014e1e60a1cbebdae&quot; Vary: Origin X-Request-Id: 47a8dd26-1348-4693-8df1-5375f60abc6c X-Runtime: 0.046477 Date: Wed, 10 May 2023 00:41:33 GMT Transfer-Encoding: chunked {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:8,&quot;result&quot;:29.204100000000007}   ","version":"次へ","tagName":"h2"},{"title":"Suite Runnerの例​","type":1,"pageTitle":"Curlを使用したテスト","url":"/ja/docs/development/curl#suite-runnerの例","content":" 継続的テストサーバーからリモートでスイートやスクリプトを実行することは非常に便利です。COSMOSのREST APIはこれを可能にします。ウェブGUIで特定のタスクを実行するために必要なものを把握するには、ブラウザの開発者ツールを開いてネットワークトラフィックを監視することができます。コマンドを実行するために必要なすべてのリクエストとレスポンスが表示され、自分の目的に合わせて再フォーマットすることができます。以下はChromiumベースのブラウザからテストスクリプトを実行する例です：  合計5つのトランザクションがあることがわかります。調査するには、ネットワークトランザクションを右クリックして「curlとしてコピー」をクリックするだけです（ブラウザによって異なります）。以下は2番目のトランザクションの例です：  curl 'http://localhost:2900/script-api/scripts/TARGET/procedures/cmd_tlm_test.rb/lock?scope=DEFAULT' \\ -X 'POST' \\ -H 'Accept: application/json' \\ -H 'Accept-Language: en-US,en;q=0.9' \\ -H 'Authorization: pass' \\ -H 'Connection: keep-alive' \\ -H 'Content-Length: 0' \\ -H 'Origin: http://ascportal:2900' \\ -H 'Referer: http://localhost:2900/tools/scriptrunner/?file=TARGET%2Fprocedures%2Fcmd_tlm_test.rb' \\ -H 'User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36 Edg/124.0.0.0' \\ --insecure   ブラウザ固有のヘッダーの多くは必要ありません。ここで重要なのはURLとリクエスト（この場合はPOST）です。これらをすべて調査すると、それぞれの役割がわかります：  スクリプトの内容を設定する ローカルの変更を更新しますスクリプトの内容をGETするのとは異なるリクエストであることに注意してください。これはページ読み込み時に行われます。 スクリプトをロックする（実行中に他のユーザーが編集できないようにするため）スクリプトを実行する（オプションを含むJSONを取ります）ログ用のWebsocketを開く結果をリクエストする（結果はredisに保存されるため、このURLは少し異なります）  以下はいくつかのオプションを指定して上記のすべてを実行するbashスクリプトです。ウェブリクエストにはcurl、JSONの解析とフォーマットにはjqが必要です。スクリプトをロックして実行し、継続的にステータスを確認し、結果をリクエストします。  #!/bin/bash set -e TARGET=${1:-'TARGET'} SCRIPT=${2:-'procedures/cmd_tlm_test.rb'} SUITE=${3:-'TestSuite'} COSMOS_HOST='http://localhost:2900' SCRIPT_API=&quot;$COSMOS_HOST/script-api&quot; SCRIPT_PATH=&quot;scripts/$TARGET/$SCRIPT&quot; CURL_ARGS=( -H 'Accept: application/json' -H 'Authorization: password' -H 'Accept-Language: en-US,en;q=0.9' -H 'Connection: keep-alive' -H 'Content-Type: application/json' --insecure --silent ) # Lock script # curl &quot;$SCRIPT_API/$SCRIPT_PATH/lock?scope=DEFAULT&quot; -X &quot;POST&quot; &quot;${CURL_ARGS[@]}&quot; # Run script # RUN_OPTS=$(cat &lt;&lt;-json { &quot;environment&quot;: [], &quot;suiteRunner&quot;: { &quot;method&quot;: &quot;start&quot;, &quot;suite&quot;: &quot;$SUITE&quot;, &quot;options&quot;: [ &quot;continueAfterError&quot; ] } } json ) RUN_OPTS=$(&lt;&lt;&lt;&quot;$RUN_OPTS&quot; jq -rc .) ID=$(curl &quot;$SCRIPT_API/$SCRIPT_PATH/run?scope=DEFAULT&quot; --data-raw &quot;$RUN_OPTS&quot; &quot;${CURL_ARGS[@]}&quot;) echo &quot;Starting Script '$SCRIPT_PATH' at $(date) (may take up to 15 minutes)&quot; &gt; /dev/stderr echo &quot;You can monitor it in Script Runner here: $COSMOS_HOST/tools/scriptrunner/$ID&quot; &gt; /dev/stderr # Loop while Script ID is still running # while true; do SCRIPT_STATUS=&quot;$(curl &quot;$SCRIPT_API/running-script?scope=DEFAULT&quot; &quot;${CURL_ARGS[@]}&quot; | jq &quot;.[]|select(.id==$ID)&quot;)&quot; if [[ -z $SCRIPT_STATUS ]]; then break; fi sleep 2 done # Request results # BUCKET_FILE_URI=&quot;$(curl &quot;$SCRIPT_API/completed-scripts?scope=DEFAULT&quot; &quot;${CURL_ARGS[@]}&quot; |\\ jq '[.[]|select(.name | test(&quot;'&quot;${SCRIPT_PATH#scripts/}&quot;' &quot;))][0] | .log | @uri' -r)&quot; URL=&quot;$(curl &quot;$COSMOS_HOST/openc3-api/storage/download/$BUCKET_FILE_URI?bucket=OPENC3_LOGS_BUCKET&amp;scope=DEFAULT&quot; &quot;${CURL_ARGS[@]}&quot; |jq .url -r)&quot; curl &quot;$COSMOS_HOST$URL&quot; &quot;${CURL_ARGS[@]}&quot;  ","version":"次へ","tagName":"h2"},{"title":"target.txtキーワード","type":0,"sectionRef":"#","url":"/ja/docs/configuration/target","content":"","keywords":"","version":"次へ"},{"title":"LANGUAGE​","type":1,"pageTitle":"target.txtキーワード","url":"/ja/docs/configuration/target#language","content":"  (5.11.1以降) ターゲットインターフェースとマイクロサービスのプログラミング言語   ターゲット言語はRubyまたはPythonのいずれかでなければなりません。言語はターゲットのインターフェースとマイクロサービスがどのように実行されるかを決定します。RubyとPythonの両方がテンプレート処理にERBを使用していることに注意してください。  パラメータ\t説明\t必須\tRubyまたはPython 有効な値: ruby, python\tはい  使用例:  LANGUAGE python   ","version":"次へ","tagName":"h2"},{"title":"REQUIRE​","type":1,"pageTitle":"target.txtキーワード","url":"/ja/docs/configuration/target#require","content":" Rubyファイルを要求する  依存関係を明示的に宣言するために必要なRubyファイルをリストします。これは現在完全にオプションです。  パラメータ\t説明\t必須ファイル名\t必要なファイル名。ターゲットのlibディレクトリ内のファイルについては、単にファイル名を指定してください（例：&quot;REQUIRE my_file&quot;）。基本OpenC3 libディレクトリ内のファイルも、単にファイル名をリストする必要があります。ファイルがlibディレクトリ下のフォルダ内にある場合は、フォルダ名を指定する必要があります（例：&quot;REQUIRE folder/my_file&quot;）。ファイル名を指定する際の「.rb」拡張子はオプションです。\tはい  使用例:  REQUIRE limits_response.rb   ","version":"次へ","tagName":"h2"},{"title":"IGNORE_PARAMETER​","type":1,"pageTitle":"target.txtキーワード","url":"/ja/docs/configuration/target#ignore_parameter","content":" 指定したコマンドパラメータを無視する  コマンドを処理する際に、他のOpenC3ツールがこのコマンドパラメータを非表示にするか無視するようにヒントを与えます。例えば、Command SenderとCommand Sequenceはコマンドを表示する際にパラメータを（デフォルトでは）表示せず、Script Runnerのコード補完はパラメータを表示しません。  パラメータ\t説明\t必須パラメータ名\tコマンドパラメータの名前。このパラメータは、それが現れるすべてのコマンドで無視されることに注意してください。\tはい  使用例:  IGNORE_PARAMETER CCSDS_VERSION   ","version":"次へ","tagName":"h2"},{"title":"IGNORE_ITEM​","type":1,"pageTitle":"target.txtキーワード","url":"/ja/docs/configuration/target#ignore_item","content":" 指定したテレメトリ項目を無視する  テレメトリを処理する際に、他のOpenC3ツールがこのテレメトリ項目を非表示にするか無視するようにヒントを与えます。例えば、Packet Viewerはパケットを表示する際に（デフォルトでは）この項目を表示しません。  パラメータ\t説明\t必須項目名\tテレメトリ項目の名前。この項目は、それが現れるすべてのテレメトリで無視されることに注意してください。\tはい  使用例:  IGNORE_ITEM CCSDS_VERSION   ","version":"次へ","tagName":"h2"},{"title":"COMMANDS​","type":1,"pageTitle":"target.txtキーワード","url":"/ja/docs/configuration/target#commands","content":" 指定したコマンド定義ファイルを処理する  このキーワードは、コマンド定義ファイルを処理するコマンドとテレメトリファイルのリストに明示的に追加するために使用されます。  警告 このキーワードを使用すると、自動コマンドとテレメトリファイルの検出が上書きされます。このキーワードを使用する場合は、TELEMETRYキーワードも使用して処理するテレメトリファイルを指定する必要があります。  パラメータ\t説明\t必須ファイル名\tターゲットのcmd_tlmディレクトリ内のコマンド定義ファイルの名前（例：&quot;cmd.txt&quot;）。\tはい  使用例:  COMMANDS inst_cmds_v2.txt TELEMETRY inst_tlm_v2.txt   ","version":"次へ","tagName":"h2"},{"title":"TELEMETRY​","type":1,"pageTitle":"target.txtキーワード","url":"/ja/docs/configuration/target#telemetry","content":" 指定したテレメトリ定義ファイルを処理する  このキーワードは、テレメトリ定義ファイルを処理するコマンドとテレメトリファイルのリストに明示的に追加するために使用されます。  警告 このキーワードを使用すると、自動コマンドとテレメトリファイルの検出が上書きされます。このキーワードを使用する場合は、COMMANDキーワードも使用して処理するコマンドファイルを指定する必要があります。  パラメータ\t説明\t必須ファイル名\tターゲットのcmd_tlmディレクトリ内のテレメトリ定義ファイルの名前（例：&quot;tlm.txt&quot;）。\tはい  使用例:  COMMANDS inst_cmds_v2.txt TELEMETRY inst_tlm_v2.txt   ","version":"次へ","tagName":"h2"},{"title":"CMD_UNIQUE_ID_MODE​","type":1,"pageTitle":"target.txtキーワード","url":"/ja/docs/configuration/target#cmd_unique_id_mode","content":"  (4.4.0以降) すべてのコマンドパケット識別子が同じビットオフセット、サイズ、タイプを共有していない   理想的には、ターゲットのすべてのコマンドは、各コマンドで全く同じビットオフセット、サイズ、タイプフィールドを使用して識別されます。いずれかのコマンド識別子が異なる場合は、強制的にブルートフォース識別方法を使用するために、このフラグを設定する必要があります。  警告 このモードを使用すると、パケット識別が著しく遅くなります  ","version":"次へ","tagName":"h2"},{"title":"TLM_UNIQUE_ID_MODE​","type":1,"pageTitle":"target.txtキーワード","url":"/ja/docs/configuration/target#tlm_unique_id_mode","content":"  (4.4.0以降) テレメトリパケット識別子がすべて同じビットオフセット、サイズ、タイプを共有していない   理想的には、ターゲットのすべてのテレメトリは、各パケットで全く同じビットオフセット、サイズ、タイプフィールドを使用して識別されます。いずれかのテレメトリ識別子が異なる場合は、強制的にブルートフォース識別方法を使用するために、このフラグを設定する必要があります。  警告 このモードを使用すると、パケット識別が著しく遅くなります ","version":"次へ","tagName":"h2"},{"title":"ログ構造","type":0,"sectionRef":"#","url":"/ja/docs/development/log-structure","content":"","keywords":"","version":"次へ"},{"title":"パケットログファイルフォーマット​","type":1,"pageTitle":"ログ構造","url":"/ja/docs/development/log-structure#パケットログファイルフォーマット","content":" OpenC3 COSMOS 6のパケットログは、さまざまなターゲットから受信した生のバイナリパケットを保存するために使用されます。また、JSON構造で保存された復調されたパケットも保存されます。  ","version":"次へ","tagName":"h2"},{"title":"ファイルヘッダー​","type":1,"pageTitle":"ログ構造","url":"/ja/docs/development/log-structure#ファイルヘッダー","content":" COSMOS 6のパケットログファイルは、8文字のシーケンス「COSMOS6_」で始まります。これはファイル名に依存せずにファイルの種類を識別し、新旧のバージョンと区別するために使用できます。  ","version":"次へ","tagName":"h3"},{"title":"エントリータイプ​","type":1,"pageTitle":"ログ構造","url":"/ja/docs/development/log-structure#エントリータイプ","content":" パケットログファイルには6つの異なるエントリータイプがあり、将来の拡張のための余地があります。すべてのエントリーヘッダーはビッグエンディアンのバイナリデータです。  共通エントリーフォーマット​  この共通フォーマットはすべてのパケットログエントリーに使用されます：  フィールド\tデータ型\t説明Length（長さ）\t32-bit符号なし整数\t長さフィールドを含まないエントリーの総バイト長。したがって最大エントリーサイズは4GiBとなります。 Entry Type（エントリータイプ）\t4-bit符号なし整数\tエントリータイプ： 1 = ターゲット宣言 2 = パケット宣言 3 = 生パケット 4 = JSON/CBORパケット 5 = オフセットマーカー 6 = キーマップ Cmd/Tlm Flag（コマンド/テレメトリフラグ）\t1-bit符号なし整数\t1 = コマンド 0 = テレメトリ Stored Flag（保存フラグ）\t1-bit符号なし整数\t1 = 保存データ 0 = リアルタイムデータ Id Flag（IDフラグ）\t1-bit符号なし整数\t1 = ID存在 0 = ID非存在 CBOR Flag（CBORフラグ）\t1-bit符号なし整数\t「JSON/CBORパケット」でのみ有効 1 = CBORデータ 0 = JSONデータ Extra Flag（追加フラグ）\t1-bit符号なし整数\t1 = 追加データ存在 0 = 追加データ非存在（COSMOS 5.11で追加） Received Time Flag（受信時間フラグ）\t1-bit符号なし整数\t1 = 受信時間あり 0 = 受信時間なし（COSMOS 5.11.0で追加） Reserved（予約）\t6-bit符号なし整数\t将来の拡張のために予約。使用しない場合は0に設定する必要があります。 Entry Data（エントリーデータ）\t可変長\tエントリータイプに基づく固有データ。以下のエントリータイプを参照 Id（ID）（オプション）\t32バイトバイナリハッシュ\tIDフィールドが設定されている場合、これはターゲット構成またはパケット構成を一意に識別する256ビットのSHA-256ハッシュです  ターゲット宣言エントリー​  ログファイルの書き込み時に初めて見られるターゲットの名前を宣言します。  フィールド\tデータ型\t説明Target Name（ターゲット名）\t可変長ASCII文字列\tターゲット名  パケット宣言エントリー​  ログファイルの書き込み時に初めて見られるパケットの名前を宣言します。インデックスによって関連するターゲット名を参照します。  フィールド\tデータ型\t説明Target Index（ターゲットインデックス）\t16-bit符号なし整数\tファイル内のターゲット宣言の順序から生成された、動的に構築されたターゲット名テーブルへのインデックス。最初のターゲット宣言はインデックス0、2番目のターゲット宣言はインデックス1を取得します。 Packet Name（パケット名）\t可変長ASCII文字列\tパケット名  生パケットとJSONパケットのエントリー​  パケットのメインデータを保持します。生パケットはCOSMOS復調フェーズ前のデータです。「JSON」パケットは復調後のデータです。「JSON」パケットは現在、ストレージサイズを削減するために通常JSONではなくCBORとして保存されることに注意してください。  フィールド\tデータ型\t説明Packet Index（パケットインデックス）\t16-bit符号なし整数\tファイル内のパケット宣言の順序から生成された、cmd_or_tlm/ターゲット名/パケット名タプルの動的に構築されたテーブルへのインデックス。最初のパケット宣言はインデックス0、2番目のパケット宣言はインデックス1を取得します。これにより、1つのファイル内の一意のパケットタイプの最大数は65536に制限されます。 Packet Timestamp（パケットタイムスタンプ）\t64-bit符号なし整数\tUnixエポック（1970年1月1日午前0時）からのナノ秒単位のパケットタイムスタンプ。このフィールドには、生およびJSONパケットエントリー（復調されたデータを保存するために使用）の両方の「パケット時間」が含まれます。JSONパケットエントリーの場合、必要に応じてJSONデータからパケット受信時間を抽出することもできます。 Received Timestamp（受信タイムスタンプ）（オプション）\t64-bit符号なし整数\t受信時間フラグが設定されている場合にのみ存在します（現在は生ログファイルのみ）。Unixエポック（1970年1月1日午前0時）からのナノ秒単位の受信タイムスタンプ。このフィールドには、生パケットエントリー（復調されたデータを保存するために使用）の「受信時間」が含まれます。JSONパケットエントリーの場合、必要に応じてJSONデータからパケット受信時間を抽出できます。 Extra Length（追加データ長）（オプション）\t32-bit符号なし整数\t追加フラグが設定されている場合にのみ存在。自身を含まない追加データのバイト単位の長さ。 Extra Data（追加データ）（オプション）\t可変長ブロックデータ\t追加フラグが設定されている場合にのみ存在。CBORまたはJSONでエンコードされた追加データのオブジェクト。 Packet Data（パケットデータ）\t可変長ブロックデータ\t生パケットエントリーの生バイナリパケットデータ、およびJSONパケットエントリーのASCII JSONデータ（またはフラグが設定されている場合はCBOR）。共通エントリーフォーマットのIdフィールドはいずれのタイプのパケットエントリーでもサポートされていないことに注意してください。  オフセットマーカーエントリー​  このファイルに保存された最後のパケットのRedisストリームオフセットが含まれています。このエントリーにより、ログファイルからCOSMOSが受信した最新のデータを保持するRedisストリームへのシームレスな移行が可能になります。  フィールド\tデータ型\t説明Offset Marker（オフセットマーカー）\t可変長ASCII文字列\tRedisオフセットマーカー  キーマップエントリー​  キーマップエントリーは、復調された値の名前のサイズを削減することにより、ログファイルのサイズをさらに減らすために使用されます。各値には0からカウントアップする数値名が付けられ、これにより復調されたデータのサイズが大幅に削減されます。注：将来的には、base64に似たより密度の高いエンコーディングに変更することでさらに強化される可能性があります。キーマップはパケットの最初の受信時に生成されます。将来のパケットが異なるキーを持つ場合、名前はそのまま使用され、削減は得られません。通常、パケットキーはファイル内で変更されません。  フィールド\tデータ型\t説明Packet Index（パケットインデックス）\t16-bit符号なし整数\tファイル内のパケット宣言の順序から生成された、パケット名の動的に構築されたテーブルへのインデックス。最初のパケット宣言はインデックス0、2番目のパケット宣言はインデックス1を取得します。 Key Map（キーマップ）\t可変長ASCII文字列\t数値キーから実際のパケット項目名へのマッピングを持つキーマップデータ ","version":"次へ","tagName":"h3"},{"title":"ロードマップ","type":0,"sectionRef":"#","url":"/ja/docs/development/roadmap","content":"","keywords":"","version":"次へ"},{"title":"OpenC3 COSMOS 6.x​","type":1,"pageTitle":"ロードマップ","url":"/ja/docs/development/roadmap#openc3-cosmos-6x","content":" プラグインアプリストア システムヘルスツール（Enterprise版） COSMOSノートブック（Jupyter Notebooksに類似） ログメッセージ抽出ツール（Enterprise版） テレメトリビューア画面での履歴データの再生 libCSPインターフェース（Cubesat Space Protocol） 一般的なメッセージバス用の標準化されたインターフェース（ZeroMQ、ActiveMQなど） 地上ネットワークとの統合（Atlas、RBC Signals） ミッションプランニングとの統合（Orbit Logic、Cognitive Space） 飛行力学との統合（Kayhan、SEE、Exotrail）   ","version":"次へ","tagName":"h2"},{"title":"OpenC3 COSMOS 7.x​","type":1,"pageTitle":"ロードマップ","url":"/ja/docs/development/roadmap#openc3-cosmos-7x","content":" スーパーブリッジ - これによりSaaS COSMOSが可能になり、クラウドサーバーからイントラネットへハードウェア制御のための安全な通信方法を提供します  ","version":"次へ","tagName":"h2"},{"title":"Githubの課題​","type":1,"pageTitle":"ロードマップ","url":"/ja/docs/development/roadmap#githubの課題","content":" 私たちはGithubの課題リストにあるバグや顧客からの要望を優先的に対応しています。OpenC3の顧客の場合は、support@openc3.comまでご連絡いただき、優先的に対応が必要な課題をお知らせください。 ","version":"次へ","tagName":"h2"},{"title":"SSL-TLS","type":0,"sectionRef":"#","url":"/ja/docs/configuration/ssl-tls","content":"","keywords":"","version":"次へ"},{"title":"証明書の生成​","type":1,"pageTitle":"SSL-TLS","url":"/ja/docs/configuration/ssl-tls#証明書の生成","content":" 注意: 自己署名証明書はインターネット上では安全でないと見なされます。Firefoxはサイトを無効な証明書として扱い、Chromeは接続がプレーンHTTPであるかのように動作します。  新しい自己署名SSL証明書を作成するには、openssl reqコマンドを使用します（cosmos-projectのルートからLinux上で実行）:  openssl req -newkey rsa:4096 \\ -x509 \\ -sha256 \\ -days 3650 \\ -nodes \\ -out ./openc3-traefik/cert.crt \\ -keyout ./openc3-traefik/cert.key Country Name (2 letter code) [XX]:. State or Province Name (full name) []:. Locality Name (eg, city) [Default City]:. Organization Name (eg, company) [Default Company Ltd]:. Organizational Unit Name (eg, section) []:. Common Name (eg, your name or your server hostname) []: &lt;!-- ここであなたのホスト名を更新してください --&gt; Email Address []:   コマンドの内容と各オプションの意味を見てみましょう:  newkey rsa:4096 - 新しい証明書リクエストと4096ビットのRSA鍵を作成します。デフォルトは2048ビットです。x509 - X.509証明書を作成します。sha256 - 256ビットのSHA（セキュアハッシュアルゴリズム）を使用します。days 3650 - 証明書の有効期間を日数で指定します。3650は10年です。任意の正の整数を使用できます。nodes - パスフレーズなしで鍵を作成します。out ./openc3-traefik/cert.crt - 新しく作成された証明書を書き込むファイル名を指定します。任意のファイル名を指定できます。keyout ./openc3-traefik/cert.key - 新しく作成された秘密鍵を書き込むファイル名を指定します。任意のファイル名を指定できます。  openssl reqコマンドオプションの詳細については、OpenSSL reqドキュメントページを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"openc3-traefik Dockerfileの更新​","type":1,"pageTitle":"SSL-TLS","url":"/ja/docs/configuration/ssl-tls#openc3-traefik-dockerfileの更新","content":" 新しい証明書をtraefik Dockerコンテナに追加します。  --- a/openc3-traefik/Dockerfile +++ b/openc3-traefik/Dockerfile @@ -1,3 +1,4 @@ FROM traefik:2.4 COPY ./traefik.yaml /etc/traefik/traefik.yaml +COPY ./cert.crt ./cert.key /etc/certs/ EXPOSE 80   ","version":"次へ","tagName":"h3"},{"title":"Traefik設定の更新​","type":1,"pageTitle":"SSL-TLS","url":"/ja/docs/configuration/ssl-tls#traefik設定の更新","content":" 新しい証明書ファイルを使用するようにTraefikを設定します。  openc3-traefik/traefik.yaml  --- a/openc3-traefik/traefik.yaml +++ b/openc3-traefik/traefik.yaml @@ -3,6 +3,17 @@ +tls: + certificates: + - certFile: &quot;/etc/certs/cert.crt&quot; + keyFile: &quot;/etc/certs/cert.key&quot; # 標準HTTPポートで入ってくるすべてをリッスンする entrypoints: web: address: &quot;:2900&quot; + http: + redirections: + entryPoint: + to: websecure + scheme: https + websecure: + address: &quot;:2943&quot; + http: + tls: + domains: + - main: &quot;&lt;!-- ここであなたのホスト名を更新してください --&gt;&quot;   ","version":"次へ","tagName":"h3"},{"title":"docker-compose.yamlの更新​","type":1,"pageTitle":"SSL-TLS","url":"/ja/docs/configuration/ssl-tls#docker-composeyamlの更新","content":" traefikがポート80の代わりにセキュアポート443を使用するように更新します。  --- a/compose.yaml +++ b/compose.yaml services: openc3-minio: @@ -70,7 +70,7 @@ services: openc3-traefik: image: &quot;ballaerospace/openc3-traefik:${OPENC3_TAG}&quot; ports: - - &quot;80:2900&quot; + - &quot;443:2943&quot; restart: &quot;unless-stopped&quot; depends_on:   これで./openc3.sh startを実行してTraefikコンテナを再ビルドすると、新しい証明書ファイルが含まれるはずです。  ","version":"次へ","tagName":"h3"},{"title":"暗号化​","type":1,"pageTitle":"SSL-TLS","url":"/ja/docs/configuration/ssl-tls#暗号化","content":" KEY​  privkey.pemは「キー」ファイルです。  時にはcert.keyやexample.com.keyとして名前が付けられることもあります。  CRT​  fullchain.pemが「crt」ファイルです。  時にはexample.com.crtとして名前が付けられることもあります。  CRT/KEYバンドル​  bundle.pemは次のように作成されます: cat fullchain.pem privkey.pem &gt; bundle.pem  HAProxyはbundle.pemを使用する唯一のサーバーです。  cert.pem​  cert.pemには証明書のみが含まれており、ブラウザがすでに署名した証明書を持っている場合にのみ単独で使用できます。これはテストでは機能するかもしれませんが（正しいファイルであるように見える）、実際には本番環境では多くのユーザーに対して信頼されていない証明書のセキュリティエラーで失敗します。  ただし、一般的にcert.pemを単独で使用することはありません。ほとんどの場合、chain.pemとfullchain.pemとして組み合わせて使用されます。  chain.pem​  chain.pemは、ルート認証局によって署名された中間署名認証局です。これはすべてのブラウザが事前に構築されたキャッシュに持っていることが保証されているものです。  ","version":"次へ","tagName":"h2"},{"title":"証明書の確認​","type":1,"pageTitle":"SSL-TLS","url":"/ja/docs/configuration/ssl-tls#証明書の確認","content":" 次のように証明書を確認できます:  openssl x509 -in cert.pem -text -noout   ","version":"次へ","tagName":"h3"},{"title":".pfxファイルから証明書と鍵を抽出する​","type":1,"pageTitle":"SSL-TLS","url":"/ja/docs/configuration/ssl-tls#pfxファイルから証明書と鍵を抽出する","content":" PKCS#12形式の.pfxファイルには、SSL証明書（公開鍵）と対応する秘密鍵が含まれています。別のシステムで使用するために、証明書と秘密鍵を暗号化されていないプレーンテキスト形式で別々にインポートする必要がある場合があります。このトピックでは、.pfxファイルを.crtファイルと.keyファイルに変換する方法について説明します。  ","version":"次へ","tagName":"h2"},{"title":".pfxファイルから.crtと.keyファイルを抽出する​","type":1,"pageTitle":"SSL-TLS","url":"/ja/docs/configuration/ssl-tls#pfxファイルからcrtとkeyファイルを抽出する","content":" 前提条件: SSL証明書を含むサーバーにOpenSSLがインストールされていることを確認してください。  OpenSSL\\binフォルダからOpenSSLを起動します。 コマンドプロンプトを開き、.pfxファイルが含まれているフォルダに移動します。 次のコマンドを実行して秘密鍵を抽出します:  openssl pkcs12 -in [yourfile.pfx] -nocerts -out [drlive.key]   インポートパスワードの入力を求められます。.pfxファイルを作成した時にキーペアを保護するために使用したパスワードを入力してください。作成中の.keyファイルを保護するための新しいパスワードを提供するよう再度求められます。不正使用を避けるため、安全な場所にキーファイルのパスワードを保存してください。  次のコマンドを実行して証明書を抽出します:  openssl pkcs12 -in [yourfile.pfx] -clcerts -nokeys -out [drlive.crt]   次のコマンドを実行して秘密鍵を復号化します:  openssl rsa -in [drlive.key] -out [drlive-decrypted.key]   前のステップで秘密鍵ファイルを保護するために作成したパスワードを入力します。 .crtファイルと復号化および暗号化された.keyファイルは、OpenSSLを起動したパスで利用できます。  ","version":"次へ","tagName":"h3"},{"title":".pfxファイルを.pem形式に変換する​","type":1,"pageTitle":"SSL-TLS","url":"/ja/docs/configuration/ssl-tls#pfxファイルをpem形式に変換する","content":" .pfxファイルを.pem形式に変換する必要がある場合があります。次のコマンドを実行してPEM形式に変換します。  openssl rsa -in [keyfile-encrypted.key] -outform PEM -out [keyfile-encrypted-pem.key]   ","version":"次へ","tagName":"h3"},{"title":"TLS1.2 INADEQUATE_SECURITYエラー​","type":1,"pageTitle":"SSL-TLS","url":"/ja/docs/configuration/ssl-tls#tls12-inadequate_securityエラー","content":" https://doc.traefik.io/traefik/https/tls/#cipher-suiteshttps://pkg.go.dev/crypto/tls#pkg-constants  tls: options: default: cipherSuites: - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 - TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256  ","version":"次へ","tagName":"h2"},{"title":"ファイル形式","type":0,"sectionRef":"#","url":"/ja/docs/configuration/format","content":"","keywords":"","version":"次へ"},{"title":"キーワード / パラメータ​","type":1,"pageTitle":"ファイル形式","url":"/ja/docs/configuration/format#キーワード--パラメータ","content":" COSMOSの設定ファイルの各行には、単一のキーワードとそれに続くパラメータが含まれています。例えば：  COMMAND TARGET COLLECT BIG_ENDIAN &quot;Collect command&quot;   キーワードはCOMMANDで、パラメータはTARGET、COLLECT、BIG_ENDIAN、および&quot;Collect command&quot;です。キーワードはCOSMOSによって解析され、パラメータの有効性がチェックされます。パラメータは必須または任意ですが、必須パラメータは常に最初に来ます。いくつかのパラメータには有効な値の限定セットがあります。例えば、上記のCOMMANDキーワードには以下のドキュメントがあります：  パラメータ\t説明\t必須Target\tこのコマンドが関連するターゲットの名前\tTrue Command\tこのコマンドの名前。ニーモニックとも呼ばれます。このターゲットへのコマンドに対して一意である必要があります。できるだけ短く明確であることが理想的です。\tTrue Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tTrue Description\t引用符で囲む必要があるこのコマンドの説明\tFalse  TargetとCommandのパラメータは任意の文字列であり、必須です。Endiannessパラメータは必須で、BIG_ENDIANまたはLITTLE_ENDIANである必要があります。他の値は解析時にエラーを引き起こします。Descriptionパラメータは引用符で囲む必要があり、任意です。すべてのCOSMOS設定ファイルはこの方法でキーワードとパラメータを文書化しています。さらに、上記の例のような使用例も提供されています。  ","version":"次へ","tagName":"h2"},{"title":"ERB​","type":1,"pageTitle":"ファイル形式","url":"/ja/docs/configuration/format#erb","content":" ERBはEmbedded Rubyの略です。ERBはRuby用のテンプレートシステムで、Rubyのロジックと変数を使用してテキストファイルを生成することができます。ERBには2つの基本的な形式があります：  &lt;% Rubyコード -- 出力なし %&gt; &lt;%= Ruby式 -- 結果を挿入 %&gt;   COSMOS Telemetry設定ファイルでは、次のように記述できます：  &lt;% (1..5).each do |i| %&gt; APPEND_ITEM VALUE&lt;%= i %&gt; 16 UINT &quot;Value &lt;%= i %&gt; setting&quot; &lt;% end %&gt;   最初の行は、1から5までを繰り返し、その値を変数iに格納するRubyコードです。ブロック内のコードは、反復が実行されるたびにファイルに出力されます。APPEND_ITEM行は、&lt;%=構文を使用してiの値を使用し、直接ファイルに出力します。解析結果は次のようになります：  APPEND_ITEM VALUE1 16 UINT &quot;Value 1 setting&quot; APPEND_ITEM VALUE2 16 UINT &quot;Value 2 setting&quot; APPEND_ITEM VALUE3 16 UINT &quot;Value 3 setting&quot; APPEND_ITEM VALUE4 16 UINT &quot;Value 4 setting&quot; APPEND_ITEM VALUE5 16 UINT &quot;Value 5 setting&quot;   COSMOSはプラグインのplugin.txt設定ファイルでERB構文を広範囲に使用しています。  ","version":"次へ","tagName":"h2"},{"title":"render​","type":1,"pageTitle":"ファイル形式","url":"/ja/docs/configuration/format#render","content":" COSMOSはERB内で使用されるrenderというメソッドを提供しており、これは設定ファイルを別の設定ファイルにレンダリングします。例えば：  TELEMETRY INST HEALTH_STATUS BIG_ENDIAN &quot;Health and status&quot; &lt;%= render &quot;_ccsds_apid.txt&quot;, locals: {apid: 1} %&gt; APPEND_ITEM COLLECTS 16 UINT &quot;Number of collects&quot; ...   renderメソッドは、最上位ファイルに注入する設定ファイルの名前をパラメータとして取ります。このファイルは通常の設定ファイルとして処理されるのを避けるために、アンダースコアで始まる必要があります。このファイルはより大きなファイルの一部であるため、パーシャルと呼ばれています。例えば、_ccsds_apid.txtは次のように定義されています：   APPEND_ID_ITEM CCSDSAPID 11 UINT &lt;%= apid %&gt; &quot;CCSDS application process id&quot;   これにより、出力は次のようになります：  TELEMETRY INST HEALTH_STATUS BIG_ENDIAN &quot;Health and status&quot; APPEND_ID_ITEM CCSDSAPID 11 UINT 1 &quot;CCSDS application process id&quot; APPEND_ITEM COLLECTS 16 UINT &quot;Number of collects&quot; ...   locals:構文を使用して変数apidが1に設定されていることに注意してください。これは、すべてのパケット定義に共通のヘッダーとフッターを追加するための非常に強力な方法です。より包括的な例については、DemoのINSTターゲットのcmd_tlm定義を参照してください。  ","version":"次へ","tagName":"h3"},{"title":"行継続​","type":1,"pageTitle":"ファイル形式","url":"/ja/docs/configuration/format#行継続","content":" COSMOSは設定ファイルで行継続文字をサポートしています。単純な行継続にはアンパサンド文字&amp;を使用します。例えば：  TELEMETRY INST HEALTH_STATUS BIG_ENDIAN &amp; &quot;Health and status&quot;   これによりアンパサンド文字が削除され、2行が結合されて次のようになります：  TELEMETRY INST HEALTH_STATUS BIG_ENDIAN &quot;Health and status&quot;   2行目の周りのスペースは削除されるため、インデントは重要ではありません。  ","version":"次へ","tagName":"h2"},{"title":"文字列連結​","type":1,"pageTitle":"ファイル形式","url":"/ja/docs/configuration/format#文字列連結","content":" COSMOSは設定ファイルで2つの異なる文字列連結文字をサポートしています。改行付きで文字列を連結するには、プラス文字：+を使用します。例えば：  TELEMETRY INST HEALTH_STATUS BIG_ENDIAN &quot;Health and status&quot; + &quot;Additional description&quot;   文字列は改行付きで結合され、次のようになります：  TELEMETRY INST HEALTH_STATUS BIG_ENDIAN &quot;Health and status\\nAdditional description&quot;   改行なしで文字列を連結するには、バックスラッシュ文字：\\を使用します。例えば：  TELEMETRY INST HEALTH_STATUS BIG_ENDIAN 'Health and status' \\ 'Additional description'   文字列は改行なしで結合され、次のようになります：  TELEMETRY INST HEALTH_STATUS BIG_ENDIAN 'Health and statusAdditional description'   文字列継続文字は単一引用符または二重引用符の文字列の両方で機能しますが、両方の行が同じ構文を使用する必要があることに注意してください。単一引用符の文字列と二重引用符の文字列を連結することはできません。また、2行目のインデントはホワイトスペースが削除されるため重要ではありません。 ","version":"次へ","tagName":"h2"},{"title":"COSMOSのテスト","type":0,"sectionRef":"#","url":"/ja/docs/development/testing","content":"","keywords":"","version":"次へ"},{"title":"Playwright​","type":1,"pageTitle":"COSMOSのテスト","url":"/ja/docs/development/testing#playwright","content":" ","version":"次へ","tagName":"h2"},{"title":"前提条件​","type":1,"pageTitle":"COSMOSのテスト","url":"/ja/docs/development/testing#前提条件","content":" Yarnのインストール npm install --global yarn COSMOS Playwrightリポジトリのクローン git clone https://github.com/OpenC3/cosmos-playwright Playwrightと依存関係のインストール cosmos-playwright % yarn install   ","version":"次へ","tagName":"h3"},{"title":"Playwrightテスト​","type":1,"pageTitle":"COSMOSのテスト","url":"/ja/docs/development/testing#playwrightテスト","content":" COSMOSの起動 cosmos % openc3.sh start ブラウザでCOSMOSを開きます。ログイン画面でパスワードを「password」に設定します。 テストの実行（注：--headedオプションはテストを視覚的に表示します。バックグラウンドで実行する場合は省略してください） テストは並行実行されるグループと直列実行されるグループに分けられています。これは全体の実行時間を短縮するためです。 cosmos-playwright % yarn test:parallel --headed cosmos-playwright % yarn test:serial --headed 両方のグループを一緒に実行することもできますが、--headedオプションは両方のグループに適用されません： cosmos-playwright % yarn test [任意] istanbul/nycカバレッジソースルックアップの修正（Linuxでない場合は fixwindows を使用）。 このステップなしでもテストは正常に実行され、カバレッジ統計は取得できますが、行ごとのカバレッジは機能しません。 cosmos-playwright % yarn fixlinux コードカバレッジの生成 cosmos-playwright % yarn coverage   コードカバレッジレポートは openc3-playwright/coverage/index.html で閲覧できます  ","version":"次へ","tagName":"h3"},{"title":"Rubyユニットテスト​","type":1,"pageTitle":"COSMOSのテスト","url":"/ja/docs/development/testing#rubyユニットテスト","content":" cosmos/openc3 フォルダに移動し、次のコマンドを実行します： cosmos/openc3 % rake build cosmos/openc3 % bundle exec rspec   コードカバレッジレポートは cosmos/openc3/coverage/index.html にあります  ","version":"次へ","tagName":"h2"},{"title":"Pythonユニットテスト​","type":1,"pageTitle":"COSMOSのテスト","url":"/ja/docs/development/testing#pythonユニットテスト","content":" cosmos/openc3/python フォルダに移動し、次のコマンドを実行します： cosmos/openc3/python % python -m pip install poetry cosmos/openc3/python % poetry install cosmos/openc3/python % poetry run coverage run -m pytest cosmos/openc3/python % poetry run coverage html   コードカバレッジレポートは cosmos/openc3/python/coverage/index.html にあります ","version":"次へ","tagName":"h2"},{"title":"COSMOSの開発","type":0,"sectionRef":"#","url":"/ja/docs/development/developing","content":"","keywords":"","version":"次へ"},{"title":"開発ツール​","type":1,"pageTitle":"COSMOSの開発","url":"/ja/docs/development/developing#開発ツール","content":" COSMOSのコアチームはVisual Studio Codeエディタを使用して開発しており、強くお勧めします。また、docker、kubernetes、gitlens、prettier、eslint、python、vetur、rubyなど多くの拡張機能を利用しています。これらのプラグインの構成を支援するために、VSCode用のopenc3.code-workspace設定をコミットしています。また、COSMOSを実行するための要件であるDocker Desktopも必要です。さらに、NodeJSとyarnもインストールする必要があります。  COSMOSのビルド  注意：私たちは主にMacOSでCOSMOSを開発しているため、ここで紹介するコマンドはbashスクリプトを参照していますが、Windowsでも同じファイルがバッチスクリプトとして存在します。  openc3.shスクリプトを使用してCOSMOSをビルドします：  % ./openc3.sh build   これにより、すべてのCOSMOSコンテナの依存関係がダウンロードされ、ローカルコンテナがビルドされます。注意：特に初回のビルドでは、これには長時間かかることがあります！  ビルドが完了すると、次のコマンドでビルドされたイメージを確認できます：  % docker image ls | grep &quot;openc3&quot; openc3inc/openc3-cosmos-init latest 4cac7a3ea9d3 29 hours ago 446MB openc3inc/openc3-cosmos-script-runner-api latest 4aacbaf49f7a 29 hours ago 431MB openc3inc/openc3-cosmos-cmd-tlm-api latest 9a8806bd4be3 3 days ago 432MB openc3inc/openc3-operator latest 223e98129fe9 3 days ago 405MB openc3inc/openc3-base latest 98df5c0378c2 3 days ago 405MB openc3inc/openc3-redis latest 5a3003a49199 8 days ago 111MB openc3inc/openc3-traefik latest ec13a8d16a2f 8 days ago 104MB openc3inc/openc3-minio latest 787f6e3fc0be 8 days ago 238MB openc3inc/openc3-node latest b3ee86d3620a 8 days ago 372MB openc3inc/openc3-ruby latest aa158bbb9539 8 days ago 326MB   オフラインでのビルド オフライン環境でビルドする場合や、プライベートなRubygems、NPM、APKサーバー（例：Nexus）を使用したい場合は、.envファイルで次の環境変数を更新できます：RUBYGEMS_URL、NPM_URL、APK_URLなど。例： ALPINE_VERSION=3.19 ALPINE_BUILD=7 RUBYGEMS_URL=https://rubygems.org NPM_URL=https://registry.npmjs.org APK_URL=http://dl-cdn.alpinelinux.org   COSMOSの実行  開発モードでCOSMOSを実行すると、内部APIポートへのlocalhostアクセスが可能になり、cmd-tlm-apiとscript-runner-api RailsサーバーでRAILS_ENV=developmentが設定されます。開発モードで実行するには：  % ./openc3.sh run   これで実行中のコンテナを確認できます（スペースを節約するためにCONTAINER ID、CREATED、STATUSは削除しています）：  % docker ps IMAGE COMMAND PORTS NAMES openc3/openc3-cmd-tlm-api:latest &quot;/sbin/tini -- rails…&quot; 127.0.0.1:2901-&gt;2901/tcp cosmos-openc3-cmd-tlm-api-1 openc3/openc3-script-runner-api:latest &quot;/sbin/tini -- rails…&quot; 127.0.0.1:2902-&gt;2902/tcp cosmos-openc3-script-runner-api-1 openc3/openc3-traefik:latest &quot;/entrypoint.sh trae…&quot; 0.0.0.0:2900-&gt;80/tcp cosmos-openc3-traefik-1 openc3/openc3-operator:latest &quot;/sbin/tini -- ruby …&quot; cosmos-openc3-operator-1 openc3/openc3-minio:latest &quot;/usr/bin/docker-ent…&quot; 127.0.0.1:9000-&gt;9000/tcp cosmos-openc3-minio-1 openc3/openc3-redis:latest &quot;docker-entrypoint.s…&quot; 127.0.0.1:6379-&gt;6379/tcp cosmos-openc3-redis-1   localhost:2900にアクセスすると、COSMOSが起動して実行されているのを確認できます！  ","version":"次へ","tagName":"h2"},{"title":"フロントエンドアプリケーションの実行​","type":1,"pageTitle":"COSMOSの開発","url":"/ja/docs/development/developing#フロントエンドアプリケーションの実行","content":" COSMOSが起動して実行されている状態で、個々のCOSMOSアプリケーションを開発するにはどうすればよいでしょうか？  yarnでフロントエンドをブートストラップします  openc3-init/plugins % yarn openc3-init/plugins % yarn build:common   ローカルのCOSMOSアプリケーション（CmdTlmServer、ScriptRunnerなど）を提供します  openc3-init % cd plugins/packages/openc3-tool-scriptrunner openc3-tool-scriptrunner % yarn serve built in 128722ms   アプリケーションのsingle SPAオーバーライドを設定します localhost:2900にアクセスして右クリックし、「検証」を選択します コンソールに以下を貼り付けます：  localStorage.setItem(&quot;devtools&quot;, true);   更新すると、右下に{...}が表示されます アプリケーション(@openc3/tool-scriptrunner)の横にあるDefaultボタンをクリックします 開発パスを貼り付けます。これはローカルのyarn serveが返すポートとツール名（scriptrunner）に依存します  http://localhost:2914/tools/scriptrunner/main.js  ページを更新すると、アプリケーション（この例ではScript Runner）のローカルコピーが表示されます。コード（console.logなど）を動的に追加すると、yarnウィンドウで再コンパイルされ、ブラウザが更新されて新しいコードが表示されます。フロントエンド開発を計画している場合は、ブラウザの開発ツールに慣れることを強くお勧めします。  ","version":"次へ","tagName":"h2"},{"title":"バックエンドサーバーの実行​","type":1,"pageTitle":"COSMOSの開発","url":"/ja/docs/development/developing#バックエンドサーバーの実行","content":" 開発したいコードがcmd-tlm-apiまたはscript-runner-apiバックエンドサーバーの場合、開発コピーへのアクセスを可能にするためにいくつかの手順があります。  traefikの開発バージョンを実行します。COSMOSはtraefikを使用してAPIリクエストを適切な場所に転送します。  % cd openc3-traefik openc3-traefik % docker ps # traefikを含む名前のコンテナを探します openc3-traefik % docker stop cosmos-openc3-traefik-1 openc3-traefik % docker build --build-arg TRAEFIK_CONFIG=traefik-dev.yaml -t openc3-traefik-dev . openc3-traefik % docker run --network=openc3-cosmos-network -p 2900:2900 -it --rm openc3-traefik-dev   cmd-tlm-apiまたはscript-runner-apiのローカルコピーを実行します  % cd openc3-cosmos-cmd-tlm-api openc3-cosmos-cmd-tlm-api % docker ps # cmd-tlm-apiを含む名前のコンテナを探します openc3-cosmos-cmd-tlm-api % docker stop cosmos-openc3-cosmos-cmd-tlm-api-1 # Windowsでは以下を実行します： openc3-cosmos-cmd-tlm-api&gt; dev_server.bat # Linuxでは、.envファイルのすべての環境変数を設定し、REDISをローカルにオーバーライドします openc3-cosmos-cmd-tlm-api % set -a; source ../.env; set +a openc3-cosmos-cmd-tlm-api % export OPENC3_REDIS_HOSTNAME=127.0.0.1 openc3-cosmos-cmd-tlm-api % export OPENC3_REDIS_EPHEMERAL_HOSTNAME=127.0.0.1 openc3-cosmos-cmd-tlm-api % bundle install openc3-cosmos-cmd-tlm-api % bundle exec rails s   bundle exec rails sコマンドが返ると、フロントエンドコードからの操作によるAPIリクエストが表示されるようになります。cmd-tlm-apiコードにコード（Rubyデバッグステートメントなど）を追加した場合は、サーバーを停止（CTRL-C）して再起動し、その効果を確認する必要があります。 ","version":"次へ","tagName":"h2"},{"title":"JSON API","type":0,"sectionRef":"#","url":"/ja/docs/development/json-api","content":"","keywords":"","version":"次へ"},{"title":"認証​","type":1,"pageTitle":"JSON API","url":"/ja/docs/development/json-api#認証","content":" HTTP認証リクエストヘッダーには、ユーザーエージェントをサーバーで認証するための資格情報が含まれています。通常、サーバーが401 Unauthorized ステータスとWWW-Authenticateヘッダーで応答した後に使用されますが、必ずしもそうではありません。  Authorization: &lt;token/password&gt;   ","version":"次へ","tagName":"h2"},{"title":"JSON-RPC 2.0​","type":1,"pageTitle":"JSON API","url":"/ja/docs/development/json-api#json-rpc-20","content":" COSMOS APIは、JSON-RPC 2.0仕様の緩和されたバージョンを実装しています。「id」がNULLのリクエストはサポートされていません。数値には、NaNや+/-infなどの特殊な非文字列リテラルを含めることができます。リクエストパラメータは位置で指定する必要があり、名前による指定はサポートされていません。仕様のセクション6「バッチ操作」はサポートされていません。COSMOSのスコープは&quot;keyword_params&quot;オブジェクトで指定する必要があります。  ","version":"次へ","tagName":"h2"},{"title":"ソケット接続​","type":1,"pageTitle":"JSON API","url":"/ja/docs/development/json-api#ソケット接続","content":" COSMOS コマンド＆テレメトリサーバーは、HTTPサーバー（デフォルトポート7777）でCOSMOS APIへの接続をリッスンします。  COSMOSは、デフォルトの2900ポートの/openc3-api/apiエンドポイントでHTTP APIリクエストをリッスンします。  ","version":"次へ","tagName":"h2"},{"title":"サポートされているメソッド​","type":1,"pageTitle":"JSON API","url":"/ja/docs/development/json-api#サポートされているメソッド","content":" COSMOS APIでサポートされているメソッドのリストは、Github上のapiソースコードにあります。@api_whitelistという変数は、CTSで受け入れられるすべてのメソッドの配列で初期化されています。このページでは、APIのすべてのメソッドの完全な引数リストを示しませんが、JSON APIメソッドはスクリプト作成ガイドに記載されているCOSMOSスクリプティングAPIメソッドに対応していることに注意してください。このページでは、いくつかのJSON要求と応答の例を示します。スクリプティングガイドは、ここで明示的に文書化されていないメソッドのリクエストの構築方法とレスポンスの解析方法を推測するための参考として使用できます。  ","version":"次へ","tagName":"h2"},{"title":"既存の実装​","type":1,"pageTitle":"JSON API","url":"/ja/docs/development/json-api#既存の実装","content":" COSMOS JSON APIは以下の言語で実装されています：Ruby、PythonとJavascript。  ","version":"次へ","tagName":"h2"},{"title":"使用例​","type":1,"pageTitle":"JSON API","url":"/ja/docs/development/json-api#使用例","content":" ","version":"次へ","tagName":"h2"},{"title":"コマンドの送信​","type":1,"pageTitle":"JSON API","url":"/ja/docs/development/json-api#コマンドの送信","content":" コマンドを送信するには、次のメソッドが使用されます：cmd、cmd_no_range_check、cmd_no_hazardous_check、cmd_no_checks  cmdメソッドは、システム内のCOSMOSターゲットにコマンドを送信します。cmd_no_range_checkメソッドも同様ですが、パラメータの範囲エラーを無視します。cmd_no_hazardous_checkメソッドも同様ですが、危険なコマンドの送信を許可します。cmd_no_checksメソッドも同様ですが、危険なコマンドの送信を許可し、範囲エラーを無視します。  2つのパラメータ構文がサポートされています。  1つ目は、「TARGET_NAME COMMAND_NAME with PARAMETER_NAME_1 PARAMETER_VALUE_1, PARAMETER_NAME_2 PARAMETER_VALUE_2, ...」の形式の単一の文字列です。「with ...」部分は省略可能です。指定されていないパラメータにはデフォルト値が与えられます。  パラメータ\tデータ型\t説明command_string\tstring\tコマンドに必要なすべての情報を含む単一文字列  2つ目は、最初のパラメータがターゲット名を示す文字列、2番目がコマンド名を含む文字列、そしてオプションの3番目がパラメータ名/値のハッシュである2つまたは3つのパラメータです。このフォーマットは、コマンドにASCIIテキストとして表現できないバイナリデータを取るパラメータが含まれている場合に使用する必要があります。cmdおよびcmd_no_range_checkメソッドは、危険とマークされたコマンドを送信しようとするとすべて失敗します。危険なコマンドを送信するには、cmd_no_hazardous_checkまたはcmd_no_checksメソッドを使用する必要があります。  パラメータ\tデータ型\t説明target_name\tString\tコマンドを送信するターゲットの名前 command_name\tString\tコマンドの名前 command_params\tHash\tオプションのコマンドパラメータのハッシュ  使用例：  --&gt; {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;cmd&quot;, &quot;params&quot;: [&quot;INST COLLECT with DURATION 1.0, TEMP 0.0, TYPE 'NORMAL'&quot;], &quot;id&quot;: 1, &quot;keyword_params&quot;:{&quot;scope&quot;:&quot;DEFAULT&quot;}} &lt;-- {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: [&quot;INST&quot;, &quot;COLLECT&quot;, {&quot;DURATION&quot;: 1.0, &quot;TEMP&quot;: 0.0, &quot;TYPE&quot;: &quot;NORMAL&quot;}], &quot;id&quot;: 1} --&gt; {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;cmd&quot;, &quot;params&quot;: [&quot;INST&quot;, &quot;COLLECT&quot;, {&quot;DURATION&quot;: 1.0, &quot;TEMP&quot;: 0.0, &quot;TYPE&quot;: &quot;NORMAL&quot;}], &quot;id&quot;: 1, &quot;keyword_params&quot;:{&quot;scope&quot;:&quot;DEFAULT&quot;}} &lt;-- {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: [&quot;INST&quot;, &quot;COLLECT&quot;, {&quot;DURATION&quot;: 1.0, &quot;TEMP&quot;: 0.0, &quot;TYPE&quot;: &quot;NORMAL&quot;}], &quot;id&quot;: 1}   ","version":"次へ","tagName":"h3"},{"title":"テレメトリの取得​","type":1,"pageTitle":"JSON API","url":"/ja/docs/development/json-api#テレメトリの取得","content":" テレメトリを取得するには、次のメソッドが使用されます：tlm、tlm_raw、tlm_formatted、tlm_with_units  tlmメソッドは、テレメトリポイントの現在の変換値を返します。tlm_rawメソッドは、テレメトリポイントの現在の生の値を返します。tlm_formattedメソッドは、テレメトリポイントの現在のフォーマット済み値を返します。tlm_with_unitsメソッドは、テレメトリポイントの現在のフォーマット済み値に単位を付加して返します。  2つのパラメータ構文がサポートされています。  1つ目は、「TARGET_NAME PACKET_NAME ITEM_NAME」の形式の単一の文字列です。  パラメータ\tデータ型\t説明tlm_string\tString\tテレメトリ項目に必要なすべての情報を含む単一文字列  2つ目は、最初のパラメータがターゲット名を示す文字列、2番目がパケット名を含む文字列、3番目が項目名を含む文字列である3つのパラメータです。  パラメータ\tデータ型\t説明target_name\tString\tテレメトリ値を取得するターゲットの名前 packet_name\tString\tテレメトリ値を取得するパケットの名前 item_name\tString\tテレメトリ項目の名前  使用例：  --&gt; {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;tlm&quot;, &quot;params&quot;: [&quot;INST HEALTH_STATUS TEMP1&quot;], &quot;id&quot;: 2, &quot;keyword_params&quot;:{&quot;scope&quot;:&quot;DEFAULT&quot;}} &lt;-- {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 94.9438, &quot;id&quot;: 2} --&gt; {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;tlm&quot;, &quot;params&quot;: [&quot;INST&quot;, &quot;HEALTH_STATUS&quot;, &quot;TEMP1&quot;], &quot;id&quot;: 2, &quot;keyword_params&quot;:{&quot;scope&quot;:&quot;DEFAULT&quot;}} &lt;-- {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 94.9438, &quot;id&quot;: 2}   ","version":"次へ","tagName":"h3"},{"title":"さらなるデバッグ​","type":1,"pageTitle":"JSON API","url":"/ja/docs/development/json-api#さらなるデバッグ","content":" 別の言語からJSON APIのインターフェースを開発する場合、最適なデバッグ方法は、まず以下のようにサポートされているRubyインターフェースから同じメッセージを送信することです。デバッグモードを有効にすることで、Ruby実装から送信される正確なリクエストとレスポンスを確認できます。  COSMOSを起動するCommand Senderを開くブラウザの開発者ツールを開く（Chromeでは右クリック-&gt;検証）「Network」タブをクリック（+ボタンで追加する必要があるかもしれません）GUIでコマンドを送信する開発者ツールでリクエストを表示する。「Payload」サブタブをクリックしてJSONを表示する  また、curlのようなプログラムを使用して、ターミナルからこれらの生のコマンドを送信することもできます：  curl -d '{&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;tlm&quot;, &quot;params&quot;: [&quot;INST HEALTH_STATUS TEMP1&quot;], &quot;id&quot;: 2, &quot;keyword_params&quot;:{&quot;type&quot;:&quot;WITH_UNITS&quot;,&quot;scope&quot;:&quot;DEFAULT&quot;}}' http://localhost:2900/openc3-api/api -H &quot;Authorization: password&quot;  ","version":"次へ","tagName":"h2"},{"title":"ストリーミングAPI","type":0,"sectionRef":"#","url":"/ja/docs/development/streaming-api","content":"","keywords":"","version":"次へ"},{"title":"Ruby の例​","type":1,"pageTitle":"ストリーミングAPI","url":"/ja/docs/development/streaming-api#ruby-の例","content":" 以下は、ストリーミングAPIを使用してテレメトリデータを取得するための簡単なRubyの例です：  require 'openc3' require 'openc3/script/web_socket_api' $openc3_scope = 'DEFAULT' ENV['OPENC3_API_HOSTNAME'] = '127.0.0.1' ENV['OPENC3_API_PORT'] = '2900' ENV['OPENC3_API_PASSWORD'] = 'password' # 以下はEnterprise版で必要です（必要に応じてユーザー/パスワードを変更してください） #ENV['OPENC3_API_USER'] = 'operator' #ENV['OPENC3_API_PASSWORD'] = 'operator' #ENV['OPENC3_KEYCLOAK_REALM'] = 'openc3' #ENV['OPENC3_KEYCLOAK_URL'] = 'http://127.0.0.1:2900/auth' # CSVデータを書き込むファイルを開く csv = File.open('telemetry_data.csv', 'w') # ストリーミングAPIに接続 OpenC3::StreamingWebSocketApi.new() do |api| # ストリームにアイテムを追加 - 昨日から1分前までのデータをリクエスト api.add(items: [ 'DECOM__TLM__INST__HEALTH_STATUS__TEMP1__CONVERTED', 'DECOM__TLM__INST__HEALTH_STATUS__TEMP2__CONVERTED' ], start_time: (Time.now - 86400).to_nsec_from_epoch, # 24時間前 end_time: (Time.now - 60).to_nsec_from_epoch) # 1分前 # CSVヘッダーを書き込む csv.puts &quot;Time,TEMP1,TEMP2&quot; # ストリームからすべてのデータを読み込む data = api.read # 各データポイントを処理 data.each do |item| csv.puts &quot;#{item['__time']/1_000_000_000.0},#{item['DECOM__TLM__INST__HEALTH_STATUS__TEMP1__CONVERTED']},#{item['DECOM__TLM__INST__HEALTH_STATUS__TEMP2__CONVERTED']}&quot; end end csv.close()   ","version":"次へ","tagName":"h2"},{"title":"StreamingApi アーキテクチャ​","type":1,"pageTitle":"ストリーミングAPI","url":"/ja/docs/development/streaming-api#streamingapi-アーキテクチャ","content":" StreamingApiはCOSMOSのコアコンポーネントで、リアルタイムおよび履歴データのストリーミング機能を提供します。以下は、そのアーキテクチャと設計の概要です。  ","version":"次へ","tagName":"h2"},{"title":"アーキテクチャの概要​","type":1,"pageTitle":"ストリーミングAPI","url":"/ja/docs/development/streaming-api#アーキテクチャの概要","content":" StreamingApiはいくつかの主要なコンポーネントを持つモジュラーアーキテクチャを使用しています：  StreamingApi ├── StreamingThread (抽象) │ ├── RealtimeStreamingThread │ └── LoggedStreamingThread └── StreamingObjectCollection └── StreamingObject   ","version":"次へ","tagName":"h3"},{"title":"主要コンポーネント​","type":1,"pageTitle":"ストリーミングAPI","url":"/ja/docs/development/streaming-api#主要コンポーネント","content":" StreamingApi​  ストリーミング接続を管理し、クライアントリクエストを処理するメインクラス：  クライアントUUID、チャネル、スコープで初期化リアルタイムと履歴データの両方のスレッドライフサイクルを管理データストリームの追加または削除に関するクライアントリクエストを処理履歴データからリアルタイムストリーミングへの引き渡しを調整バッチ処理されたデータをActionCable経由でクライアントに送信  StreamingThread​  共通スレッド機能を定義する抽象基本クラス：  スレッドライフサイクル（開始、停止）を管理さまざまなソースからのデータを処理結果のバッチ処理と送信を処理ストリーミングが完了したかどうかを判断  RealtimeStreamingThread​  リアルタイムデータ用の特殊スレッド：  Redisトピックをサブスクライブリアルタイムで受信メッセージを処理現在の時刻からの連続的なストリーミング  LoggedStreamingThread​  履歴データ用の特殊スレッド：  アーカイブされたログファイルから読み取りデータの時間ベースのソートを処理履歴データが使い果たされたときにリアルタイムストリーミングに移行  StreamingObject​  単一のサブスクリプションアイテムを表す：  ストリームキーを解析して検証ストリームに関するメタデータ（モード、ターゲット、パケット、アイテム）を保存タイムスタンプとオフセットを追跡認証を処理  StreamingObjectCollection​  StreamingObjectのグループを管理：  トピックによってオブジェクトを整理集合的な状態を追跡効率的な検索を提供  ","version":"次へ","tagName":"h3"},{"title":"データフロー​","type":1,"pageTitle":"ストリーミングAPI","url":"/ja/docs/development/streaming-api#データフロー","content":" クライアントがActionCableに接続し、StreamingChannelをサブスクライブクライアントがストリームするアイテム/パケットを含む「add」リクエストを送信StreamingApiが認証付きの適切なStreamingObjectを作成履歴リクエストの場合： LoggedStreamingThreadがログファイルから読み取りデータはバッチでクライアントに送信履歴データが使い果たされたらリアルタイムに引き渡し リアルタイムリクエストの場合： RealtimeStreamingThreadがRedisトピックをサブスクライブデータは到着次第クライアントに送信 クライアントはいつでもアイテムの追加/削除が可能クライアントが切断されると、すべてのスレッドが終了  ","version":"次へ","tagName":"h3"},{"title":"パフォーマンスに関する考慮事項​","type":1,"pageTitle":"ストリーミングAPI","url":"/ja/docs/development/streaming-api#パフォーマンスに関する考慮事項","content":" 履歴データには「リクエストごとにスレッド」モデルを使用リアルタイムデータには単一のスレッドを維持ネットワークオーバーヘッドを減らすためにバッチ処理された結果（バッチあたり最大100アイテム）効率的な履歴データアクセスのためのファイルキャッシング履歴データからリアルタイムデータへのシームレスな移行  ","version":"次へ","tagName":"h3"},{"title":"セキュリティ​","type":1,"pageTitle":"ストリーミングAPI","url":"/ja/docs/development/streaming-api#セキュリティ","content":" すべてのStreamingObjectは、リクエストされた特定のターゲットとパケットの認証を検証し、ユーザーが表示権限を持つデータのみにアクセスできるようにします。 ","version":"次へ","tagName":"h3"},{"title":"テーブル","type":0,"sectionRef":"#","url":"/ja/docs/configuration/table","content":"","keywords":"","version":"次へ"},{"title":"テーブル定義ファイル​","type":1,"pageTitle":"テーブル","url":"/ja/docs/configuration/table#テーブル定義ファイル","content":" テーブル定義ファイルは、COSMOS テーブルマネージャーで表示できるバイナリテーブルを定義します。テーブル定義はターゲットのtables/configディレクトリで定義され、通常はPPSSelectionTable_def.txtのようにテーブル名に基づいて命名されます。_def.txt拡張子はそのファイルがテーブル定義であることを識別するのに役立ちます。テーブル定義はTABLEFILEキーワードを使用して組み合わせることができます。これにより、個々のテーブルコンポーネントをより大きなバイナリに構築することができます。  テーブル定義ファイルはコマンド設定と多くの類似点を共有しています。同じデータ型があります：INT、UINT、FLOAT、STRING、BLOCK。これらはそれぞれ整数、符号なし整数、浮動小数点数、文字列、およびバイナリデータブロックに対応しています。    テーブルキーワード  ","version":"次へ","tagName":"h2"},{"title":"TABLEFILE​","type":1,"pageTitle":"テーブル","url":"/ja/docs/configuration/table#tablefile","content":" テーブル定義のために開いて処理する別のファイルを指定する  パラメータ\t説明\t必須File Name\tファイルの名前。ファイルは現在の定義ファイルのディレクトリで検索されます。\tTrue  ","version":"次へ","tagName":"h2"},{"title":"TABLE​","type":1,"pageTitle":"テーブル","url":"/ja/docs/configuration/table#table","content":" 新しいテーブル定義を開始する  パラメータ\t説明\t必須Name\t引用符で囲まれたテーブルの名前。名前はGUIタブに表示されます。\tTrue Endianness\tこのテーブル内のデータがビッグエンディアンまたはリトルエンディアン形式であるかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tTrue Display\tテーブルがKEY_VALUE行（各行が一意）を含むか、または同一の行に異なる値を含むROW_COLUMNテーブルであるかを示します。 有効な値: KEY_VALUE, ROW_COLUMN\tFalse  DisplayがKEY_VALUEの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Description\t引用符で囲まれたテーブルの説明。説明はマウスオーバーポップアップとステータスライン情報で使用されます。\tFalse  DisplayがROW_COLUMNの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Rows\tテーブル内の行数\tFalse Description\t引用符で囲まれたテーブルの説明。説明はマウスオーバーポップアップとステータスライン情報で使用されます。\tFalse  ","version":"次へ","tagName":"h2"},{"title":"TABLE修飾子​","type":1,"pageTitle":"テーブル","url":"/ja/docs/configuration/table#table修飾子","content":" 次のキーワードはTABLEキーワードに続く必要があります。  ","version":"次へ","tagName":"h2"},{"title":"PARAMETER​","type":1,"pageTitle":"テーブル","url":"/ja/docs/configuration/table#parameter","content":" 現在のテーブル内のパラメータを定義する  パラメータ\t説明\t必須Name\tパラメータの名前。テーブル内で一意である必要があります。\tTrue Bit Offset\tこのパラメータの最上位ビットのテーブル内のビットオフセット。テーブルの末尾からのオフセットを示すために負の値を使用することもできます。派生パラメータには常にビットオフセット0を使用します。\tTrue Bit Size\tこのパラメータのビットサイズ。ゼロまたは負の値を使用して、文字列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。Bit Offsetが0でBit Sizeが0の場合、これは派生パラメータであり、Data Typeは'DERIVED'に設定する必要があります。\tTrue Data Type\tこのパラメータのデータ型 有効な値: INT, UINT, FLOAT, DERIVED, STRING, BLOCK\tTrue  Data TypeがINT、UINT、FLOAT、DERIVEDの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Minimum Value\tこのパラメータに許可される最小値\tTrue Maximum Value\tこのパラメータに許可される最大値\tTrue Default Value\tこのパラメータのデフォルト値。デフォルト値を提供する必要がありますが、パラメータをREQUIREDとマークすると、スクリプトは値を指定するよう強制されます。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します。リトルエンディアンビットフィールドのガイドを参照してください。 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  Data TypeがSTRING、BLOCKの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Default Value\tこのパラメータのデフォルト値。デフォルト値を提供する必要がありますが、パラメータをREQUIREDとマークすると、スクリプトは値を指定するよう強制されます。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  ","version":"次へ","tagName":"h3"},{"title":"PARAMETER修飾子​","type":1,"pageTitle":"テーブル","url":"/ja/docs/configuration/table#parameter修飾子","content":" 次のキーワードはPARAMETERキーワードに続く必要があります。  FORMAT_STRING​  printfスタイルのフォーマットを追加する  パラメータ\t説明\t必須Format\tprintf構文を使用してフォーマットする方法。例えば、'0x%0X'は値を16進数で表示します。\tTrue  使用例:  FORMAT_STRING &quot;0x%0X&quot;   UNITS​  表示単位を追加する  パラメータ\t説明\t必須Full Name\t単位タイプのフルネーム（例：摂氏）\tTrue Abbreviated\t単位の略称（例：C）\tTrue  使用例:  UNITS Celsius C UNITS Kilometers KM   DESCRIPTION​  定義された説明をオーバーライドする  パラメータ\t説明\t必須Value\t新しい説明\tTrue  META​  カスタムユーザーメタデータを格納する  メタデータは、カスタムツールがさまざまな目的で使用できるユーザー固有のデータです。一例として、ソースコードヘッダーファイルを生成するために必要な追加情報を格納するためのものがあります。  パラメータ\t説明\t必須Meta Name\t格納するメタデータの名前\tTrue Meta Values\tこのMeta Nameに格納する1つ以上の値\tFalse  使用例:  META TEST &quot;This parameter is for test purposes only&quot;   OVERLAP​   (Since 4.4.1) このアイテムはパケット内の他のアイテムと重複することが許可されています   アイテムのビットオフセットが他のアイテムと重複する場合、OpenC3は警告を発します。このキーワードは、アイテムが他のアイテムと重複することを明示的に許可し、警告メッセージを抑制します。  KEY​   (Since 5.0.10) パケット内のこの生の値にアクセスするために使用されるキーを定義します   キーは多くの場合、JSONPathやXPath文字列です  パラメータ\t説明\t必須Key string\tこのアイテムにアクセスするためのキー\tTrue  使用例:  KEY $.book.title   VARIABLE_BIT_SIZE​   (Since 5.18.0) アイテムのビットサイズが別の長さアイテムによって定義されていることを示します   パラメータ\t説明\t必須Length Item Name\t関連する長さアイテムの名前\tTrue Length Bits Per Count\t長さアイテムのカウント当たりのビット数。デフォルトは8\tFalse Length Value Bit Offset\t長さフィールド値に適用するビットオフセット。デフォルトは0\tFalse  REQUIRED​  スクリプトでパラメータを必ず指定する必要がある  Script Runner経由でコマンドを送信する際、現在のコマンドパラメータに常に値を指定する必要があります。これにより、ユーザーがデフォルト値に依存することを防ぎます。これはCommand Senderには影響せず、PARAMETER定義で提供されたデフォルト値でフィールドが入力されることに注意してください。  MINIMUM_VALUE​  定義された最小値をオーバーライドする  パラメータ\t説明\t必須Value\tパラメータの新しい最小値\tTrue  MAXIMUM_VALUE​  定義された最大値をオーバーライドする  パラメータ\t説明\t必須Value\tパラメータの新しい最大値\tTrue  DEFAULT_VALUE​  定義されたデフォルト値をオーバーライドする  パラメータ\t説明\t必須Value\tパラメータの新しいデフォルト値\tTrue  STATE​  現在のコマンドパラメータのキー/値ペアを定義する  キー値のペアにより、ユーザーフレンドリーな文字列が可能になります。例えば、ON = 1およびOFF = 0の状態を定義できます。これにより、コマンドパラメータを送信する際に、数字の1ではなく単語「ON」を使用できるようになり、より明確で、ユーザーエラーの可能性が低くなります。  パラメータ\t説明\t必須Key\t文字列の状態名\tTrue Value\t数値の状態値\tTrue Hazardous / Disable Messages\t状態が危険であることを示します。これにより、このコマンドを送信する際にユーザー確認を求めるポップアップが表示されます。危険でない状態の場合、DISABLE_MESSAGESを設定することもでき、その状態を使用する際にコマンドを表示しません。 有効な値: HAZARDOUS\tFalse Hazardous Description\tこの状態が危険である理由を説明する文字列\tFalse  使用例:  APPEND_PARAMETER ENABLE 32 UINT 0 1 0 &quot;Enable setting&quot; STATE FALSE 0 STATE TRUE 1 APPEND_PARAMETER STRING 1024 STRING &quot;NOOP&quot; &quot;String parameter&quot; STATE &quot;NOOP&quot; &quot;NOOP&quot; DISABLE_MESSAGES STATE &quot;ARM LASER&quot; &quot;ARM LASER&quot; HAZARDOUS &quot;Arming the laser is an eye safety hazard&quot; STATE &quot;FIRE LASER&quot; &quot;FIRE LASER&quot; HAZARDOUS &quot;WARNING! Laser will be fired!&quot;   WRITE_CONVERSION​  現在のコマンドパラメータに書き込み時の変換を適用する  変換はカスタムRubyまたはPythonファイルで実装され、ターゲットのlibフォルダーに配置する必要があります。クラスはConversionを継承する必要があります。追加パラメータを取る場合はinitialize（Ruby）または__init__（Python）メソッドを実装する必要があり、常にcallメソッドを実装する必要があります。変換係数は、ユーザーが入力した値にバイナリコマンドパケットに書き込まれて送信される前に適用されます。  書き込み変換を適用する場合、データ型が変更されることがあります。例えば、入力STRING型からUINT型を作成する場合（この例についてはip_write_conversion.rbまたはip_write_conversion.pyを参照）。この場合、コマンド定義のデータ型はUINTであり、最小値・最大値は重要ではない（ただし指定する必要がある）ため、通常はMIN MAXに設定されます。デフォルト値は重要であり、文字列として指定する必要があります。完全な例については、COSMOS DemoのTIME_OFFSETコマンド定義のIP_ADDRESSパラメータを参照してください：INST inst_cmds.txtまたはINST2 inst_cmds.txt。  コマンドパラメータに対する複数の書き込み変換 コマンドが構築されると、各アイテムがデフォルト値を設定するために書き込まれ（このとき書き込み変換が実行されます）、その後、ユーザーが提供した値でアイテムが書き込まれます（ここでも書き込み変換が実行されます）。したがって、書き込み変換は2回実行される可能性があります。また、どのパラメータがすでに書き込まれたかについての保証はありません。パケット自体には、コマンドにユーザーが提供した値のハッシュを取得するためのgiven_values()メソッドがあります。これを使用して渡されたパラメータ値を確認できます。  パラメータ\t説明\t必須Class Filename\tRubyまたはPythonクラスを含むファイル名。ファイル名はクラス名に基づいて命名する必要があり、クラスはアンダースコア付きのファイル名のCamelCase版である必要があります。例えば、'the_great_conversion.rb'は'class TheGreatConversion'を含んでいるべきです。\tTrue Parameter\tクラスコンストラクタに渡される変換の追加パラメータ値。\tFalse  Ruby例:  WRITE_CONVERSION the_great_conversion.rb 1000 Defined in the_great_conversion.rb: require 'openc3/conversions/conversion' module OpenC3 class TheGreatConversion &lt; Conversion def initialize(multiplier) super() @multiplier = multiplier.to_f end def call(value, packet, buffer) return value * multiplier end end end   Python例:  WRITE_CONVERSION the_great_conversion.py 1000 Defined in the_great_conversion.py: from openc3.conversions.conversion import Conversion class TheGreatConversion(Conversion): def __init__(self, multiplier): super().__init__() self.multiplier = float(multiplier) def call(self, value, packet, buffer): return value * self.multiplier   POLY_WRITE_CONVERSION​  現在のコマンドパラメータに多項式変換係数を追加する  変換係数は、ユーザーが入力した値にバイナリコマンドパケットに書き込まれて送信される前に適用されます。  パラメータ\t説明\t必須C0\t係数\tTrue Cx\t変換の追加係数値。任意の次数の多項式変換を使用できるため、「x」の値は多項式の次数によって異なります。より高次の多項式は処理に時間がかかりますが、より精度が高くなることがあります。\tFalse  使用例:  POLY_WRITE_CONVERSION 10 0.5 0.25   SEG_POLY_WRITE_CONVERSION​  現在のコマンドパラメータに区分的多項式変換係数を追加する  この変換係数は、ユーザーが入力した値にバイナリコマンドパケットに書き込まれて送信される前に適用されます。  パラメータ\t説明\t必須Lower Bound\tこの区分的多項式が適用される値の範囲の下限を定義します。最小下限値のセグメントでは無視されます。\tTrue C0\t係数\tTrue Cx\t変換の追加係数値。任意の次数の多項式変換を使用できるため、「x」の値は多項式の次数によって異なります。より高次の多項式は処理に時間がかかりますが、より精度が高くなることがあります。\tFalse  使用例:  SEG_POLY_WRITE_CONVERSION 0 10 0.5 0.25 # Apply the conversion to all values &lt; 50 SEG_POLY_WRITE_CONVERSION 50 11 0.5 0.275 # Apply the conversion to all values &gt;= 50 and &lt; 100 SEG_POLY_WRITE_CONVERSION 100 12 0.5 0.3 # Apply the conversion to all values &gt;= 100   GENERIC_WRITE_CONVERSION_START​  汎用書き込み変換を開始する  現在のコマンドパラメータに汎用変換関数を追加します。 この変換係数は、ユーザーが入力した値にバイナリコマンドパケットに書き込まれて送信される前に適用されます。変換はRubyまたはPythonコードとして指定され、2つの暗黙のパラメータを受け取ります。'value'は書き込まれる生の値であり、'packet'はコマンドパケットクラスへの参照です（注：後方互換性のためにパケットを'myself'として参照することもサポートされています）。コードの最後の行は変換された値を返す必要があります。GENERIC_WRITE_CONVERSION_ENDキーワードは、変換のすべてのコード行が与えられたことを指定します。  コマンドパラメータに対する複数の書き込み変換 コマンドが構築されると、各アイテムがデフォルト値を設定するために書き込まれ（このとき書き込み変換が実行されます）、その後、ユーザーが提供した値でアイテムが書き込まれます（ここでも書き込み変換が実行されます）。したがって、書き込み変換は2回実行される可能性があります。また、どのパラメータがすでに書き込まれたかについての保証はありません。パケット自体には、コマンドにユーザーが提供した値のハッシュを取得するためのgiven_values()メソッドがあります。これを使用して渡されたパラメータ値を確認できます。  警告 汎用変換は長期的な解決策としては適していません。変換クラスを作成してWRITE_CONVERSIONを使用することを検討してください。WRITE_CONVERSIONはデバッグが容易で、パフォーマンスが高いです。  Ruby例:  APPEND_PARAMETER ITEM1 32 UINT 0 0xFFFFFFFF 0 GENERIC_WRITE_CONVERSION_START return (value * 1.5).to_i # Convert the value by a scale factor GENERIC_WRITE_CONVERSION_END   Python例:  APPEND_PARAMETER ITEM1 32 UINT 0 0xFFFFFFFF 0 GENERIC_WRITE_CONVERSION_START return int(value * 1.5) # Convert the value by a scale factor GENERIC_WRITE_CONVERSION_END   GENERIC_WRITE_CONVERSION_END​  汎用書き込み変換を完了する  OVERFLOW​  値を書き込む際に型のオーバーフローが発生した場合の動作を設定する  デフォルトでは、OpenC3は指定された型をオーバーフローする値を書き込もうとするとエラーをスローします（例：8ビット符号付き値に255を書き込む場合）。オーバーフロー動作を設定することで、OpenC3に値を'TRUNCATE'（上位ビットを除外する）させることもできます。また、'SATURATE'を設定することもでき、これによりOpenC3はその型で許容される最大値または最小値に値を置き換えます。最後に、'ERROR_ALLOW_HEX'を指定することもでき、これにより最大16進値を書き込むことが可能になります（例：8ビット符号付き値に255を正常に書き込める）。  パラメータ\t説明\t必須Behavior\tOpenC3がオーバーフロー値をどのように扱うか。符号付きおよび符号なし整数データ型にのみ適用されます。 有効な値: ERROR, ERROR_ALLOW_HEX, TRUNCATE, SATURATE\tTrue  使用例:  OVERFLOW TRUNCATE   HIDDEN​  パラメータがテーブルマネージャーGUIでユーザーに表示されないことを示す  非表示パラメータは依然として存在し、結果のバイナリに保存されます。これはパディングや他の必須だがユーザーが編集できないフィールドに役立ちます。  UNEDITABLE​  パラメータがユーザーに表示されるが編集できないことを示す  編集不可パラメータは、ユーザーが興味を持つかもしれないが編集できるべきではない制御フィールドに役立ちます。  ","version":"次へ","tagName":"h3"},{"title":"APPEND_PARAMETER​","type":1,"pageTitle":"テーブル","url":"/ja/docs/configuration/table#append_parameter","content":" 現在のテーブル内のパラメータを定義する  パラメータ\t説明\t必須Name\tパラメータの名前。テーブル内で一意である必要があります。\tTrue Bit Size\tこのパラメータのビットサイズ。ゼロまたは負の値を使用して、文字列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。Bit Offsetが0でBit Sizeが0の場合、これは派生パラメータであり、Data Typeは'DERIVED'に設定する必要があります。\tTrue Data Type\tこのパラメータのデータ型 有効な値: INT, UINT, FLOAT, DERIVED, STRING, BLOCK\tTrue  Data TypeがINT、UINT、FLOAT、DERIVEDの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Minimum Value\tこのパラメータに許可される最小値\tTrue Maximum Value\tこのパラメータに許可される最大値\tTrue Default Value\tこのパラメータのデフォルト値。デフォルト値を提供する必要がありますが、パラメータをREQUIREDとマークすると、スクリプトは値を指定するよう強制されます。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します。リトルエンディアンビットフィールドのガイドを参照してください。 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  Data TypeがSTRING、BLOCKの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Default Value\tこのパラメータのデフォルト値。デフォルト値を提供する必要がありますが、パラメータをREQUIREDとマークすると、スクリプトは値を指定するよう強制されます。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  ","version":"次へ","tagName":"h3"},{"title":"SELECT_TABLE​","type":1,"pageTitle":"テーブル","url":"/ja/docs/configuration/table#select_table","content":" 既存のテーブルを編集用に選択する、通常は既存の定義をオーバーライドするために行われる  パラメータ\t説明\t必須Table\t既存のテーブルの名前\tTrue  ","version":"次へ","tagName":"h2"},{"title":"DEFAULT​","type":1,"pageTitle":"テーブル","url":"/ja/docs/configuration/table#default","content":" マルチカラムテーブルの単一行のデフォルト値を指定する  複数の行がある場合、各行にDEFAULT行が必要です。すべての行が同一の場合は、OpenC3デモで示されているようにERBの使用を検討してください。  パラメータ\t説明\t必須Default values\tデータ型に対応するSTATE値またはデータ値\tFalse  ","version":"次へ","tagName":"h2"},{"title":"サンプルファイル​","type":1,"pageTitle":"テーブル","url":"/ja/docs/configuration/table#サンプルファイル","content":" サンプルファイル: TARGET/tables/config/MCConfigurationTable_def.txt  TABLE &quot;MC_Configuration&quot; BIG_ENDIAN KEY_VALUE &quot;Memory Control Configuration Table&quot; APPEND_PARAMETER &quot;Scrub_Region_1_Start_Addr&quot; 32 UINT 0 0x03FFFFFB 0 FORMAT_STRING &quot;0x%0X&quot; APPEND_PARAMETER &quot;Scrub_Region_1_End_Addr&quot; 32 UINT 0 0x03FFFFFF 0x03FFFFFF FORMAT_STRING &quot;0x%0X&quot; APPEND_PARAMETER &quot;Scrub_Region_2_Start_Addr&quot; 32 UINT 0 0x03FFFFB 0 FORMAT_STRING &quot;0x%0X&quot; APPEND_PARAMETER &quot;Scrub_Region_2_End_Addr&quot; 32 UINT 0 0x03FFFFF 0x03FFFFF FORMAT_STRING &quot;0x%0X&quot; APPEND_PARAMETER &quot;Dump_Packet_Throttle_(sec)&quot; 32 UINT 0 0x0FFFFFFFF 2 &quot;Number of seconds to wait between dumping large packets&quot; APPEND_PARAMETER &quot;Memory_Scrubbing&quot; 8 UINT 0 1 1 STATE DISABLE 0 STATE ENABLE 1 APPEND_PARAMETER &quot;SIOC_Memory_Config&quot; 8 UINT 1 3 3 APPEND_PARAMETER &quot;Uneditable_Text&quot; 32 UINT MIN MAX 0xDEADBEEF &quot;Uneditable field&quot; FORMAT_STRING &quot;0x%0X&quot; UNEDITABLE APPEND_PARAMETER &quot;Uneditable_State&quot; 16 UINT MIN MAX 0 &quot;Uneditable field&quot; STATE DISABLE 0 STATE ENABLE 1 UNEDITABLE APPEND_PARAMETER &quot;Uneditable_Check&quot; 16 UINT MIN MAX 1 &quot;Uneditable field&quot; STATE UNCHECKED 0 STATE CHECKED 1 UNEDITABLE APPEND_PARAMETER &quot;Binary&quot; 32 STRING 0xDEADBEEF &quot;Binary string&quot; APPEND_PARAMETER &quot;Pad&quot; 16 UINT 0 0 0 HIDDEN  ","version":"次へ","tagName":"h2"},{"title":"インストール","type":0,"sectionRef":"#","url":"/ja/docs/getting-started/installation","content":"","keywords":"","version":"次へ"},{"title":"OpenC3 COSMOSのインストール​","type":1,"pageTitle":"インストール","url":"/ja/docs/getting-started/installation#openc3-cosmosのインストール","content":" 以下のセクションでは、様々なオペレーティングシステムにOpenC3 COSMOSをインストールする方法について説明します。このドキュメントは、ホストマシンのセットアップを行い、すぐにCOSMOSの実行バージョンを使用できるようにするのに役立ちます。  ","version":"次へ","tagName":"h2"},{"title":"ホストマシンへのOpenC3 COSMOSのインストール​","type":1,"pageTitle":"インストール","url":"/ja/docs/getting-started/installation#ホストマシンへのopenc3-cosmosのインストール","content":" ","version":"次へ","tagName":"h2"},{"title":"前提条件​","type":1,"pageTitle":"インストール","url":"/ja/docs/getting-started/installation#前提条件","content":" Linux（本番環境に推奨）をお使いの場合は、Docker Engineのインストールの手順に従ってDockerをインストールすることをお勧めします（LinuxではDocker Desktopを使用しないでください）。注意：Red HatユーザーはPodmanドキュメントをお読みください。WindowsまたはMacを使用している場合は、Docker Desktopをインストールしてください。すべてのプラットフォームでDocker Composeもインストールする必要があります。  Dockerに割り当てる最小リソース: 8GB RAM, 1 CPU, 80GB ディスク Dockerに割り当てる推奨リソース: 16GB RAM, 2+ CPUs, 100GB ディスク WSL2を使用したWindows上のDocker: WSL2はWindows上の合計メモリの50%または8GB（いずれか小さい方）を消費します。ただし、Windows ビルド20175より前のバージョン（確認するにはwinverを使用）では、合計メモリの80%を消費します。これはWindowsのパフォーマンスに悪影響を与える可能性があります！ Windowsビルド &lt; 20175の場合、またはより細かい制御のために、C:\\Users\\&lt;username&gt;\\.wslconfigを作成してください。32GBマシンでの推奨内容: [wsl2] memory=16GB swap=0  重要: Dockerの接続タイムアウトを変更する Dockerはデフォルトで、5分間のアイドル（データなし）接続を切断します。この「機能」は、Docker設定を調整しないと、最終的に問題を引き起こす可能性があります。これは、アイドル接続が切断されたり、データが再び流れ始めた後に再開できないことなどの形で現れることがあります。WindowsではC:\\Users\\username\\AppData\\Roaming\\Docker\\settings.jsonにあるファイルを、MacOSでは~/Library/Group Containers/group.com.docker/settings.jsonを見つけてください。タイムアウトを変更するにはvpnKitMaxPortIdleTimeの値を変更します（0に設定することをお勧めします）。注意: 0はタイムアウトなし（アイドル接続が切断されない）を意味します  注意: 2021年12月現在、COSMOS Dockerコンテナは Alpine Dockerイメージをベースにしています。  ","version":"次へ","tagName":"h3"},{"title":"プロジェクトのクローン​","type":1,"pageTitle":"インストール","url":"/ja/docs/getting-started/installation#プロジェクトのクローン","content":" 始めるには、COSMOS プロジェクトテンプレートを使用することをお勧めします。  git clone https://github.com/OpenC3/cosmos-project.git git clone https://github.com/OpenC3/cosmos-enterprise-project.git   オフラインインストール オフライン環境にインストールする必要がある場合は、まずCOSMOSコンテナを直接使用できるかどうかを確認してください。もし可能であれば、まずコンテナを保存できます： ./openc3.sh util save docker.io openc3inc 6.3.0 これにより、openc3incネームスペースとバージョン5.16.2を使用して、docker.ioリポジトリからCOSMOSコンテナがダウンロードされます。リポジトリ、ネームスペース、バージョンはすべて設定可能です。tarファイルは「tmp」ディレクトリに作成され、オフライン環境に転送できます。tarファイルをオフライン環境のプロジェクトの「tmp」ディレクトリに転送し、以下のコマンドでインポートします： ./openc3.sh util load 6.3.0 saveで指定したバージョンは、loadで指定するバージョンと一致する必要があることに注意してください。  ","version":"次へ","tagName":"h3"},{"title":"証明書​","type":1,"pageTitle":"インストール","url":"/ja/docs/getting-started/installation#証明書","content":" COSMOSコンテナは、SSL復号化デバイスの存在下で動作し、構築されるように設計されています。これをサポートするため、組織が必要とする証明書を含むcacert.pemファイルをCOSMOS 6プロジェクトのベースに配置できます。注意：SSL_CERT_FILE環境変数にSSLファイルへのパスを設定すると、openc3セットアップスクリプトがそれをコピーして、Dockerコンテナがロードするために配置します。  SSL問題 組織ではますますSSL復号化デバイスのようなものを使用するようになっており、これによりcurlやgitなどの他のコマンドラインツールでSSL証明書の問題が発生する可能性があります。インストールが「certificate」「SSL」「self-signed」または「secure」に関するメッセージで失敗した場合、これが問題です。ITは通常、ブラウザが正しく動作するように設定しますが、コマンドラインアプリケーションは設定しません。ファイル拡張子は.pemではない可能性があり、.pem、.crt、.ca-bundle、.cer、.p7b、.p7sなど、他の拡張子の可能性もあります。 回避策は、curlなどのツールで使用できるIT部門から適切なローカル証明書ファイルを取得することです（例：C:\\Shared\\Ball.pem）。スペースがない場所であればどこでも構いません。 その後、次の環境変数をそのパスに設定します（例：C:\\Shared\\Ball.pem） SSL_CERT_FILE CURL_CA_BUNDLE REQUESTS_CA_BUNDLE Windowsの環境変数に関するいくつかの指示はこちらです：Windows環境変数 上記の名前で新しい環境変数を作成し、その値を証明書ファイルへのフルパスに設定する必要があります。  ","version":"次へ","tagName":"h3"},{"title":"実行​","type":1,"pageTitle":"インストール","url":"/ja/docs/getting-started/installation#実行","content":" ローカルにクローンしたプロジェクトディレクトリをパスに追加して、バッチファイルまたはシェルスクリプトを直接使用できるようにします。Windowsでは、&quot;C:\\openc3-project&quot;をPATHに追加します。Linuxでは、シェルのrcファイルを編集してPATHをエクスポートします。例えば、Macでは次の行を~/.zshrcに追加します：export PATH=~/cosmos-project:$PATH。  openc3.bat run（Windows）または./openc3.sh run（Linux/Mac）を実行します。  注意、.envファイルを編集して、OPENC3_TAGを「latest」ではなく特定のリリース（例：6.3.0）に変更できます。  Dockerデーモンが実行されていないというエラーが表示された場合は、DockerとDocker Composeがインストールされ、実行されていることを確認してください。エラーが発生した場合は、docker --versionまたはdocker-compose --versionを実行してみて、再度開始コマンドを実行してみてください。エラーが続く場合は、問題を作成する場合は、バージョンを問題に含めてください。  docker psを実行すると、実行中のコンテナを表示できます。  openc3.*は複数の引数を取ります。引数なしで実行するとヘルプが表示されます。openc3.shを引数なしで実行すると、以下のような使用ガイドが表示されます。  ./openc3.sh Usage: ./openc3.sh [cli, cliroot, start, stop, cleanup, run, util] * cli: デフォルトユーザーとしてcliコマンドを実行（詳細は'cli help'） * cliroot: ルートユーザーとしてcliコマンドを実行（詳細は'cli help'） * start: docker-compose openc3を開始 * stop: 実行中のopenc3用Dockerを停止 * cleanup: openc3のネットワークとボリュームをクリーンアップ * run: openc3用のプリビルドコンテナを実行 * util: さまざまなヘルパーコマンド   ","version":"次へ","tagName":"h3"},{"title":"接続​","type":1,"pageTitle":"インストール","url":"/ja/docs/getting-started/installation#接続","content":" Webブラウザで http://localhost:2900 に接続します。パスワードは好きなものに設定してください。  ","version":"次へ","tagName":"h3"},{"title":"次のステップ​","type":1,"pageTitle":"インストール","url":"/ja/docs/getting-started/installation#次のステップ","content":" はじめにに進みます。    ","version":"次へ","tagName":"h3"},{"title":"フィードバック​","type":1,"pageTitle":"インストール","url":"/ja/docs/getting-started/installation#フィードバック","content":" ドキュメントに問題がありましたか？ GitHubで課題を作成して、 改善方法を教えてください。 ","version":"次へ","tagName":"h3"},{"title":"OpenC3 COSMOS 主要概念","type":0,"sectionRef":"#","url":"/ja/docs/getting-started/key-concepts","content":"","keywords":"","version":"次へ"},{"title":"プロジェクト​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#プロジェクト","content":" メインのCOSMOS リポジトリには、COSMOSをビルドして実行するために使用されるすべてのソースコードが含まれています。ただし、COSMOS のユーザー（ソフトウェア開発者ではない）は、COSMOS を起動するために COSMOS プロジェクトを使用するのを勧めます。プロジェクトは、COSMOS の起動と停止のためのopenc3.shとopenc3.batファイル、COSMOS コンテナの設定のためのcompose.yaml、そしてランタイム変数を設定するための.envファイルで構成されています。さらに、COSMOSプロジェクトには、RedisとTraefikの両方のためのユーザー修正可能な設定ファイルが含まれています。  ","version":"次へ","tagName":"h2"},{"title":"コンテナ化​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#コンテナ化","content":" ","version":"次へ","tagName":"h2"},{"title":"イメージ​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#イメージ","content":" Dockerによれば、「イメージは、Dockerコンテナを作成するための指示を含む読み取り専用のテンプレート」です。COSMOSが使用する基本オペレーティングシステムはAlpine Linuxと呼ばれています。これは依存関係をインストールできる完全なパッケージシステムを備えたシンプルでコンパクトなイメージです。Alpineをベースに、RubyとPythonといくつかの他のパッケージを追加するためのDockerfileを作成して、独自のDockerイメージを作成します。さらに、そのイメージを元にして、フロントエンドをサポートするNodeJSイメージと、バックエンドをサポートする追加イメージを構築しています。  ","version":"次へ","tagName":"h3"},{"title":"コンテナ​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#コンテナ","content":" Dockerによれば、「コンテナは、コードとそのすべての依存関係をパッケージ化するソフトウェアの標準単位であり、アプリケーションがあるコンピューティング環境から別の環境へ迅速かつ確実に実行されるようにするもの」です。また、Dockerは、「コンテナはコードのための独立した環境です。これは、コンテナがあなたのオペレーティングシステムやファイルについての知識を持たないことを意味します。Docker Desktopによって提供される環境で実行されます。コンテナには、ベースとなるオペレーティングシステムまで、コードを実行するために必要なすべてのものが含まれています」とも述べています。COSMOSはコンテナを利用して一貫したランタイム環境を提供しています。コンテナにより、ローカルのオンプレミスサーバー、クラウド環境、またはエアギャップネットワークへの展開が容易になります。  COSMOS オープンソースのコンテナは以下で構成されています：  名前\t説明cosmos-openc3-cosmos-init-1\tファイルをMinioにコピーしてCOSMOSを設定し、その後終了します cosmos-openc3-operator-1\tインターフェイスとターゲットマイクロサービスを実行するメインのCOSMOSコンテナ cosmos-openc3-cosmos-cmd-tlm-api-1\tすべてのCOSMOS APIエンドポイントを提供するRailsサーバー cosmos-openc3-cosmos-script-runner-api-1\tスクリプトAPIエンドポイントを提供するRailsサーバー cosmos-openc3-redis-1\t静的ターゲット設定を提供します cosmos-openc3-redis-ephemeral-1\t生データと復調されたデータを含むストリームを提供します cosmos-openc3-minio-1\tS3のようなバケットストレージインターフェイスを提供し、ツールファイル用の静的ウェブサーバーとしても機能します cosmos-openc3-traefik-1\tCOSMOSエンドポイントへのルートを持つリバースプロキシとロードバランサーを提供します  Enterprise COSMOSのコンテナリストは以下で構成されています：  名前\t説明cosmos-enterprise-openc3-metrics-1\tCOSMOSのパフォーマンスに関するメトリクスを提供するRailsサーバー cosmos-enterprise-openc3-keycloak-1\t認証のためのシングルサインオンサービス cosmos-enterprise-openc3-postgresql-1\tKeycloakが使用するSQLデータベース openc3-nfs *\tコンテナ間でコードライブラリを共有するためにKubernetesでのみ使用するネットワークファイルシステムポッド  ","version":"次へ","tagName":"h3"},{"title":"Docker Compose​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#docker-compose","content":" Dockerによれば、「Composeは、マルチコンテナDockerアプリケーションを定義して実行するためのツールです。Composeでは、YAMLファイルを使用してアプリケーションのサービスを設定します。その後、1つのコマンドで設定からすべてのサービスを作成して起動します」。OpenC3は、COSMOSの構築と実行の両方にComposeファイルを使用しています。compose.yamlは、ポートが公開され、環境変数が使用される場所です。  ","version":"次へ","tagName":"h3"},{"title":"環境ファイル​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#環境ファイル","content":" COSMOSは、Docker Composeとともに環境ファイルを使用して、環境変数をCOSMOSランタイムに渡します。この.envファイルは、デプロイされたCOSMOSのバージョン、ユーザー名とパスワード、その他多くの情報を含む単純なキーと値のペアで構成されています。  ","version":"次へ","tagName":"h3"},{"title":"Kubernetes​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#kubernetes","content":" Kubernetes.ioによれば、「Kubernetes（K8sとも呼ばれる）は、コンテナ化されたアプリケーションのデプロイメント、スケーリング、管理を自動化するためのオープンソースシステムです。アプリケーションを構成するコンテナを論理的なユニットにグループ化して、管理と発見を容易にします」。COSMOS Enterpriseは、様々なクラウド環境へのKubernetesへの簡単なデプロイメントのためのHelmチャートを提供しています。  COSMOS Enterpriseはまた、様々なクラウド環境（例：AWSのCloudFormationテンプレート）にCOSMOSインフラストラクチャをデプロイするための設定も提供しています。  ","version":"次へ","tagName":"h3"},{"title":"フロントエンド​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#フロントエンド","content":" ","version":"次へ","tagName":"h2"},{"title":"Vue.js​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#vuejs","content":" COSMOSフロントエンドは完全にブラウザネイティブであり、Vue.jsフレームワークで実装されています。Vue.jsによれば、「Vueはユーザーインターフェイスを構築するためのJavaScriptフレームワークです。標準的なHTML、CSS、JavaScriptの上に構築され、シンプルであれ複雑であれ、ユーザーインターフェイスを効率的に開発するのに役立つ宣言的でコンポーネントベースのプログラミングモデルを提供します」。COSMOSはVue.jsとVuetifyコンポーネントフレームワークUIライブラリを利用して、お好みのブラウザで実行されるすべてのCOSMOSツールを構築しています。COSMOS 5はVue.js 2.xとVuetify 2.xを使用していましたが、COSMOS 6はVue.js 3.xとVuetify 3.xを使用しています。  ","version":"次へ","tagName":"h3"},{"title":"Single-Spa​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#single-spa","content":" COSMOS自体はVue.jsで書かれていますが、COSMOS開発者が選択した任意のJavaScriptフレームワークでアプリケーションを作成できるように、single-spaと呼ばれる技術を利用しています。Single-spaはマイクロフロントエンドフレームワークであり、要求されたアプリケーションをレンダリングするトップレベルのルーターとして機能します。COSMOSは、Angular、React、Svelte、Vueですぐにsingle-spaに接続できるサンプルアプリケーションを提供しています。  ","version":"次へ","tagName":"h3"},{"title":"Astro UX​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#astro-ux","content":" AstroUXDSによれば、「Astro Space UX Design Systemは、開発者やデザイナーが確立されたインタラクションパターンとベストプラクティスを使用して、豊かな宇宙アプリケーション体験を構築できるようにします」。COSMOSは、色、タイポグラフィ、アイコングラフィのためにAstroデザインガイドラインを利用しています。場合によっては、例えばAstro Clockのように、COSMOSは直接Astroコンポーネントを組み込んでいます。  ","version":"次へ","tagName":"h3"},{"title":"バックエンド​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#バックエンド","content":" ","version":"次へ","tagName":"h2"},{"title":"Redis​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#redis","content":" Redisは、文字列、ハッシュ、リスト、セット、ソート済みセット、ストリームなどをサポートするインメモリデータストアです。COSMOSはRedisを使用して設定とデータの両方を保存します。コンテナリストを振り返ると、2つのRedisコンテナがあることに気づくでしょう：cosmos-openc3-redis-1とcosmos-openc3-redis-ephemeral-1です。一時的なコンテナには、Redisストリームにプッシュされるすべてのリアルタイムデータが含まれています。もう一つのRedisコンテナには、永続化されることを意図したCOSMOS設定が含まれています。COSMOS Enterpriseは、データが複数のRedisノード間で共有される水平スケーリングを実行するためのRedisクラスターをセットアップするHelmチャートを提供しています。  ","version":"次へ","tagName":"h3"},{"title":"MinIO​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#minio","content":" MinIOは、高性能でS3互換のオブジェクトストアです。COSMOSはこのストレージ技術を使用して、COSMOSツール自体と長期的なログファイルの両方をホストしています。クラウド環境にデプロイされたCOSMOS Enterpriseは、利用可能なクラウドネイティブのバケットストレージ技術（AWS S3、GCPバケット、Azure Blobストレージなど）を使用します。バケットストレージを使用することで、COSMOSは静的ウェブサイトとしてツールを直接提供できるため、例えばTomcatやNginxをデプロイする必要がありません。  ","version":"次へ","tagName":"h3"},{"title":"Ruby on Rails​","type":1,"pageTitle":"OpenC3 COSMOS 主要概念","url":"/ja/docs/getting-started/key-concepts#ruby-on-rails","content":" COSMOS APIとScript Runnerのバックエンドは、Ruby on Railsによって動作しています。Railsは、Rubyプログラミング言語で書かれたWebアプリケーション開発フレームワークです。Railsにより、他の多くの言語やフレームワークよりも少ないコードで多くのことを達成できます。 ","version":"次へ","tagName":"h3"},{"title":"Podman","type":0,"sectionRef":"#","url":"/ja/docs/getting-started/podman","content":"","keywords":"","version":"次へ"},{"title":"ルートレスPodmanとDocker-Composeを使用したOpenC3 COSMOS​","type":1,"pageTitle":"Podman","url":"/ja/docs/getting-started/podman#ルートレスpodmanとdocker-composeを使用したopenc3-cosmos","content":" Podmanのインストール方法 これらの手順は、DockerではなくPodmanを使用してCOSMOSをインストールおよび実行するためのものです。Dockerが利用可能な場合は、そちらの方がより簡単な方法です。  PodmanはDockerの代替となるコンテナ技術で、RedHatによって積極的に推進されています。主な利点は、Podmanがルートレベルのデーモンサービスなしで実行できることであり、標準的なDockerと比較して設計上、大幅にセキュリティが向上します。ただし、使用するのは少し複雑です。以下の手順でPodmanを使って環境を構築できます。これらの手順はRHEL 8.8およびRHEL 9.2でテストされていますが、他のオペレーティングシステムでも同様の手順になるはずです。  ルートレスPodmanはNFSホームディレクトリでは直接動作しません NFSは、ユーザーIDとグループIDの問題により、コンテナストレージの保持に使用できません。回避策はありますが、いずれもコンテナストレージを別の場所に移動する必要があります（ホストのローカルディスク上の異なるパーティション、または特別にマウントされたディスクイメージのいずれかです）。 参照：https://www.redhat.com/sysadmin/rootless-podman-nfs。 また、/etc/containers/storage.confにあるrootless_storage_pathという設定を使って、ストレージの場所をより簡単に変更できるPodmanの新しい設定もあります。参照：https://www.redhat.com/sysadmin/nfs-rootless-podman  Redhat 8.8と9.2の手順  前提条件パッケージのインストール 注：これはGithubの最新の2.x リリースからdocker-composeをダウンロードしてインストールします。オペレーティングシステムにdocker-composeパッケージがある場合は、それを使用してインストールする方が簡単です。RHEL8にはdocker-composeパッケージがありません。 sudo yum update sudo yum install git podman-docker netavark curl -SL https://github.com/docker/compose/releases/download/v2.16.0/docker-compose-linux-x86_64 -o docker-compose sudo mv docker-compose /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose RedisのためのホストOSの設定 sudo su echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag sysctl -w vm.max_map_count=262144 exit DNS用のNetavarkを使用するようにPodmanを設定 sudo cp /usr/share/containers/containers.conf /etc/containers/. sudo vi /etc/containers/containers.conf 次に、network_backendの行を「cni」から「netavark」に編集します ルートレスpodmanソケットサービスの開始 systemctl enable --now --user podman.socket 以下を.bashrcファイル（または.bash_profileなど）に追加 export DOCKER_HOST=&quot;unix://$XDG_RUNTIME_DIR/podman/podman.sock&quot; 現在のターミナルでプロファイルファイルを読み込む source .bashrc COSMOSの取得 - リリースまたは現在のmainブランチ（mainブランチを表示） git clone https://github.com/OpenC3/cosmos.git オプション - デフォルトコンテナレジストリの設定 どのレジストリを使用するかをpodmanに問い合わせないようにするには、$HOME/.config/containers/registries.confを作成し、メインのdockerレジストリのみを持つように変更します（または/etc/containers/registries.confファイルを直接変更します） mkdir -p $HOME/.config/containers cp /etc/containers/registries.conf $HOME/.config/containers/. vi $HOME/.config/containers/registries.conf 次に、unqualified-search-registries =の行を編集して、必要なレジストリ（おそらくdocker.io）のみを含めるようにします cosmos/compose.yamlの編集 cd cosmos vi compose.yaml compose.yamlを編集し、user: 0:0の行のコメントを解除し、user: &quot;${OPENC3_USER_ID}:${OPENC3_GROUP_ID}&quot;の行をコメントアウトします。 また、traefik設定を更新してインターネットからのアクセスを許可するために、127.0.0.1を削除し、おそらくSSL設定ファイルまたはhttp許可設定に切り替えることもできます。また、選択したポートへのアクセスをファイアウォールが許可していることを確認してください。ルートレスpodmanでは、より高い番号のポート（1-1023以外）を使用する必要があります。 COSMOSの実行 ./openc3.sh run すべてが構築され、実行されるまで待ってから、ブラウザで http://localhost:2900 にアクセスします  MacOSでのPodman PodmanはMacOSでも使用できますが、一般的にはDocker Desktopをお勧めします  ","version":"次へ","tagName":"h3"},{"title":"MacOSの手順​","type":1,"pageTitle":"Podman","url":"/ja/docs/getting-started/podman#macosの手順","content":" Podmanのインストール brew install podman Podman仮想マシンの開始 podman machine init podman machine start # 注意：次の行でユーザー名を更新するか、'podman machine start'の出力からコピーペーストしてください export DOCKER_HOST='unix:///Users/ryanmelt/.local/share/containers/podman/machine/qemu/podman.sock' docker-composeのインストール brew install docker-compose # Docker Desktopがすでにある場合は必要無し cosmos/compose.yamlの編集 compose.yamlを編集し、user: 0:0の行のコメントを解除し、user: &quot;${OPENC3_USER_ID}:${OPENC3_GROUP_ID}&quot;の行をコメントアウトします。 重要：MacOSでは、ボリュームマウント行からすべての:zを削除する必要もあります また、インターネットからのアクセスを許可するためにtraefik設定を更新することもできます。 COSMOSの実行 cd cosmos ./openc3.sh run  ","version":"次へ","tagName":"h2"},{"title":"ブリッジ","type":0,"sectionRef":"#","url":"/ja/docs/guides/bridges","content":"","keywords":"","version":"次へ"},{"title":"ブリッジは基本的にインターフェースとルーターのみで構成されています​","type":1,"pageTitle":"ブリッジ","url":"/ja/docs/guides/bridges#ブリッジは基本的にインターフェースとルーターのみで構成されています","content":" ブリッジは一般的に、ホスト接続デバイスからデータを取得するCOSMOS Interfaceクラスと、そのデータをTCP/IP経由でCOSMOSに転送するRouterで構成されています。 ほとんどの場合、BURSTプロトコルを使用してデータを安全にCOSMOSに送信し、COSMOS側でLENGTHなどの適切なパケット区切りプロトコルを使用できます。  ","version":"次へ","tagName":"h2"},{"title":"ブリッジを実行するためのホスト要件​","type":1,"pageTitle":"ブリッジ","url":"/ja/docs/guides/bridges#ブリッジを実行するためのホスト要件","content":" ホストRubyインストールが必要（Ruby 3）OpenC3 gemのインストール gem install openc3 Rubyのgem実行可能パスがPATH環境変数に含まれていることを確認 このパスはgem environmentを実行し、EXECUTABLE DIRECTORYを確認することで見つけられます 成功した場合、ターミナルからopenc3cliを実行できるはずです  ","version":"次へ","tagName":"h2"},{"title":"ブリッジ設定: bridge.txt​","type":1,"pageTitle":"ブリッジ","url":"/ja/docs/guides/bridges#ブリッジ設定-bridgetxt","content":" ブリッジはbridge.txtという名前の設定ファイルを使用して実行されます。このファイルはplugin.txt設定構文のサブセットで、VARIABLE、INTERFACE、ROUTER、および関連する修飾キーワードをサポートしています。ただし、ブリッジはターゲットの知識を持ちません。そのため、MAP_TARGETSの代わりに、INTERFACEはROUTEキーワードを使用してROUTERに関連付けられます。  以下は、openc3cli bridgesetupを実行することで生成されるデフォルトのbridge.txtです。  # 書き込みシリアルポート名 VARIABLE write_port_name COM1 # 読み取りシリアルポート名 VARIABLE read_port_name COM1 # ボーレート VARIABLE baud_rate 115200 # パリティ - NONE、ODD、またはEVEN VARIABLE parity NONE # ストップビット - 0、1、または2 VARIABLE stop_bits 1 # 書き込みタイムアウト VARIABLE write_timeout 10.0 # 読み取りタイムアウト VARIABLE read_timeout nil # フロー制御 - NONE、またはRTSCTS VARIABLE flow_control NONE # ワードあたりのデータビット - 通常は8 VARIABLE data_bits 8 # COSMOSからの接続をリッスンするポート - プラグインと一致する必要があります VARIABLE router_port 2950 # COSMOSからの接続をリッスンするポート。セキュリティのためにデフォルトではlocalhostです。COSMOSが別のマシンにある場合は、 # 開放する必要があります。 VARIABLE router_listen_address 127.0.0.1 INTERFACE SERIAL_INT serial_interface.rb &lt;%= write_port_name %&gt; &lt;%= read_port_name %&gt; &lt;%= baud_rate %&gt; &lt;%= parity %&gt; &lt;%= stop_bits %&gt; &lt;%= write_timeout %&gt; &lt;%= read_timeout %&gt; OPTION FLOW_CONTROL &lt;%= flow_control %&gt; OPTION DATA_BITS &lt;%= data_bits %&gt; ROUTER SERIAL_ROUTER tcpip_server_interface.rb &lt;%= router_port %&gt; &lt;%= router_port %&gt; 10.0 nil BURST ROUTE SERIAL_INT OPTION LISTEN_ADDRESS &lt;%= router_listen_address %&gt;   VARIABLEは、ブリッジ起動時に変更できる変数のデフォルト値を提供します。この例では、serial_interface.rbクラスを使用するように設定されたINTERFACEを示しています。また、COSMOSが接続してシリアルポートからデータを取得できるtcpip_server_interface.rbを使用する標準的なROUTERも含まれています。この例ではLISTEN_ADDRESSが127.0.0.1に設定されており、ホストシステム外からのアクセスを防止しています。同じマシン上で実行されているDockerは、host.docker.internalホスト名と設定されたポート（この例では2950）を使用してこのサーバーにアクセスできます。  ","version":"次へ","tagName":"h2"},{"title":"ブリッジコマンド: openc3cli​","type":1,"pageTitle":"ブリッジ","url":"/ja/docs/guides/bridges#ブリッジコマンド-openc3cli","content":" openc3cli bridgesetup  bridge.txtの例ファイルを生成します  openc3cli bridge [filename] [variable1=value1] [variable2=value2]  指定された設定ファイルからブリッジを実行します。デフォルトでは現在のディレクトリのbridge.txtを使用します。VARIABLEのデフォルト値を上書きするために変数を渡すこともできます。  openc3cli bridgegem [gem_name] [variable1=value1] [variable2=value2]  ブリッジgemで提供されるbridge.txtを使用してブリッジを実行します。VARIABLEのデフォルト値を上書きするために変数を渡すこともできます。  ","version":"次へ","tagName":"h2"},{"title":"ブリッジGemの例​","type":1,"pageTitle":"ブリッジ","url":"/ja/docs/guides/bridges#ブリッジgemの例","content":" シリアルポート: openc3-cosmos-bridge-serialホスト: openc3-cosmos-bridge-hostHIDAPI: openc3-cosmos-bridge-hidapiPS5 Dual Senseコントローラ: openc3-cosmos-bridge-dualsense  ","version":"次へ","tagName":"h2"},{"title":"シリアルポートに関する注意​","type":1,"pageTitle":"ブリッジ","url":"/ja/docs/guides/bridges#シリアルポートに関する注意","content":" Linux Dockerインストールでは、ブリッジを使わずに直接シリアルポートを使用できます。  compose.yamlのoperatorサービスに以下を追加します：   devices: - &quot;/dev/ttyUSB0:/dev/ttyUSB0&quot;   シリアルデバイスに、Dockerを実行しているユーザーがアクセスするための権限があることを確認してください：  sudo chmod 666 /dev/ttyUSB0  ","version":"次へ","tagName":"h2"},{"title":"はじめに","type":0,"sectionRef":"#","url":"/ja/docs/getting-started/gettingstarted","content":"","keywords":"","version":"次へ"},{"title":"ハードウェアとのインターフェース​","type":1,"pageTitle":"はじめに","url":"/ja/docs/getting-started/gettingstarted#ハードウェアとのインターフェース","content":" COSMOSデモで遊ぶのは楽しいですが、ここからは実際のハードウェアと通信したいですよね？さっそくやってみましょう！  インストールとプラットフォーム このガイドでは、WindowsでCOSMOSがC:\\COSMOSにインストールされていることを前提としています。MacまたはLinuxでは、openc3.batをopenc3.shに変更し、インストールディレクトリに合わせて必要に応じてパスを調整してください。  独自の設定を作成する前に、COSMOSデモをアンインストールして、クリーンなCOSMOSシステムで作業するようにしましょう。Adminボタンをクリックし、PLUGINSタブをクリックします。次に、openc3-cosmos-demoの横にあるゴミ箱アイコンをクリックして削除します。コマンド＆テレメトリサーバーに戻ると、インターフェースのない空のテーブルが表示されるはずです。 インストールガイドに従った場合、すでにクローンしたopenc3-project内にいるはずです。これはパス（PATH）に含まれており、openc3.bat / openc3.shが解決されるために必要です。このプロジェクト内では、README.md（Markdown）を編集して、プログラムやプロジェクトについて説明することをお勧めします。 次に、プラグインを作成する必要があります。プラグインは、ターゲットとマイクロサービスをCOSMOSに追加する方法です。プラグインには、ターゲットと通信するために必要なパケット（コマンドとテレメトリ）を定義するすべての情報を含む単一のターゲットが含まれます。COSMOSプラグインジェネレーターを使用して、正しい構造を作成しましょう。  PythonとRuby 各CLIコマンドでは、OPENC3_LANGUAGE環境変数を'python'または'ruby'に設定していない限り、--pythonまたは--rubyの使用が必要です。  C:\\openc3-project&gt; openc3.bat cli generate plugin BOB --python Plugin openc3-cosmos-bob successfully generated!   これにより、「openc3-cosmos-bob」という新しいディレクトリが作成され、多くのファイルが含まれるはずです。すべてのファイルの詳細な説明は、プラグインジェネレーターページで説明されています。  ルートユーザーとして実行する CLIはデフォルトのCOSMOSコンテナユーザーとして実行されます。これが推奨される方法です。そのユーザーとして実行する際に問題がある場合は、例のいずれかでcliの代わりにclirootを実行することで、ルートユーザーとして実行できます（実質的にdocker run --user=rootと同じ）。  COSMOS v5.5.0以降では、プラグインジェネレーターはプラグインフレームワークのみを作成します（以前はターゲットも作成していました）。新しく作成されたプラグインディレクトリ内から、ターゲットを生成します。 C:\\openc3-project&gt; cd openc3-cosmos-bob openc3-cosmos-bob&gt; openc3.bat cli generate target BOB --python Target BOB successfully generated!   ジェネレーター 利用可能なジェネレーターがいくつかあります。openc3.bat cli generateを実行して、利用可能なすべてのオプションを確認してください。  ターゲットジェネレーターは、BOBという名前の単一のターゲットを作成します。ベストプラクティスは、プラグインごとに単一のターゲットを作成することで、ターゲットの共有と個別のアップグレードが容易になります。ターゲットジェネレーターが何を作成したのか見てみましょう。openc3-cosmos-bob/targets/BOB/cmd_tlm/cmd.txtを開きます： COMMAND BOB EXAMPLE BIG_ENDIAN &quot;Packet description&quot; # Keyword Name BitSize Type Min Max Default Description APPEND_ID_PARAMETER ID 16 INT 1 1 1 &quot;Identifier&quot; APPEND_PARAMETER VALUE 32 FLOAT 0 10.5 2.5 &quot;Value&quot; APPEND_PARAMETER BOOL 8 UINT MIN MAX 0 &quot;Boolean&quot; STATE FALSE 0 STATE TRUE 1 APPEND_PARAMETER LABEL 0 STRING &quot;OpenC3&quot; &quot;The label to apply&quot; これはどういう意味でしょうか？ ターゲットBOBに対して、EXAMPLEという名前のCOMMAND（コマンド）を作成しました。このコマンドはBIG_ENDIANパラメータで構成され、「Packet description」（パケットの説明）という説明がついています。ここでは、パラメータを定義するためにappend（追加）形式を使用しています。これは、パケットを構築する際にパラメータを連続して配置するため、パケット内のビットオフセットを定義する心配がありません。最初にAPPEND_ID_PARAMETERで、パケットを識別するために使用される「ID」というパラメータを追加しています。これは16ビット符号付き整数（INT）で、最小値は1、最大値は1、デフォルト値は1で、「Identifier」（識別子）と説明されています。次にAPPEND_PARAMETERで、「VALUE」という名前のパラメータを追加しています。これは32ビット浮動小数点数（FLOAT）で、最小値は0、最大値は10.5、デフォルト値は2.5です。次にAPPEND_PARAMETERで、3番目のパラメータ「BOOL」を追加しています。これは8ビット符号なし整数（UINT）で、最小値はMIN（UINTがサポートする最小値、例えば0を意味）、最大値はMAX（UINTがサポートする最大値、例えば255）、デフォルト値は0です。BOOLには2つの状態があり、これは整数値0と1に意味を持たせる方法です。状態FALSEは値0、状態TRUEは値1を持ちます。最後にAPPEND_PARAMETERで、「LABEL」というパラメータを追加しています。これは0ビット（パケット内の残りのすべてのスペースを占めることを意味）の文字列（STRING）で、デフォルト値は「OpenC3」です。文字列（STRING）には最小値や最大値はありません。 詳細については、完全なCommandドキュメントをご覧ください。 次に、openc3-cosmos-bob/targets/BOB/cmd_tlm/tlm.txtを開きます： TELEMETRY BOB STATUS BIG_ENDIAN &quot;Telemetry description&quot; # Keyword Name BitSize Type ID Description APPEND_ID_ITEM ID 16 INT 1 &quot;Identifier&quot; APPEND_ITEM VALUE 32 FLOAT &quot;Value&quot; APPEND_ITEM BOOL 8 UINT &quot;Boolean&quot; STATE FALSE 0 STATE TRUE 1 APPEND_ITEM LABEL 0 STRING &quot;The label to apply&quot; 今回は、ターゲットBOB用の「STATUS」という名前のTELEMETRY（テレメトリ）パケットを作成しました。このパケットはBIG_ENDIANアイテムを含み、「Telemetry description」（テレメトリの説明）という説明がついています。まず、「ID」というID_ITEMを定義しています。これは16ビット符号付き整数（INT）で、ID値は1、説明は「Identifier」（識別子）です。IDアイテムは、未識別のバイトの塊（blob）を取り、それがどのパケットであるかを判断するために使用されます。この場合、値1のblobがビットオフセット0（このアイテムを最初にAPPENDするため）で入ってきた場合、16ビット整数として解釈され、このパケットは「STATUS」として「識別」されます。ID_ITEMなしで定義された最初のパケットは、すべての受信データに一致する「キャッチオール」パケットであることに注意してください（データの長さが一致しない場合でも）。次に、上記のコマンド定義と同様の3つのアイテムを定義します。 詳細については、完全なTelemetryドキュメントをご覧ください。 COSMOSは、ターゲット用のサンプルコマンドとテレメトリパケットを定義しました。ほとんどのターゲットは複数のコマンドとテレメトリパケットを持ちます。さらに追加するには、テキストファイルに追加のCOMMANDとTELEMETRY行を作成するだけです。実際のパケットは、コマンドとテレメトリの構造と一致する必要があります。パケットを互いに区別できるように、少なくとも1つの固有のID_PARAMETERとID_ITEMを追加してください。 次に、COSMOSにBOBターゲットへの接続方法を伝える必要があります。openc3-cosmos-bob/plugin.txtファイルを開きます： # Set VARIABLEs here to allow variation in your plugin # See [Plugins](../configuration/plugins) for more information VARIABLE bob_target_name BOB # Modify this according to your actual target connection # See [Interfaces](../configuration/interfaces) for more information TARGET BOB &lt;%= bob_target_name %&gt; INTERFACE &lt;%= bob_target_name %&gt;_INT openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8081 10.0 None BURST MAP_TARGET &lt;%= bob_target_name %&gt; これにより、デフォルト値が「BOB」のbob_target_nameというVARIABLEを持つプラグインが設定されます。このプラグインをインストールする際に、このターゲットの名前を「BOB」以外のものに変更することができます。これは名前の競合を避け、COSMOSシステム内にBOBターゲットの複数のコピーを持つことができるため便利です。TARGETラインは、変数から名前を使用して新しいBOBターゲットを宣言します。&lt;%= %&gt;構文はERB（Embedded (埋め込み) Ruby）と呼ばれ、テキストファイルに変数を入れることができます。この場合、bob_target_nameを参照しています。最後の行は、（デフォルトで）BOB_INTと呼ばれる新しいINTERFACEを宣言します。これはTCP/IPクライアントとして接続し、tcpip_client_interface.pyのコードを使用してhost.docker.internal（これはホストのゲートウェイに対する正しいIPアドレスに/etc/hostsエントリを追加します）に接続します。書き込みにはポート8080、読み取りにはポート8081を使用します。また、書き込みタイムアウトは10秒で、読み取りはタイムアウトしません（None）。TCP/IPストリームはCOSMOS BURSTプロトコルを使用して解釈され、これはインターフェースからできるだけ多くのデータを読み取ることを意味します。COSMOSインターフェースの設定方法の詳細については、インターフェースガイドをご覧ください。MAP_TARGETラインは、COSMOSがBOB_INTインターフェースを使用してBOBターゲットからテレメトリを受信し、コマンドを送信することを示しています。  変数は再利用性をサポートします 再利用する予定のプラグインでは、ホスト名やポートなどを変数にするのを推奨します  ","version":"次へ","tagName":"h2"},{"title":"プラグインの構築​","type":1,"pageTitle":"はじめに","url":"/ja/docs/getting-started/gettingstarted#building-your-plugin","content":" 次に、プラグインを構築してCOSMOSにアップロードします。 openc3-cosmos-bob&gt; openc3.bat cli rake build VERSION=1.0.0 Successfully built RubyGem Name: openc3-cosmos-bob Version: 1.0.0 File: openc3-cosmos-bob-1.0.0.gem 構築するバージョンを指定するためにVERSIONが必要であることに注意してください。プラグインを構築する際にはセマンティックバージョニングをお勧めします。これにより、プラグインを使用する人々は、重大な変更がいつあるかを知ることができます。 プラグインが構築されたら、COSMOSにアップロードします。Adminページに戻り、「Plugins」タブをクリックします。「Click to install plugin」をクリックし、openc3-cosmos-bob-1.0.0.gemファイルを選択します。次に「Upload」をクリックします。CmdTlmServerに戻ると、プラグインがデプロイされ、BOB_INTインターフェースが表示され、接続を試みるはずです。ポート8080で何かがリッスンしているのでなければ接続されることはないので、「Cancel」をクリックしてください。この時点で、他のCmdTlmServerタブや他のツールを調べて、新しく定義したBOBターゲットを確認できます。 BOBターゲットを変更して、COSMOS内のコピーを更新してみましょう。COSMOSのCommand SenderでBOB EXAMPLEを開くと、VALUEパラメータの値が2.5であることが分かります。openc3-cosmos-bob/targets/BOB/cmd_tlm/cmd.txtを開いて、VALUEのデフォルト値を5に、説明を「New Value」に変更します。 COMMAND BOB EXAMPLE BIG_ENDIAN &quot;Packet description&quot; # Keyword Name BitSize Type Min Max Default Description APPEND_ID_PARAMETER ID 16 INT 1 1 1 &quot;Identifier&quot; APPEND_PARAMETER VALUE 32 FLOAT 0 10.5 5 &quot;New Value&quot; APPEND_PARAMETER BOOL 8 UINT MIN MAX 0 &quot;Boolean&quot; STATE FALSE 0 STATE TRUE 1 APPEND_PARAMETER LABEL 0 STRING &quot;OpenC3&quot; &quot;The label to apply&quot; 新しいVERSION番号でプラグインを再ビルドします。重大な変更を行っていないので、パッチリリース番号を単純に上げるだけです： openc3-cosmos-bob&gt; openc3.bat cli rake build VERSION=1.0.1 Successfully built RubyGem Name: openc3-cosmos-bob Version: 1.0.1 File: openc3-cosmos-bob-1.0.1.gem Adminページに戻り、「Plugins」タブをクリックします。今回は、openc3-cosmos-bob-1.0.0の横にある時計アイコンをクリックして、プラグインをアップグレードします。新しくビルドしたプラグインgemを参照して選択します。これにより、プラグイン変数（bob_target_name）の再入力が求められますが、名前を変更せずに「OK」をクリックしてください。プラグインがインストールされるというメッセージが表示され、プラグインリストがopenc3-cosmos-bob-1.0.1.gemに変更されるはずです。Command Senderに戻ると、VALUEの新しいデフォルト値が5、説明が「New Value」になっているはずです。これでプラグインをアップグレードしました！ この時点で、実際のターゲットにちなんだ名前の新しいプラグインを作成し、インターフェースとコマンド＆テレメトリの定義を変更して、COSMOSがターゲットに接続して制御できるようにすることができます。問題が発生した場合は、Github Issuesページで解決策を探してください。サポート契約や専門的なCOSMOS開発についてお問い合わせがある場合は、support@openc3.comまでご連絡ください。 ","version":"次へ","tagName":"h2"},{"title":"アップグレード","type":0,"sectionRef":"#","url":"/ja/docs/getting-started/upgrading","content":"","keywords":"","version":"次へ"},{"title":"COSMOSのアップグレード​","type":1,"pageTitle":"アップグレード","url":"/ja/docs/getting-started/upgrading#cosmosのアップグレード","content":" COSMOSはDockerコンテナとしてリリースされています。Dockerコンテナとボリュームを使用しているため、既存のCOSMOSアプリケーションを停止し、新しいリリースをダウンロードして実行するだけでアップグレードが完了します。  リリースノート 常にリリースページにあるリリースに関連するリリースノートを確認してください。移行に関する注意事項が含まれている場合があります。  この例では、C:\\cosmos-projectに既存のCOSMOSプロジェクトがあることを前提としています。  現在のCOSMOSアプリケーションを停止します C:\\cosmos-project&gt; openc3.bat stop .envファイル内のリリースを希望のリリースに変更します OPENC3_TAG=5.1.1 新しいCOSMOSアプリケーションを実行します C:\\cosmos-project&gt; openc3.bat run   ダウングレード ダウングレードは必ずしもサポートされていません。COSMOSをアップグレードする際には、データベースをアップグレードし、内部データ構造を移行する必要があることがあります。すべてのリリースで完全な回帰テストを実施していますが、特定のプラグインを使用して個別のマシンをアップグレードし、本番システムへのアップグレードを展開する前にローカルでテストすることをお勧めします。 一般的に、パッチリリース(x.y.Z)はダウングレード可能ですが、マイナーリリース(x.Y.z)は_場合によってダウングレード可能かもしれません。メジャーリリース(X.y.z)はダウングレードすることはできません。  ","version":"次へ","tagName":"h2"},{"title":"COSMOS 5からCOSMOS 6への移行​","type":1,"pageTitle":"アップグレード","url":"/ja/docs/getting-started/upgrading#cosmos-5からcosmos-6への移行","content":" 開発者向け カスタムツールやウィジェットを作成していない場合、COSMOS 5からCOSMOS 6へのアップグレードに特別な変更は必要ありません。上記の通常のアップグレード手順に従い、リリースノートに従ってください。  COSMOS 6は、Vueフレームワークと共通ライブラリコードに関するカスタムツールに互換性のない変更をいくつか導入しています。Vue 2（2023年12月31日にEOL）からVue 3にアップグレードしました。これらのVueバージョンは互いに互換性がないため、Vue 2で書かれたツールはすべて更新する必要があります。さらに、@openc3/tool-common NPMパッケージは非推奨となり、その機能は@openc3/js-commonと@openc3/vue-commonの2つのパッケージに再編成されました。これにより、Vueフレームワークを使用せずにCOSMOSツールを構築する開発者により良い体験を提供します。  また、COSMOS 6ではほとんど使用されていなかったAPIメソッドをいくつか削除しました。  ","version":"次へ","tagName":"h2"},{"title":"Vueの更新​","type":1,"pageTitle":"アップグレード","url":"/ja/docs/getting-started/upgrading#vueの更新","content":" ツールがVueで構築されていない場合（例：フロントエンドフレームワークなしで構築された、またはReact、Angularなどで構築された場合）、このセクションはスキップできます。  簡易的な方法​  比較的シンプルなツールであれば、依存関係を更新して発生するビルドエラーを修正し、ツールのテストと使用から見つかったランタイムエラーを修正するだけで、一度にアップグレードできる可能性があります。このアップグレード方法に自信がある場合は、このプルリクエストを参照して、何を変更する必要があるかを確認できます。それ以外の場合は、このガイドの残りの部分で、より詳細で完全な移行プロセスを説明します。  ステップ1：Vue互換モード​  VueチームはVue 2からVue 3への移行を支援するための互換モードを提供しています。これによりツールを起動して実行でき、必要な変更を見つけやすくなります。  (1.a) 依存関係の更新​  パッケージマネージャーを使用するか、package.jsonファイルを編集して、次の依存関係を更新します（使用していない「Update」とマークされたパッケージは無視してください）  削除: vue-template-compiler追加: @vue/compat &gt;= 3.5 (npmjs.com)追加: @vue/compiler-sfc &gt;= 3.5 (npmjs.com)更新: @vue/test-utils &gt;= 2.4 (npmjs.com)更新: vue &gt;= 3.5 (npmjs.com)更新: vuex &gt;= 4.1 (npmjs.com)更新: vue-router &gt;= 4.4 (npmjs.com)更新: vuetify &gt;= 3.7 (npmjs.com)更新: single-spa-vue &gt;= 3.0 (npmjs.com)  Eslintは移行のためにコードに必要な変更を指摘するのに役立つため、まだプロジェクトに含まれていない場合は、eslintを含めることをお勧めします。その方法を説明するオンラインガイドはたくさんあります。eslintを使用している場合は、ツールの依存関係に次の追加変更を行います：  追加: eslint-plugin-vuetify &gt;= 2.5 (npmjs.com)追加: vue-eslint-parser &gt;= 9.4 (npmjs.com)  package.jsonファイルを手動で変更した場合は、プロジェクトのルートでyarnまたはnpm installを実行して変更を適用することを忘れないでください。  (1.b) Vue構成ファイル(vue.config.js)の更新​  このファイルからエクスポートされるオブジェクトに、次のようなchainWebpackプロパティがある可能性があります（内容は異なる場合があります）  chainWebpack: (config) =&gt; { config.module .rule('vue') .use('vue-loader') .tap((options) =&gt; { return { prettify: false, } }) },   このブロックの最上部に@vue/compatの解決エイリアスを追加し、コンパイラがVue 2互換モードを使用するように設定します：  chainWebpack: (config) =&gt; { config.resolve.alias.set('vue', '@vue/compat') // この行を追加 config.module .rule('vue') .use('vue-loader') .tap((options) =&gt; { return { prettify: false, compilerOptions: { // このブロックを compatConfig: { // 追加 MODE: 2, // }, // }, // ここまで } }) },   (1.c) eslint構成ファイル(.eslintrc)の更新​  extendsブロックに'plugin:vue/essential'を見つけて、'plugin:vue/vue3-essential'に変更します。そのプラグインがextendsブロックにない場合、またはブロック全体が欠けている場合は、これを追加します。VueのAPIの使用方法に関する互換性のない変更を見つけるのに役立ちます。  extends: [ 'plugin:vue/vue3-essential', // plugin:vue/essentialから変更 'plugin:prettier/recommended', '@vue/prettier', ],   (1.d) ビルドおよびランタイムの警告とエラーの修正​  リントとビルドスクリプトを実行します（例：yarn lintおよびyarn build）。eslintプラグインとVueの互換モードにより、対処する必要があるコード変更の最初のセットが見つかります。プロジェクトが正常にビルドされるまで、これらのlint/ビルドエラーを修正します。  ビルドが完了したら、通常の開発時と同様にプロジェクトを実行します。yarn serveでローカル開発サーバーから提供し、ブラウザのインポートマップオーバーライドに追加することをお勧めします。ツールの機能をテストし、ブラウザコンソールに表示されるVueのエラーと警告に対処します。（注意：MODE: 2-このセクションの最初は、ツールが完全に動作しなくても問題ありません。ブラウザコンソールに記録される警告とエラーに対処するだけです。次のステップでツールを完全に動作させます。）  COSMOSのファーストパーティツールを移行した経験から、最低でもmain.jsとrouter.jsファイルを変更する必要がある可能性が高いです。上記の「簡易的な方法」セクションで言及したPRを参照して変更内容を確認するか、Vue 2 -&gt; Vue 3移行ガイドをインターネットで検索して、警告やエラーに対処するための助けを得ることができます。  ステップ2：互換モードを2から3に変える​  vue構成ファイル（vue.config.js）に追加したcompatConfigをMODE: 2からMODE: 3に変更します。これにより、前のステップで変更に対処したことをVueの互換モードに伝え、次の問題セットを見つけます（これは複数ステップのプロセスであるため）。「(1.d) ビルドおよびランタイムの警告とエラーの修正」ステップを繰り返します。  ステップ3：Vuetifyの更新​  Vuetifyを使用していない場合は、このステップをスキップできます。  eslint構成（.eslintrc）を再度変更してVuetifyプラグインを追加します：  extends: [ 'plugin:vue/vue3-essential', 'plugin:vuetify/base', // この行を追加 'plugin:prettier/recommended', '@vue/prettier', ],   注意： Vuetify eslintプラグインはVuetify 2からVuetify 3へのプロジェクト移行用に設計されており、リントのパフォーマンスに問題を引き起こす可能性があるため、ツールの移行が完了したら削除する必要があります。  .eslintrcで再度、parserOptionsブロックを見つけて、その上にparserプロパティを追加します：  parser: 'vue-eslint-parser', // この行を追加 parserOptions: { ... },   これで、eslintを実行すると、コードがVuetify APIをどのように使用しているかに関して対処する必要がある変更について教えてくれます。これらの変更を見つけるには、Vueファイルでeslintを実行します（例：yarn eslint . --ext .vue）。これらを手動で対処することもできますし、eslintを信頼しているか、優れたバージョン管理を行っている場合は、プラグインに自動的に修正させることができます（yarn eslint . --ext .vue --fix）。  最後に、COSMOSからVuetifyを介してAstro UXDSアイコンを使用している場合—または他のカスタムアイコンパックを使用している場合—パックエイリアス形式を$packName-からpackName:に変更する必要があります。antenna-transmit Astroアイコンの例を示します：  &lt;!-- Vue 2 / Vuetify 2 (古い) --&gt; &lt;v-icon&gt; $astro-antenna-transmit &lt;/v-icon&gt; &lt;!-- Vue 3 / Vuetify 3 (新しい) --&gt; &lt;v-icon&gt; astro:antenna-transmit &lt;/v-icon&gt;   ステップ4：クリーンアップ​  ステップ1.aで追加した@vue/compatとeslint-plugin-vuetifyの依存関係を削除しますステップ1.bで追加したcompatConfigを削除しますステップ3で追加した'plugin:vuetify/base'を削除します  ","version":"次へ","tagName":"h3"},{"title":"新しいOpenC3共通パッケージへの移行​","type":1,"pageTitle":"アップグレード","url":"/ja/docs/getting-started/upgrading#新しいopenc3共通パッケージへの移行","content":" このガイドの最初の段落で述べたように、@openc3/tool-common NPMパッケージは非推奨になりました。その機能はすべて同じままですが、すべてが異なる方法で整理されているため、依存関係とインポートを更新する必要があります。  ステップ1：依存関係の更新​  パッケージマネージャーを使用するか、package.jsonファイルを編集して、次の依存関係を更新します  削除: @openc3/tool-common追加: @openc3/js-common &gt;= 6.0 (npmjs.com)追加: @openc3/vue-common &gt;= 6.0 (npmjs.com) これは、当社のVue関連のもの（コンポーネント、プラグインなど）を使用している場合にのみ必要です  ステップ2：コード内のインポートの更新​  COSMOS 5では、@openc3/tool-commonのsrcディレクトリから直接インポートしてビルドプロセスでツールに組み込んでいました。COSMOS 6では、すべてが新しい共通パッケージでいくつかのトップレベルエクスポートを通じてエクスポートされています。一般的なパターンは次のとおりです：  COSMOS 5: import bar from '@openc3/tool-common/src/foo/bar'COSMOS 6: import { bar } from '@openc3/vue-common/foo'  このパターンにより、複数のインポートステートメントを1つにまとめることもできます（例：import { bar, baz } from '@openc3/vue-common/foo'）。  このパターンには3つの例外があります：  ウィジェットはcomponentsディレクトリ配下ではなく、独自のトップレベルエクスポートを取得します 古い: import foo from '@openc3/tool-common/src/components/widgets/Foo新しい: import { foo } from '@openc3/vue-common/widgets アイコンも同様の扱いになりました 古い: import bar from '@openc3/tool-common/src/components/icons/Bar新しい: import { bar } from '@openc3/vue-common/icons TimeFiltersミックスインはtools/baseからutilに移動されました 古い: import TimeFilters from '@openc3/tool-common/src/tools/base/util/timeFilters新しい: import { TimeFilters } from '@openc3/vue-common/util  @openc3/js-common​  このパッケージには、以前は@openc3/tool-common/src/servicesにあったものが含まれています。そのパス以外のものは、以下で説明するvue-commonパッケージに含まれています。  そのパスからのインポートを適宜更新します。例：  // COSMOS 5 (古い) import Api from &quot;@openc3/tool-common/src/services/api&quot;; import Cable from &quot;@openc3/tool-common/src/services/cable&quot;; import { OpenC3Api } from &quot;@openc3/tool-common/src/services/openc3Api&quot;; // COSMOS 6 (新しい) import { Api, Cable, OpenC3Api } from &quot;@openc3/js-common/services&quot;;   このパッケージは、おそらく必要ないかもしれませんが、役立つかもしれないいくつかのトップレベルインポートも提供しています：  import { prependBasePath } from '@openc3/js-common/utils はVue Routerのrouteオブジェクトとその下にベースパス（例：localhost:2900）を前置する関数を提供します。これは、完全なパスが必要なsingle-spaとvue-router 4のルーティングロジックの特定の問題に遭遇した場合に役立ちます。使用方法はこちらで確認できます。 import { devServerPlugin } from '@openc3/js-common/viteDevServerPlugin。このViteプラグインは、webpack/vue-cliから移行する際にツール用のローカル開発サーバーを実行するための一時的なハックです。Viteの組み込みvite dev開発サーバーに置き換えるべきですが、少なくとも当社のファーストパーティCOSMOSツールでは現在動作していません。使用方法はこちらで確認できます。  @openc3/vue-common​  このパッケージには、ファーストパーティツールの構築に使用するすべての共有Vueコンポーネントが提供されています。主なトップレベルエクスポートはcomponents、icons、plugins、util、およびwidgetsです。COSMOS Enterpriseとのコード共有のために構築したツール固有のエクスポートもあります：tool/base、tool/admin、およびtool/calendar。以下は例ですが、上記で言及したパターンを参照してください。  // COSMOS 5 (古い) import DetailsDialog from &quot;@openc3/tool-common/src/components/DetailsDialog&quot;; import Graph from &quot;@openc3/tool-common/src/components/Graph&quot;; import Notify from &quot;@openc3/tool-common/src/plugins/notify&quot;; import TimeFilters from &quot;@openc3/tool-common/src/tools/base/util/timeFilters&quot;; import VWidget from &quot;@openc3/tool-common/src/components/widgets/VWidget&quot;; // COSMOS 6 (新しい) import { DetailsDialog, Graph } from &quot;@openc3/vue-common/components&quot;; import { Notify } from &quot;@openc3/vue-common/plugins&quot;; import { TimeFilters } from &quot;@openc3/vue-common/util&quot;; import { VWidget } from &quot;@openc3/vue-common/widgets&quot;;   ","version":"次へ","tagName":"h3"},{"title":"COSMOS 4からCOSMOS 5への移行​","type":1,"pageTitle":"アップグレード","url":"/ja/docs/getting-started/upgrading#cosmos-4からcosmos-5への移行","content":" すべてのCOSMOSユーザー すべてのCOSMOS 4ユーザーは構成を5にアップグレードする必要があります。ただし、コマンド、テレメトリ、画面定義（キーワードと構文）は同じままです。  COSMOS 5は新しいアーキテクチャであり、ターゲットを独立したプラグインとして扱います。したがって、COSMOS 4からCOSMOS 5への移行における主な作業は、ターゲットをプラグインに変換することです。独立したターゲット（独自のインターフェースを持つ）ごとにプラグインを作成することをお勧めしますが、インターフェースを共有するターゲットは同じプラグインの一部である必要があります。独立したプラグインを推奨する理由は、プラグインを個別にバージョン管理でき、特定のプロジェクト外で共有しやすくなるためです。プロジェクト固有のターゲット（カスタムハードウェアなど）がある場合は、デプロイを容易にするために潜在的に組み合わせることができます。  ","version":"次へ","tagName":"h2"},{"title":"構成移行ツール​","type":1,"pageTitle":"アップグレード","url":"/ja/docs/getting-started/upgrading#構成移行ツール","content":" COSMOS 5（COSMOS 6ではなく）には、既存のCOSMOS 4構成をCOSMOS 5プラグインに変換するための移行ツールが含まれています。この例では、C:\\COSMOSに既存のCOSMOS 4構成があり、C:\\cosmos-projectに新しいCOSMOS 5インストールがあることを前提としています。Linuxユーザーはパスを調整し、.batを.shに変更して同様に実行できます。  既存のCOSMOS 4構成ディレクトリに移動します。config、lib、procedures、outputsディレクトリが表示されるはずです。次に、COSMOS 5インストールの絶対パスを指定して移行ツールを実行できます。 C:\\COSMOS&gt; C:\\cosmos-project\\openc3.bat cli migrate -a demo これにより、既存のlibとproceduresファイルと既存のすべてのターゲットを含むDEMOという名前のターゲットを持つopenc3-cosmos-demoという新しいCOSMOS 5プラグインが作成されます。 C:\\COSMOS&gt; C:\\cosmos-project\\openc3.bat cli migrate demo-part INST これにより、既存のlibとproceduresファイル、およびINSTターゲット（他のターゲットは含まない）を含むDEMO_PARTという名前のターゲットを持つopenc3-cosmos-demo-partという新しいCOSMOS 5プラグインが作成されます。 新しいCOSMOS 5プラグインを開き、plugin.txtファイルが正しく構成されていることを確認します。移行ツールはVARIABLEsやMICROSERVICEsを作成せず、ターゲット置換も処理しないため、これらの機能は手動で追加する必要があります。 プラグインの構築の「はじめに」チュートリアルの部分に従って、新しいプラグインを構築し、COSMOS 5にアップロードしてください。  ","version":"次へ","tagName":"h3"},{"title":"カスタムツールのアップグレード​","type":1,"pageTitle":"アップグレード","url":"/ja/docs/getting-started/upgrading#カスタムツールのアップグレード","content":" COSMOS 4はQtデスクトップベースのアプリケーションでした。COSMOS 5は完全に新しいアーキテクチャで、JavascriptフレームワークとしてVue.jsを、GUIライブラリとしてVuetifyを使用して、ブラウザでネイティブに実行されます。single-spaを利用して、任意の言語でCOSMOSツールプラグインを作成できるようにし、Vue.js（推奨）、Angular、React、Svelteのテンプレートを提供しています。COSMOS 4のカスタムツールはCOSMOS 5で実行するために完全に書き直す必要があります。ネイティブのCOSMOS ツールを使用し、再作成しようとしているツールに最も一致するGUIの概念と機能を見つけることをお勧めします。  カスタム開発が必要な場合は、sales@openc3.comまでお問い合わせください。 ","version":"次へ","tagName":"h3"},{"title":"要件と設計","type":0,"sectionRef":"#","url":"/ja/docs/getting-started/requirements","content":"","keywords":"","version":"次へ"},{"title":"用語​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#用語","content":" COSMOSシステムでは、理解することが重要ないくつかの用語を使用しています。以下の表はこれらの用語を定義しています。  用語\t定義ターゲット\tCOSMOSターゲットは、COSMOSコマンド＆テレメトリサーバーがインターフェースを使用して接続し、コマンドを送信したり、テレメトリを受信したりする組み込みシステムです。 コマンド\tターゲットに何らかのアクションを実行するよう指示する情報のパケットです。 テレメトリパケット\tターゲットからステータスを提供する情報のパケットです。 インターフェース\tターゲットにコマンドを送信したり、ターゲットからテレメトリを受信したりする方法を知っているRubyクラスです。COSMOSには、TCP/IP、UDP、シリアル接続をサポートするインターフェースが付属しています。カスタムインターフェースは簡単に追加できます。 Ruby\tCOSMOSのアプリケーションやライブラリ、COSMOSスクリプトやテスト手順を記述するために使用されるプログラミング言語です。 設定ファイル\tCOSMOSはシンプルなプレーンテキスト設定ファイルを使用して、コマンドとテレメトリパケットを定義し、各COSMOSアプリケーションを設定します。これらのファイルは人間が読み書きしやすく、機械も読み書きしやすいです。 パケットログファイル\tログに記録されたコマンドまたはテレメトリパケットのいずれかを含むバイナリファイルです。 メッセージログファイル\tシステムによって生成されたメッセージを含むテキストファイルです。 ツール\tCOSMOSアプリケーションの別名です。  ","version":"次へ","tagName":"h2"},{"title":"全体的なアーキテクチャとコンテキスト図​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#全体的なアーキテクチャとコンテキスト図","content":" 以下の図はCOSMOS 6のアーキテクチャを示しています。    このアーキテクチャの主要な側面：  COSMOS 6は、クラウドネイティブ、コンテナ化されたマイクロサービス指向のコマンド＆コントロールシステムです。すべてのCOSMOSマイクロサービスはDockerコンテナであり、そのためDockerがCOSMOSシステム全体を含んでいるように表示されています。左側の緑色のボックスは、COSMOSが接続する外部の組み込みシステム（ターゲット）を表しています。Redisデータストアには、すべてのマイクロサービスの設定、現在値テーブル、復調されたデータを含むデータストリームが含まれています。Minioデータストアには、プラグイン、ターゲット、設定データ、テキストログ、および生データ、復調データ、削減データのすべてのバイナリログが含まれています。ユーザーはウェブブラウザからCOSMOSと対話し、内部のTraefikロードバランサーを通じてルーティングされます。  COSMOSは多くの異なる種類のターゲットに接続できます。例としては、フライトソフトウェア（FSW）、地上支援機器（GSE）、Labview、およびAgilent電源などのCOTSターゲットなどがあります。通信インターフェースを提供する任意の組み込みシステムをCOSMOSに接続できます。COSMOSには、TCP/IP、UDP、MQTT、およびシリアル接続を介して接続するためのインターフェースが付属しています。これによりほとんどのシステムをカバーしていますが、カスタムインターフェースを作成して何にでも接続することもできます。ターゲットとのすべてのリアルタイム通信はCOSMOSシステムを通過します。これにより、すべてのコマンドとテレメトリが確実にログに記録されます。すべてのツールはプレーンテキスト設定ファイルで設定されています。COSMOSライブラリを使用して、リアルタイムのコマンドとテレメトリストリームと対話でき、ログに記録されたデータを処理できるプログラム固有のツールを作成できます。  ","version":"次へ","tagName":"h2"},{"title":"全体的な要件​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#全体的な要件","content":" 要件ID\t説明\tテスト説明COSMOS-1\tすべてのCOSMOSのコア機能はコンテナ化されること。\tCOSMOSがDockerで実行されていることを確認する COSMOS-2\tCOSMOSユーザーインターフェースはChromiumベースのウェブブラウザからアクセス可能であること\tChrome/EdgeでCOSMOSを開く COSMOS-3\tCOSMOSユーザーインターフェースはFirefoxウェブブラウザからアクセス可能であること\tFirefoxでCOSMOSを開く COSMOS-4\tCOSMOSは送信されたすべてのコマンドをログに記録すること COSMOS-5\tCOSMOSは受信したすべてのテレメトリをログに記録すること COSMOS-6\tCOSMOSは受信したすべてのテレメトリパケットを復調すること COSMOS-7\tCOSMOSはターゲットへの接続を自律的に試みることをサポートすること\tCTSを起動するとターゲットが接続されることを確認する COSMOS-8\tCOSMOSは受信時にテレメトリパケットにタイムスタンプを付けること\tログに記録されたパケットにタイムスタンプが付いていることを確認する COSMOS-9\tCOSMOSはテレメトリパケットに1ミリ秒以上の解像度でタイムスタンプを付けること。注意：この要件は解像度のみを指します。COSMOSはリアルタイムオペレーティングシステムで実行されず、精度は保証できません。\tログのタイムスタンプを確認する COSMOS-10\tCOSMOSは受信したテレメトリにUTCタイムスタンプを付けること\tログに記録されたタイムスタンプが期待通りであることを確認する COSMOS-11\tCOSMOSは受信したコマンド、制限違反、および発生したエラーのタイムスタンプ付きログを維持すること\tCOSMOSメッセージログを表示する  ","version":"次へ","tagName":"h2"},{"title":"API要件​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#api要件","content":" 要件ID\t説明\tテスト説明API-1\tCOSMOS APIはインターフェースのスクリプト化された接続と切断を可能にすること\tスクリプトからインターフェースを切断して接続する API-2\tCOSMOS APIはルーターのスクリプト化された接続と切断を可能にすること\tスクリプトからルーターを切断して接続する API-3\tCOSMOS APIは現在のリミットセットをスクリプトで設定できるようにすること\tスクリプトから別のリミットセットを選択する API-4\tCOSMOS APIはターゲットのコマンド送信を可能にすること\tコマンドを送信する API-5\tCOSMOS APIはテレメトリアイテムの現在の値の読み取りを可能にすること\tテレメトリポイントを読み取る API-6\tCOSMOS APIはリアルタイムおよびログに記録されたテレメトリパケットのストリーミングを可能にすること\tテレメトリパケットをストリーミングする API-7\tCOSMOS APIはリアルタイムおよびログに記録されたコマンドパケットのストリーミングを可能にすること\tコマンドパケットをストリーミングする API-8\tCOSMOS APIはCOSMOSスクリプトの開始を可能にすること\tAPIを使用してスクリプトを開始する  ","version":"次へ","tagName":"h2"},{"title":"コマンド＆テレメトリサーバー​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#コマンドテレメトリサーバー","content":" コマンド＆テレメトリサーバーは、特定のスコープ向けのCOSMOS全体的なステータスを提供します。  要件ID\t説明\tテスト説明CTS-1\tコマンド＆テレメトリサーバーはすべてのインターフェースのリストを表示すること\tインターフェースタブを表示する CTS-2\tコマンド＆テレメトリサーバーはインターフェースの手動接続と切断を可能にすること\tGUIボタンを押してインターフェースを切断して接続する CTS-3\tコマンド＆テレメトリサーバーはすべてのターゲットのリストを表示すること\tターゲットタブを表示する CTS-4\tコマンド＆テレメトリサーバーは既知のコマンドのリストを表示すること\tコマンドパケットタブを表示する CTS-5\tコマンド＆テレメトリサーバーは最新の受信コマンドの生データを表示すること\tコマンドパケットタブを表示し、コマンドの生データ表示ボタンをクリックする CTS-6\tコマンド＆テレメトリサーバーは既知のテレメトリパケットのリストを表示すること\tテレメトリパケットタブを表示する CTS-7\tコマンド＆テレメトリサーバーは最新の受信テレメトリパケットの生パケットデータを表示すること\tテレメトリパケットタブを表示し、テレメトリパケットの生データ表示ボタンをクリックする CTS-8\tコマンド＆テレメトリサーバーはすべてのルーターのリストを表示すること\tルータータブを表示する CTS-9\tコマンド＆テレメトリサーバーはルーターの手動接続と切断を可能にすること\tGUIボタンを押してルーターを切断して接続する CTS-10\tコマンド＆テレメトリサーバーは現在のリミットセットを手動で設定することを可能にすること\tコンボボックスから別のリミットセットを選択する CTS-11\tコマンド＆テレメトリサーバーはパケットビューアーでテレメトリパケットを開くことをサポートすること\tテレメトリパケットタブで、テレメトリパケットの「パケットビューアーで表示」をクリックする CTS-12\tコマンド＆テレメトリサーバーはタイムスタンプをローカル時間で表示すること\tログのタイムスタンプを表示する  ","version":"次へ","tagName":"h2"},{"title":"リミットモニター​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#リミットモニター","content":" リミットモニターは、現在リミット外にあるすべてのテレメトリポイントを表示し、リミットモニターが起動されてからリミット外になったテレメトリポイントも表示します。  要件ID\t説明\tテスト説明LM-1\tリミットモニターは現在リミット外にあるすべてのテレメトリポイントを表示すること\t表示されているテレメトリポイントを確認する LM-2\tリミットモニターはテレメトリポイントの無視をサポートすること\tテレメトリポイントの「無視 (ignore)」をクリックする LM-3\tリミットモニターはリミット違反の表示ログを保持すること\tログタブを表示する LM-4\tリミットモニターは一時的にリミット外になったテレメトリポイントの表示を継続すること\tテレメトリポイントが緑色に戻るまで観察する LM-5\tリミットモニターは設定の保存をサポートすること\t設定を保存する LM-6\tリミットモニターは設定のロードをサポートすること\t設定をロードする  ","version":"次へ","tagName":"h2"},{"title":"コマンドセンダー​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#コマンドセンダー","content":" コマンドセンダーは、単一のコマンドをターゲットに送信する簡単な方法を提供します。グラフィカルユーザーインターフェースは、ターゲット名とコマンド名で整理された送信したいコマンドをすばやく選択するためのシンプルなドロップダウンを提供します。ユーザーがコマンドを選択した後、希望するコマンドパラメータを入力し、送信をクリックしてコマンドをターゲットに送信します。  要件ID\t説明\tテスト説明CMD-1\tコマンドセンダーはターゲット名とパケット名によるコマンドの選択を可能にすること\tドロップダウンメニューでターゲット名とパケット名によって特定のコマンドを選択する CMD-2\tコマンドセンダーは選択したコマンドの送信を可能にすること\t送信ボタンを押して選択したコマンドを送信する CMD-3\tコマンドセンダーは選択したコマンドの無視されていないパラメータを表示すること\t特定のコマンドを選択し、期待されるパラメータが表示されていることを確認する CMD-4\tコマンドセンダーは状態を持つコマンドパラメータの状態値を選択するメカニズムを提供すること\t状態を持つ特定のコマンドの特定の状態値を選択する CMD-5\tコマンドセンダーは状態を持つコマンドパラメータに手動で入力した値の送信を許可すること\t状態を持つ特定のコマンドの値を手動で入力する CMD-6\tコマンドセンダーは必須パラメータが提供されていない場合、コマンドの送信を拒否すること\t必須パラメータが入力されていないコマンドの送信を試みる CMD-7\tコマンドセンダーは範囲チェックを無視しながらコマンドを送信することをサポートすること\t「範囲チェックを無視 (Ignore Range Checking)」モードに入り、範囲外のパラメータを持つコマンドを送信する CMD-8\tコマンドセンダーは状態値を16進数で表示することをオプションでサポートすること\t「状態値を16進数で表示 (Display State Values in Hex)」モードに入り、状態値が16進数で表示されることを確認する CMD-9\tコマンドセンダーは無視されたコマンドパラメータをオプションで表示すること\t「無視されたパラメータを表示 (Show Ignored Parameters)」モードに入り、無視されたパラメータが表示されることを確認する CMD-10\tコマンドセンダーは危険なコマンドを尊重し、続行する前にユーザーに通知すること\t危険なコマンドを送信し、コマンドが送信される前にダイアログボックスが表示されることを確認する。ダイアログの承認と送信の拒否の両方を確認する CMD-11\tコマンドセンダーは送信された各コマンドのコマンド履歴を保持すること\tコマンドを送信し、コマンド履歴ボックスに表示されることを確認する CMD-12\tコマンドセンダーはコマンド履歴内の任意のコマンドの再送信を可能にすること\tコマンド履歴ボックス内のコマンドの1つを再送信する  ","version":"次へ","tagName":"h2"},{"title":"スクリプトランナー​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#スクリプトランナー","content":" スクリプトランナーは、スクリプト/手順の編集と実行のための視覚的なインターフェースを提供します。全機能を備えたテキストエディタは、スクリプト開発中にシンタックスハイライトとコード補完を提供します。スクリプト実行中は、現在実行中の行がハイライトされ、ログに記録されたメッセージがユーザーに対してハイライト表示されます。エラーが発生した場合、スクリプトは一時停止し、ユーザーに警告します。ユーザーはスクリプトを停止するか、エラーを無視して続行するかを決定できます。ユーザーは失敗した行や、続行する前に他の近くの行を再試行することもできます。  スクリプトランナーは現在、ソフトウェアユニットテストで使用される非常に成功したパターンを反映したシステムレベルのスクリプティングを設計するための構造化された方法論も提供しています。システムレベルのテスト/手順は、グループに整理されたケースで構成されています。例えば、特定のメカニズムに関連するすべての要件を検証する1つのグループがあるかもしれません。理想的には、これを異なるシナリオの個別のケースに分割します。(例: シャッターを開くためのケースや、閉じるためのケースなど) ケースは理想的には小さく独立したタスクです。これらのグループのいくつかは、EMIやソフトウェアFQTなどの主要なテストを実行するために、全体的なスイートに結合されます。  要件ID\t説明\tテスト説明SR-1\tスクリプトランナーはテストスクリプト開発用のテキストエディタを提供すること\tスクリプトランナーを開いて簡単なテストスクリプトを作成する。新規作成、開く、再読み込み、閉じる、保存、名前を付けて保存などのすべての標準ファイル操作を実行する。切り取り、コピー、貼り付け、元に戻す、やり直し、すべて選択、行のコメント/コメント解除などの標準編集操作をすべて実行する SR-2\tスクリプトランナーは検索と置換機能を提供すること\t検索、置換、次を検索、前を検索などの標準的な検索と置換機能をすべて実行する SR-3\tスクリプトランナーはcmd()、tlm()、wait_check()などのCOSMOS APIメソッドのコード補完を提供すること。注：他のメソッドもサポートされている場合がある\tスクリプトを作成し、言及されたキーワードでコード補完を試す SR-4\tスクリプトランナーはRubyベースのCOSMOSスクリプトを実行すること\tスタート(start)を押してスクリプトを実行する SR-5\tスクリプトランナーはスクリプトの現在実行中の行をハイライトすること\tテストスクリプトの実行中に行がハイライトされていることを確認する SR-6\tスクリプトランナーは実行中のスクリプトの一時停止を可能にすること\t一時停止(pause)ボタンを押し、スクリプトが一時停止していることを確認する。スタートを押して再開する SR-7\tスクリプトランナーは実行中のスクリプトの停止を可能にすること\t停止(stop)を押し、スクリプトが停止していることを確認する SR-8\tスクリプトランナーはエラーが発生した時に実行中のスクリプトを一時停止すること\t確実に失敗するステートメントを含むスクリプトを作成し、スクリプトが一時停止していることを確認する SR-9\tスクリプトランナーは送信されたコマンドをログに記録すること\tコマンドを送信するスクリプトを実行し、それがログに記録されていることを確認する SR-10\tスクリプトランナーはSTDOUTに書き込まれたテキストをログに記録すること。注：通常はputsメソッドを通じて。\tputsを使用してメッセージを書き込むスクリプトを実行し、それがログに記録されていることを確認する SR-11\tスクリプトランナーは待機時間をログに記録すること\twaitメソッドを含むスクリプトを実行し、待機時間がログに記録されていることを確認する SR-12\tスクリプトランナーはスクリプト実行中に発生したエラーをログに記録すること\t確実に失敗するチェックステートメントを含むスクリプトを作成し、それがログに記録されていることを確認する SR-13\tスクリプトランナーはチェックステートメントの成功と失敗をログに記録すること\t確実に失敗するチェックステートメントと、確実に成功するチェックステートメントを含むスクリプトを作成する。成功と失敗の両方がログに記録されていることを確認する SR-14\tスクリプトランナーは選択した行の実行をサポートすること\t一連の行を選択し、スクリプト(Script)→選択した行を実行(Execute Selected Lines) を使用してそれらを実行する SR-15\tスクリプトランナーは一時停止中に選択した行の実行をサポートすること\t一連の行を選択し、右クリックのコンテキストメニューからそれらを実行する SR-16\tスクリプトランナーは任意の行からスクリプトを開始することをサポートすること\tマウスカーソルを希望の最初の行に置き、スクリプト(Script)→カーソルから実行(Execute From Cursor)を選択する SR-17\tスクリプトランナーはニーモニックチェック機能をサポートすること\tスクリプト(Script)→ニーモニックチェック(Mnemonic Check)を選択する SR-18\tスクリプトランナーは構文チェック機能をサポートすること\tスクリプト(Script)→Ruby構文チェック(Ruby Syntax Check)を選択する SR-19\tスクリプトランナーはスクリプトのインストゥルメンテーションの表示をサポートすること\tスクリプト(Script)→インストゥルメンテーションされたスクリプトを表示(View Instrumented Script)を選択する SR-20\tスクリプトランナーはコマンド＆テレメトリサーバーへの接続なしでスクリプトを実行できる切断モードをサポートすること\tスクリプト(Script)→切断切り替え(Toggle Disconnect)を選択する。コマンドとチェックステートメントを含むスクリプトを実行し、完了まで実行されることを確認する SR-21\tスクリプトランナーはスクリプトのデバッグを支援するためのデバッグターミナルをサポートすること\tスクリプト(Script)→デバッグ切り替え(Toggle Debug)を選択する SR-22\tスクリプトランナーはスクリプトが各行の後に停止し、ユーザーの操作を待つステップモードをサポートすること\tステップをプレスしてスクリプトを進める SR-23\tスクリプトランナーはブレークポイント機能をサポートすること\tブレークポイントを作成し、スクリプトを実行して指定された行で停止することを確認する SR-25\tスクリプトランナースイートモードは個別のテストスイートの実行をサポートすること\t個別のテストスイートを実行する SR-26\tスクリプトランナースイートモードは個別のテストグループの実行をサポートすること\t個別のテストグループを実行する SR-27\tスクリプトランナースイートモードは個別のテストケースの実行をサポートすること\t個別のテストケースを実行する SR-28\tスクリプトランナースイートモードはテストグループのセットアップとティアダウンメソッドを個別に実行することをサポートすること\tテストグループのセットアップを実行する。テストグループのティアダウンを実行する SR-29\tスクリプトランナースイートモードはテストスイートのセットアップとティアダウンメソッドを個別に実行することをサポートすること\tテストスイートのセットアップを実行する。テストスイートのティアダウンを実行する SR-30\tスクリプトランナースイートモードは任意のスイートテストを実行した後にレポートを作成すること\tスイートを実行した後にレポートが生成されることを確認する SR-31\tスクリプトランナースイートモードはエラーが発生した時に一時停止することをサポートすること\tエラー時に一時停止するボックスをチェックしたテストスクリプトと、チェックしていないテストスクリプトを実行する SR-32\tスクリプトランナースイートモードはエラーが発生しても継続することをユーザーに許可することをサポートすること\tエラー時に進行/再試行を許可するボックスをチェックしたテストスクリプトと、チェックしていないテストスクリプトを実行する SR-33\tスクリプトランナースイートモードはエラー発生時の実行中止をサポートすること\tエラー時に中止するボックスをチェックしたテストスクリプトと、チェックしていないテストスクリプトを実行する。 SR-34\tスクリプトランナースイートモードはテストのループをサポートすること\tループテストのボックスをチェックしたテストスクリプトと、チェックしていないテストスクリプトを実行する SR-35\tスクリプトランナースイートモードはエラー発生時のテストループの中断をサポートすること\tエラー時にループを中断するボックスをチェックしたテストスクリプトと、チェックしていないテストスクリプトを実行する SR-36\tスクリプトランナースイートモードはループテストが行われていることを示すユーザーが読める状態フラグをサポートすること\tループ中に$loop_testing変数をチェックし、ループしていない時に再度チェックするテストスクリプトを実行する SR-37\tスクリプトランナースイートモードは手動操作が望まれていることを示すユーザーが読める状態フラグをサポートすること\t手動ボックスをチェックしたテストスクリプトと、チェックしていないテストスクリプトを実行する  ","version":"次へ","tagName":"h2"},{"title":"パケットビューアー​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#パケットビューアー","content":" パケットビューアーは、システムで定義されたテレメトリパケットのリアルタイムの内容を表形式のキーと値の形式で表示するためのシンプルなツールを提供します。  要件ID\t説明\tテスト説明PV-1\tパケットビューアーはターゲット名とパケット名によるテレメトリパケットの選択を可能にすること\tドロップダウンメニューでターゲット名とパケット名によって特定のテレメトリパケットを選択する PV-2\tパケットビューアーは選択したテレメトリパケットの内容を表示すること\t選択したテレメトリパケットのすべてのアイテムが表示され、更新されていることを確認する PV-3\tパケットビューアーはテレメトリアイテムに関する詳細情報を取得するメカニズムを提供すること\tテレメトリアイテムを右クリックし、コンテキストメニューから「詳細(Details)」を選択する PV-4\tパケットビューアーは任意のテレメトリアイテムのグラフを表示するメカニズムを提供すること\tテレメトリアイテムを右クリックし、コンテキストメニューから「グラフ(Graph)」を選択する PV-5\tパケットビューアーはリミット状態に基づいてテレメトリ値に色を付けること\tリミットを含むアイテムのあるパケットを表示し、色付けされていることを確認する PV-6\tパケットビューアーは設定可能なポーリングレートをサポートすること\tファイル(File)→オプション(Options)を選択し、ポーリングレートを変更する PV-7\tパケットビューアーは色覚異常の人がリミット状態を区別できるよう色覚異常モードをサポートすること\t表示(View)→色覚異常モード(Color Blind Mode)を選択し、リミットのあるアイテムがリミット状態の色のテキスト表示とともに表示されることを確認する PV-8\tパケットビューアーは4つのCOSMOS値タイプ（生(raw)、変換済(converted)、フォーマット済(formatted)、単位付きフォーマット済(formatted with units)）でのテレメトリ表示をサポートすること\t表示メニューで4つの値タイプそれぞれを選択し、値が適切に表示されることを確認する  ","version":"次へ","tagName":"h2"},{"title":"テレメトリビューアー​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#テレメトリビューアー","content":" テレメトリビューアーは、テレメトリポイントをカスタム「画面」に整理する方法を提供し、テレメトリデータのユニークで整理されたビューを作成することができます。画面はウィジェットまたは小さなGUIコンポーネントで構成され、テレメトリを表示します。  要件ID\t説明\tテスト説明TV-1\tテレメトリビューアーはユーザー定義のテレメトリ画面を表示すること\tテレメトリを開く TV-2\tテレメトリビューアーはリアルタイムデータを表示すること\tテレメトリ画面がリアルタイムデータを表示していることを確認する TV-3\tテレメトリビューアーは開いているテレメトリ画面とその位置の保存をサポートすること\t3つのテレメトリ画面を開き、ファイル(File)→設定の保存(Save Configuration)を選択する  ","version":"次へ","tagName":"h2"},{"title":"テレメトリグラファー​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#テレメトリグラファー","content":" テレメトリグラファーは、リアルタイムとログファイル再生の両方でテレメトリポイントのグラフ作成を実行します。  要件ID\t説明\tテスト説明TG-1\tテレメトリグラファーはテレメトリポイントの折れ線グラフを提供すること\tいくつかのデータオブジェクトをプロットに追加する TG-2\tテレメトリグラファーはテレメトリのリアルタイムグラフ作成をサポートすること\tスタート(Start)を押してリアルタイムグラフ作成を開始する TG-3\tテレメトリグラファーはログに記録されたテレメトリからのデータのグラフ作成をサポートすること\tログデータからデータをグラフ化(Graph Data from Logged Data)するメニューオプションを選択する TG-4\tテレメトリグラファーはブラウザタブごとに複数のプロットをサポートすること\t複数のプロットを追加する TG-5\tテレメトリグラファーはプロットごとに複数のテレメトリポイントをサポートすること\t1つのプロットに複数のデータオブジェクトを追加する TG-6\tテレメトリグラファーは可変数のデータポイントの保存をサポートすること\t保存ポイントを編集する TG-7\tテレメトリグラファーは可変時間のグラフ作成をサポートすること\tプロット秒数を編集する TG-8\tテレメトリグラファーは可変数のデータポイントのグラフ作成をサポートすること\tプロットポイント数を編集する TG-9\tテレメトリグラファーは設定の保存をサポートすること\t現在の設定を保存する TG-10\tテレメトリグラファーは設定のロードをサポートすること\t前に保存した設定をロードする  ","version":"次へ","tagName":"h2"},{"title":"データエクストラクター​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#データエクストラクター","content":" データエクストラクターは、ログに記録されたデータを処理し、Excelやその他のツールで分析するためにCSV形式でデータを抽出します。  要件ID\t説明\tテスト説明DE-1\tデータエクストラクターは個別のテレメトリポイントの追加をサポートすること\t個別のテレメトリポイントを追加する DE-2\tデータエクストラクターはテレメトリパケット全体の追加をサポートすること\tパケット全体を追加する DE-3\tデータエクストラクターはテレメトリターゲット全体の追加をサポートすること\tターゲットのすべてのパケットを追加する DE-4\tデータエクストラクターは各テレメトリポイントに対して抽出する値タイプの選択をサポートすること (RAW, CONVERTED, FORMATTED, WITH_UNITS)\tアイテムをクリックして値タイプを変更する DE-5\tデータエクストラクターは設定の保存をサポートすること\tファイル(File)→設定の保存(Save Config)を選択する DE-6\tデータエクストラクターは設定のロードをサポートすること\tファイル(File)→設定のロード(Load Config)を選択する DE-7\tデータエクストラクターはアイテムの削除をサポートすること\tアイテムを選択して削除キーを押す  ","version":"次へ","tagName":"h2"},{"title":"データビューアー​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#データビューアー","content":" データビューアーは、他の表示方法が適さない場合にテレメトリパケットのテキスト表示を提供します。特にメモリダンプやログメッセージタイプのデータ表示に役立ちます。  要件ID\t説明\tテスト説明DV-1\tデータビューアーはテレメトリパケットのリアルタイム処理をサポートすること\tスタート(Start)を押してリアルタイム処理を開始する DV-2\tデータビューアーはテレメトリパケットのログ再生をサポートすること\t再生する時間範囲を選択する DV-3\tデータビューアーはテレメトリパケットのテキスト表示をサポートすること\tデータの表示を確認する DV-4\tデータビューアーはデータ表示のための複数のタブをサポートすること\tいくつかのデータタブ間を切り替える DV-5\tデータビューアーはタブの削除をサポートすること\tタブを削除する  ","version":"次へ","tagName":"h2"},{"title":"カレンダー​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#カレンダー","content":" カレンダーツールは、COSMOSでスケジュールされたアクションを開始するためのユーザーインターフェースとAPIを提供します  要件ID\t説明\tテスト説明TL-1\tカレンダーは新しいタイムラインの作成を可能にすること\tボタンをクリックして新しいタイムラインを作成する TL-2\tカレンダーは未来の実行のためのコマンドのスケジューリングを可能にすること\tタイムラインにコマンドを追加する TL-3\tカレンダーは未来の実行のためのスクリプトのスケジューリングを可能にすること\tタイムラインにスクリプトを追加する TL-4\tカレンダーはリソースの予約を可能にすること\tタイムラインに予約を追加する TL-5\tカレンダーはコマンドの成功または失敗を追跡すること\t完了したコマンドのステータスを確認する TL-6\tカレンダーはスクリプトの成功または失敗を追跡すること\t完了したスクリプトのステータスを確認する TL-7\tカレンダーはタイムラインからアクティビティの削除を可能にすること\tタイムラインから既存のアイテムを削除する TL-8\tカレンダーはタイムラインの削除を可能にすること\tタイムラインを削除する  ","version":"次へ","tagName":"h2"},{"title":"管理者（Admin）​","type":1,"pageTitle":"要件と設計","url":"/ja/docs/getting-started/requirements#管理者admin","content":" 管理者ツールは、COSMOSシステムのプラグイン管理を含む管理機能を提供します  要件ID\t説明\tテスト説明AD-1\t管理者ツールはプラグインのインストールを可能にすること\tプラグインをアップロードしてインストールする AD-2\t管理者ツールはプラグインのアップグレードをサポートすること\tインストール済みのプラグインをアップグレードする AD-3\t管理者ツールはプラグインのアンインストールをサポートすること\tプラグインをアンインストールする AD-4\t管理者ツールはインストールされたプラグインに関する情報を表示すること\tインターフェース、マイクロサービスなどの情報を表示する AD-5\t管理者ツールはマイクロサービスの編集をサポートすること\tマイクロサービスの設定を編集する AD-6\t管理者ツールはプラグインの検出をサポートすること\tプラグインを検出してダウンロードする AD-7\t管理者ツールは外部ツールへのリンク追加をサポートすること\tGoogleへのリンクを追加する AD-8\t管理者ツールはツールの並べ替えをサポートすること\tツールタブでツールを並べ替える AD-9\t管理者ツールは分類バーの設定をサポートすること\t設定タブに分類バーを追加する ","version":"次へ","tagName":"h2"},{"title":"コードジェネレーター","type":0,"sectionRef":"#","url":"/ja/docs/getting-started/generators","content":"","keywords":"","version":"次へ"},{"title":"プラグインジェネレーター​","type":1,"pageTitle":"コードジェネレーター","url":"/ja/docs/getting-started/generators#プラグインジェネレーター","content":" プラグインジェネレーターは、新しいCOSMOSプラグインのスキャフォールディング（構造）を作成します。プラグイン名が必要で、openc3-cosmos-&lt;name&gt;という新しいディレクトリを作成します。例えば：  % openc3.sh cli generate plugin Usage: cli generate plugin &lt;name&gt; % openc3.sh cli generate plugin GSE Plugin openc3-cosmos-gse successfully generated!   これにより以下のファイルが作成されます：  名前\t説明.gitignore\tgitにnode_modulesディレクトリを無視するよう指示します（ツール開発用） LICENSE.txt\tプラグインのライセンス。COSMOSプラグインは、COSMOS Enterprise版でのみ使用するように設計されていない限り、AGPLv3と互換性のある方法でライセンスされるべきです openc3-cosmos-gse.gemspec\t説明、作者、メール、ホームページなどのユーザー固有の情報を追加するために編集すべきGemspecファイル。このファイルの名前は、プラグインの内容を最終的な対応するgemファイルにコンパイルする際に使用されます（例：openc3-cosmos-gse-1.0.0.gem）。COSMOSプラグインは、Rubygemsリポジトリで簡単に識別できるように、常にopenc3-cosmos接頭で始める必要があります。このファイルは次の場所でドキュメント化されているフォーマットに従っています：https://guides.rubygems.org/specification-reference/ plugin.txt\tプラグイン作成のためのCOSMOS固有のファイル。詳細はこちらをご覧ください。 Rakefile\t&quot;openc3.sh cli rake build VERSION=X.X.X&quot;を実行してプラグインをビルドするように設定されたRuby Rakeファイル。X.X.Xはプラグインのバージョン番号です README.md\tプラグインを文書化するために使用されるMarkdownファイル requirements.txt\tPython依存関係ファイル（Pythonプラグインのみ）  この構造は必須ですが、それ自体ではあまり役に立ちません。プラグインジェネレーターは、他のジェネレーターが使用するフレームワークを作成するだけです。  ","version":"次へ","tagName":"h2"},{"title":"ターゲットジェネレーター​","type":1,"pageTitle":"コードジェネレーター","url":"/ja/docs/getting-started/generators#ターゲットジェネレーター","content":" ターゲットジェネレーターは、新しいCOSMOSターゲットの基本構造を作成します。既存のCOSMOSプラグイン内で動作する必要があり、ターゲット名が必要です。例えば：  openc3-cosmos-gse % openc3.sh cli generate target Usage: cli generate target &lt;n&gt; (--ruby or --python) openc3-cosmos-gse % openc3.sh cli generate target GSE Target GSE successfully generated!   これにより以下のファイルとディレクトリが作成されます：  名前\t説明targets/GSE\tGSEターゲットの設定を含みます。ターゲット名は常に大文字で定義されます。これは通常、ターゲットのデフォルト名ですが、適切に設計されたターゲットはインストール時に名前を変更できるようにします targets/GSE/cmd_tlm\tGSEターゲットのコマンドとテレメトリの定義ファイルを含みます。これらのファイルは、ターゲットに送信できるコマンドの形式と、COSMOSがターゲットから受信すると予想されるテレメトリパケットを捕捉します。デフォルトでは、このフォルダ内のファイルはアルファベット順に処理されることに注意してください。これは、別のファイルでパケットを参照する場合に重要になることがあります（すでに定義されている必要があります）。 targets/GSE/cmd_tlm/cmd.txt\tコマンド設定の例。ターゲット固有のコマンド用に編集する必要があります targets/GSE/cmd_tlm/tlm.txt\tテレメトリ設定の例。ターゲット固有のテレメトリ用に編集する必要があります targets/GSE/lib\tターゲットに必要なカスタムコードを含みます。カスタムコードの良い例としては、ライブラリファイル、カスタムインターフェースクラス、およびプロトコルがあります targets/GSE/lib/gse.rb/py\tターゲットの開発に伴って拡張できるライブラリファイルの例。COSMOSでは、コードの重複を避け、再利用を容易にするためにライブラリメソッドを構築することをお勧めします targets/GSE/procedures\tこのフォルダには、ターゲットの機能を実行するターゲット固有の手順とヘルパーメソッドが含まれています。これらの手順はシンプルに保ち、このターゲットに関連付けられたコマンドとテレメトリの定義のみを使用する必要があります。詳細については、スクリプト作成ガイドを参照してください。 targets/GSE/procedures/procedure.rb/py\tコマンドの送信とテレメトリのチェックの例を含む手順 targets/GSE/public\tCANVASIMAGEやCANVASIMAGEVALUEなどのテレメトリビューアのキャンバス画像ウィジェットで使用する画像ファイルをここに配置します targets/GSE/screens\tターゲット用のテレメトリ画面を含みます targets/GSE/screens/status.txt\tテレメトリ値を表示するための画面の例 targets/GSE/target.txt\tコマンドとテレメトリアイテムの無視やcmd/tlmファイルの処理方法などのターゲット設定  また、新しいターゲットを追加するためにplugin.txtファイルも更新されます：  VARIABLE gse_target_name GSE TARGET GSE &lt;%= gse_target_name %&gt; INTERFACE &lt;%= gse_target_name %&gt;_INT tcpip_client_interface.rb host.docker.internal 8080 8081 10.0 nil BURST MAP_TARGET &lt;%= gse_target_name %&gt;   ","version":"次へ","tagName":"h2"},{"title":"マイクロサービスジェネレーター​","type":1,"pageTitle":"コードジェネレーター","url":"/ja/docs/getting-started/generators#マイクロサービスジェネレーター","content":" マイクロサービスジェネレーターは、新しいCOSMOSマイクロサービスの基本構造を作成します。既存のCOSMOSプラグイン内で動作する必要があり、ターゲット名が必要です。例えば：  openc3-cosmos-gse % openc3.sh cli generate microservice Usage: cli generate microservice &lt;n&gt; (--ruby or --python) openc3-cosmos-gse % openc3.sh cli generate microservice background Microservice BACKGROUND successfully generated!   これにより以下のファイルとディレクトリが作成されます：  名前\t説明microservices/BACKGROUND\tBACKGROUNDマイクロサービスのコードと必要な設定を含みます。名前は常に大文字で定義されます。これは通常、マイクロサービスのデフォルト名ですが、適切に設計されたマイクロサービスはインストール時に名前を変更できるようにします microservices/BACKGROUND/background.rb\t毎分実行してメッセージをログに記録する完全に機能するマイクロサービス。バックグラウンドで実行したいカスタムロジックを実装するために編集します。潜在的な用途としては、複雑なイベントを確認して自律的に対応し、アクションを実行できる安全マイクロサービスがあります（注：単純なアクションはリミットレスポンスだけで十分かもしれません）  また、新しいマイクロサービスを追加するためにplugin.txtファイルも更新されます：  MICROSERVICE BACKGROUND background-microservice CMD ruby background.rb   ","version":"次へ","tagName":"h2"},{"title":"変換ジェネレーター​","type":1,"pageTitle":"コードジェネレーター","url":"/ja/docs/getting-started/generators#変換ジェネレーター","content":" 変換ジェネレーターは、新しいCOSMOS 変換(Conversion)の基本構造を作成します。既存のCOSMOSプラグイン内で動作する必要があり、ターゲット名と変換名の両方が必要です。例えば：  openc3-cosmos-gse % openc3.sh cli generate conversion Usage: cli generate conversion &lt;TARGET&gt; &lt;n&gt; (--ruby or --python) openc3-cosmos-gse % openc3.sh cli generate limits_response GSE double Conversion targets/GSE/lib/double_conversion.rb successfully generated! To use the conversion add the following to a telemetry item: READ_CONVERSION double_conversion.rb   これにより以下のファイルとディレクトリが作成されます：  名前\t説明targets/GSE/lib/double_conversion.rb\t既存のCOSMOS値を変換するためのcall()メソッドの実装例を持つ完全に機能する変換  ジェネレーターが述べているように、この変換コードを使用するにはテレメトリアイテムに追加する必要があります。例えば：  TELEMETRY GSE STATUS BIG_ENDIAN &quot;Telemetry description&quot; # Keyword Name BitSize Type ID Description APPEND_ID_ITEM ID 16 INT 1 &quot;Identifier&quot; APPEND_ITEM VALUE 32 FLOAT &quot;Value&quot; READ_CONVERSION double_conversion.rb APPEND_ITEM BOOL 8 UINT &quot;Boolean&quot; STATE FALSE 0 STATE TRUE 1 APPEND_ITEM LABEL 0 STRING &quot;The label to apply&quot;   ","version":"次へ","tagName":"h2"},{"title":"リミットレスポンスジェネレーター​","type":1,"pageTitle":"コードジェネレーター","url":"/ja/docs/getting-started/generators#リミットレスポンスジェネレーター","content":" リミットレスポンスジェネレーターは、新しいCOSMOS リミットレスポンスの基本構造を作成します。既存のCOSMOSプラグイン内で動作する必要があり、ターゲット名とリミットレスポンス名の両方が必要です。例えば：  openc3-cosmos-gse % openc3.sh cli generate limits_response Usage: cli generate limits_response &lt;TARGET&gt; &lt;n&gt; (--ruby or --python) openc3-cosmos-gse % openc3.sh cli generate limits_response GSE safe Limits response targets/GSE/lib/safe_limits_response.rb successfully generated! To use the limits response add the following to a telemetry item: LIMITS_RESPONSE safe_limits_response.rb   これにより以下のファイルとディレクトリが作成されます：  名前\t説明targets/GSE/lib/safe_limits_response.rb\t特定のアイテムの現在のリミット状態に基づいてアクションを実行するcall()メソッドの実装例を持つ完全に機能するリミットレスポンス  ジェネレーターが述べているように、このリミットコードを使用するには、リミットが定義されているテレメトリアイテムに追加する必要があります。生成されたGSEターゲットでは、リミットが定義されているアイテムがないため、まずリミットを追加してからレスポンスを追加する必要があります。  TELEMETRY GSE STATUS BIG_ENDIAN &quot;Telemetry description&quot; # Keyword Name BitSize Type ID Description APPEND_ID_ITEM ID 16 INT 1 &quot;Identifier&quot; APPEND_ITEM VALUE 32 FLOAT &quot;Value&quot; LIMITS DEFAULT 1 ENABLED -80.0 -70.0 60.0 80.0 -20.0 20.0 LIMITS_RESPONSE safe_limits_response.rb APPEND_ITEM BOOL 8 UINT &quot;Boolean&quot; STATE FALSE 0 STATE TRUE 1 APPEND_ITEM LABEL 0 STRING &quot;The label to apply&quot;   ","version":"次へ","tagName":"h2"},{"title":"ウィジェットジェネレーター​","type":1,"pageTitle":"コードジェネレーター","url":"/ja/docs/getting-started/generators#ウィジェットジェネレーター","content":" ウィジェットジェネレーターは、テレメトリビューアー画面で使用するための新しいCOSMOSウィジェットの基本構造を作成します。詳細については、カスタムウィジェットガイドを参照してください。既存のCOSMOSプラグイン内で動作する必要があり、ウィジェット名が必要です。例えば：  openc3-cosmos-gse % openc3.sh cli generate widget Usage: cli generate widget &lt;SuperdataWidget&gt; openc3-cosmos-gse % openc3.sh cli generate widget HelloworldWidget Widget HelloworldWidget successfully generated! Please be sure HelloworldWidget does not overlap an existing widget: https://docs.openc3.com/docs/configuration/telemetry-screens   これにより以下のファイルとディレクトリが作成されます：  名前\t説明src/HelloworldWidget.vue\tシンプルな値を表示する完全に機能するウィジェット。既存のCOSMOS Vue.jsコードを使用して拡張し、あらゆるデータ可視化を作成できます  また、新しいウィジェットを追加するためにplugin.txtファイルも更新されます：  WIDGET Helloworld   ","version":"次へ","tagName":"h2"},{"title":"ツールジェネレーター​","type":1,"pageTitle":"コードジェネレーター","url":"/ja/docs/getting-started/generators#ツールジェネレーター","content":" ツールジェネレーターは、新しいCOSMOSツールの基本構造を作成します。既存のCOSMOSプラグイン内で動作する必要があり、ツール名が必要です。カスタムツールの開発には、Vue.js、Angular、React、SvelteなどのJavascriptフレームワークに関する深い知識が必要です。すべてのCOSMOSツールはVue.jsで構築されているため、新しいツール開発には Vue.js が推奨されるフレームワークです。フロントエンド開発の詳細については、フロントエンドアプリケーションの実行を参照してください。  openc3-cosmos-gse % openc3.sh cli generate tool Usage: cli generate tool 'Tool Name' openc3-cosmos-gse % openc3.sh cli generate widget DataVis Tool datavis successfully generated! Please be sure datavis does not conflict with any other tools   これにより以下のファイルとディレクトリが作成されます：  名前\t説明src/App.vue\tアプリケーションをレンダリングするための基本的なVueテンプレート src/main.js\tVue、Vuetify、その他のライブラリをロードする新しいツールのエントリーポイント src/router.js\tVueコンポーネントルーター src/tools/datavis\tdatavisという名前のウェブベースのツールを提供するために必要なすべてのファイルを含みます。名前は常に小文字で定義されます。技術的な制限により、ツール名は一意である必要があり、インストール時に名前を変更することはできません。 src/tools/datavis/datavis.vue\tシンプルなボタンを表示する完全に機能するツール。既存のCOSMOS Vue.jsコードを使用して拡張し、想像可能なあらゆるツールを作成できます package.json\tビルドと依存関係の定義ファイル。npmまたはyarnがツールをビルドするために使用します vue.config.js\t開発環境でアプリケーションを提供し、アプリケーションをビルドするために使用されるVue設定ファイル &lt;dotfiles&gt;\tJavascriptフロントエンド開発用のフォーマッターやツールを設定するのに役立つ各種dotファイル  また、新しいツールを追加するためにplugin.txtファイルも更新されます。アイコンはここで見つかるマテリアルデザインアイコンの自由に変更できます。  TOOL datavis &quot;DataVis&quot; INLINE_URL main.js ICON mdi-file-cad-box  ","version":"次へ","tagName":"h2"},{"title":"インターフェース","type":0,"sectionRef":"#","url":"/ja/docs/configuration/interfaces","content":"","keywords":"","version":"次へ"},{"title":"概要​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#概要","content":" インターフェースは、ターゲットと呼ばれる外部の組み込みシステムへの接続です。インターフェースはplugin.txtファイル内のトップレベルのINTERFACEキーワードで定義されます。  インターフェースクラスは、COSMOSがターゲットからリアルタイムテレメトリを受信し、ターゲットにコマンドを送信するために使用するコードを提供します。ターゲットが使用するインターフェースは何でも可能であり（TCP/IP、シリアル、MQTT、SNMPなど）、これは再利用可能なコマンド・テレメトリシステムのカスタマイズ可能な部分であることが重要です。幸いなことに、最も一般的なインターフェース形式はTCP/IPソケット経由であり、COSMOSはこれらのインターフェースソリューションを提供します。このガイドでは、これらのインターフェースクラスの使用方法と、独自のインターフェースの作成方法について説明します。ほとんどの場合、新しいインターフェースを実装するのではなく、プロトコルでインターフェースを拡張できることに注意してください。  インターフェースとルーターは非常に似ています インターフェースとルーターは非常に似ており、同じ設定パラメータを共有していることに注意してください。ルーターは単に、既存のインターフェースのテレメトリデータを接続されたターゲットに送り出し、接続されたターゲットのコマンドを元のインターフェースのターゲットに戻すインターフェースです。  ","version":"次へ","tagName":"h2"},{"title":"プロトコル​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#プロトコル","content":" プロトコルは、パケット境界の区別やデータの必要に応じた変更など、インターフェースの動作を定義します。詳細についてはプロトコルを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"アクセサ​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#アクセサ","content":" アクセサはインターフェースによってターゲットに送信されるバッファの読み書きを担当します。詳細についてはアクセサを参照してください。  インターフェース、プロトコル、アクセサがどのように連携するかについての詳細は、標準なしの相互運用性を参照してください。  ","version":"次へ","tagName":"h3"},{"title":"提供されるインターフェース​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#提供されるインターフェース","content":" COSMOSは以下のインターフェースを提供しています：TCPIPクライアント、TCPIPサーバー、UDP、HTTPクライアント、HTTPサーバー、MQTTおよびシリアル。使用するインターフェースはINTERFACEおよびROUTERキーワードで定義されます。INTERFACEキーワードの後に続くキーワードの説明については、インターフェース修飾子を参照してください。  COSMOS Enterpriseは次のインターフェースを提供しています：SNMP、SNMPトラップ、GEMS、InfluxDB。  すべてのインターフェースオプション​  以下のオプションはすべてのインターフェースに適用されます。オプションは例に示すように、インターフェース定義の直下に追加されます。  オプション\t説明PERIODIC_CMD\t定期的な間隔で送信するコマンド。3つのパラメータを取ります：LOG/DONT_LOG、間隔（秒）、および実際のコマンド（文字列）。  例：  INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 10.0 # 'INST ABORT'コマンドを5秒ごとに送信し、CmdTlmServerメッセージにログを残さない # 注：すべてのコマンドはバイナリログに記録されます OPTION PERIODIC_CMD DONT_LOG 5.0 &quot;INST ABORT&quot; INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 10.0 # 'INST2 COLLECT with TYPE NORMAL'コマンドを10秒ごとに送信し、CmdTlmServerメッセージに出力する OPTION PERIODIC_CMD LOG 10.0 &quot;INST2 COLLECT with TYPE NORMAL&quot;   オプション\t説明CONNECT_CMD\tインターフェースが接続したときに送信するコマンド。2つのパラメータを取ります：LOG/DONT_LOGと実際のコマンド（文字列）。  例：  INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 10.0 # 接続時に'INST ABORT'コマンドを送信し、CmdTlmServerメッセージにログを残さない # 注：すべてのコマンドはバイナリログに記録されます OPTION CONNECT_CMD DONT_LOG &quot;INST ABORT&quot; INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 10.0 # 接続時に'INST2 COLLECT with TYPE NORMAL'を送信し、CmdTlmServerメッセージに出力する OPTION CONNECT_CMD LOG &quot;INST2 COLLECT with TYPE NORMAL&quot;   ","version":"次へ","tagName":"h2"},{"title":"TCPIPクライアントインターフェース​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#tcpipクライアントインターフェース","content":" TCPIPクライアントインターフェースはTCPIPソケットに接続してコマンドを送信し、テレメトリを受信します。このインターフェースは、ソケットを開いて接続を待機するターゲット用に使用されます。これは最も一般的なインターフェースタイプです。  パラメータ\t説明\t必須Host\t接続するマシン名\tはい Write Port\tコマンドを書き込むポート（読み取りポートと同じでも可）。nil / Noneを渡すとインターフェースは読み取り専用になります。\tはい Read Port\tテレメトリを読み取るポート（書き込みポートと同じでも可）。nil / Noneを渡すとインターフェースは書き込み専用になります。\tはい Write Timeout\t書き込みを中止するまで待機する秒数\tはい Read Timeout\t読み取りを中止するまで待機する秒数。nil / Noneを渡すと読み取りでブロックします。\tはい Protocol Type\tプロトコルを参照してください。\tいいえ Protocol Arguments\t各ストリームプロトコルが取る引数については、プロトコルを参照してください。\tいいえ  plugin.txt Rubyの例：  INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8081 10.0 nil LENGTH 0 16 0 1 BIG_ENDIAN 4 0xBA5EBA11 INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 nil BURST 4 0xDEADBEEF INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 nil FIXED 6 0 nil true INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 10.0 TERMINATED 0x0D0A 0x0D0A true 0 0xF005BA11 INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 10.0 TEMPLATE 0xA 0xA INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 nil PREIDENTIFIED 0xCAFEBABE INTERFACE INTERFACE_NAME tcpip_client_interface.rb host.docker.internal 8080 8080 10.0 10.0 # ビルトインプロトコルなし   plugin.txt Pythonの例：  INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8081 10.0 None LENGTH 0 16 0 1 BIG_ENDIAN 4 0xBA5EBA11 INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 None BURST 4 0xDEADBEEF INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 None FIXED 6 0 None true INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 10.0 TERMINATED 0x0D0A 0x0D0A true 0 0xF005BA11 INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 10.0 TEMPLATE 0xA 0xA INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 None PREIDENTIFIED 0xCAFEBABE INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8080 10.0 10.0 # ビルトインプロトコルなし   ","version":"次へ","tagName":"h3"},{"title":"TCPIPサーバーインターフェース​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#tcpipサーバーインターフェース","content":" TCPIPサーバーインターフェースはTCPIPサーバーを作成し、着信接続をリッスンして、ターゲットと通信するソケットを動的に作成します。このインターフェースは、ソケットを開いてサーバーに接続しようとするターゲット用に使用されます。  注意：内部dockerネットワーク外からの接続を受け入れるには、compose.yamlファイルでTCPポートを公開する必要があります。例えば、ポート8080での接続を許可するには、openc3-operatorセクションを見つけて次の例のように変更します：  openc3-operator: ports: - &quot;127.0.0.1:8080:8080&quot; # tcpポート8080を開く   パラメータ\t説明\t必須Write Port\tコマンドを書き込むポート（読み取りポートと同じでも可）\tはい Read Port\tテレメトリを読み取るポート（書き込みポートと同じでも可）\tはい Write Timeout\t書き込みを中止するまで待機する秒数\tはい Read Timeout\t読み取りを中止するまで待機する秒数。nil / Noneを渡すと読み取りでブロックします。\tはい Protocol Type\tプロトコルを参照してください。\tいいえ Protocol Arguments\t各ストリームプロトコルが取る引数については、プロトコルを参照してください。\tいいえ  インターフェースオプション​  オプションは例に示すように、インターフェース定義の直下に追加されます。  オプション\t説明\tデフォルトLISTEN_ADDRESS\t接続を受け付けるIPアドレス\t0.0.0.0  plugin.txt Rubyの例：  INTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8081 10.0 nil LENGTH 0 16 0 1 BIG_ENDIAN 4 0xBA5EBA11 INTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 nil BURST 4 0xDEADBEEF INTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 nil FIXED 6 0 nil true INTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 10.0 TERMINATED 0x0D0A 0x0D0A true 0 0xF005BA11 INTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 10.0 TEMPLATE 0xA 0xA INTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 nil PREIDENTIFIED 0xCAFEBABE INTERFACE INTERFACE_NAME tcpip_server_interface.rb 8080 8080 10.0 10.0 # ビルトインプロトコルなし OPTION LISTEN_ADDRESS 127.0.0.1   plugin.txt Pythonの例：  INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8081 10.0 None LENGTH 0 16 0 1 BIG_ENDIAN 4 0xBA5EBA11 INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 None BURST 4 0xDEADBEEF INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 None FIXED 6 0 None true INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 10.0 TERMINATED 0x0D0A 0x0D0A true 0 0xF005BA11 INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 10.0 TEMPLATE 0xA 0xA INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 None PREIDENTIFIED 0xCAFEBABE INTERFACE INTERFACE_NAME openc3/interfaces/tcpip_server_interface.py 8080 8080 10.0 10.0 # ビルトインプロトコルなし   ","version":"次へ","tagName":"h3"},{"title":"UDPインターフェース​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#udpインターフェース","content":" UDPインターフェースはUDPパケットを使用してターゲットとの間でコマンドの送信とテレメトリの受信を行います。  注意：内部dockerネットワーク外からUDPパケットを受信するには、compose.yamlファイルでUDPポートを公開する必要があります。例えば、ポート8081でUDPパケットを許可するには、openc3-operatorセクションを見つけて次の例のように変更します：  openc3-operator: ports: - &quot;127.0.0.1:8081:8081/udp&quot; # udpポート8081を開く   パラメータ\t説明\t必須\tデフォルトHost\tデータの送受信を行うマシンのホスト名またはIPアドレス\tはい Write Dest Port\tコマンドを送信するリモートマシン上のポート\tはい Read Port\tテレメトリを読み取るリモートマシン上のポート\tはい Write Source Port\tコマンドを送信するローカルマシン上のポート\tいいえ\tnil (ソケットは発信ポートにバインドされない) Interface Address\tリモートマシンがマルチキャストをサポートしている場合、インターフェースアドレスは発信マルチキャストアドレスを設定するために使用されます\tいいえ\tnil (使用されない) TTL\tTime to Live。パケットを破棄する前に許可される中間ルーターの数。\tいいえ\t128 (Windows) Write Timeout\t書き込みを中止するまで待機する秒数\tいいえ\t10.0 Read Timeout\t読み取りを中止するまで待機する秒数\tいいえ\tnil (読み取りでブロック)  plugin.txt Rubyの例：  INTERFACE INTERFACE_NAME udp_interface.rb host.docker.internal 8080 8081 8082 nil 128 10.0 nil   plugin.txt Pythonの例：  INTERFACE INTERFACE_NAME openc3/interfaces/udp_interface.py host.docker.internal 8080 8081 8082 None 128 10.0 None   ","version":"次へ","tagName":"h3"},{"title":"HTTPクライアントインターフェース​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#httpクライアントインターフェース","content":" HTTPクライアントインターフェースはHTTPサーバーに接続してコマンドを送信し、テレメトリを受信します。このインターフェースはHttpAccessorおよびJsonAccessorと共に使用されることが一般的です。詳細についてはopenc3-cosmos-http-exampleを参照してください。  パラメータ\t説明\t必須\tデフォルトHost\t接続するマシン名\tはい Port\tコマンドを書き込み、テレメトリを読み取るポート\tいいえ\t80 Protocol\tHTTPまたはHTTPSプロトコル\tいいえ\tHTTP Write Timeout\t書き込みを中止するまで待機する秒数。nil / Noneを渡すと書き込みでブロックします。\tいいえ\t5 Read Timeout\t読み取りを中止するまで待機する秒数。nil / Noneを渡すと読み取りでブロックします。\tいいえ\tnil / None Connect Timeout\t接続を中止するまで待機する秒数\tいいえ\t5 Include Request In Response\tリクエストを追加データに含めるかどうか\tいいえ\tfalse  plugin.txt Rubyの例：  INTERFACE INTERFACE_NAME http_client_interface.rb myserver.com 80   plugin.txt Pythonの例：  INTERFACE INTERFACE_NAME openc3/interfaces/http_client_interface.py mysecure.com 443 HTTPS   ","version":"次へ","tagName":"h3"},{"title":"HTTPサーバーインターフェース​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#httpサーバーインターフェース","content":" HTTPサーバーインターフェースは、シンプルな暗号化されていない、認証されていないHTTPサーバーを作成します。このインターフェースはHttpAccessorおよびJsonAccessorと共に使用されることが一般的です。詳細についてはopenc3-cosmos-http-exampleを参照してください。  パラメータ\t説明\t必須\tデフォルトPort\tコマンドを書き込み、テレメトリを読み取るポート\tいいえ\t80  インターフェースオプション​  オプションは例に示すように、インターフェース定義の直下に追加されます。  オプション\t説明\tデフォルトLISTEN_ADDRESS\t接続を受け付けるIPアドレス\t0.0.0.0  plugin.txt Rubyの例：  INTERFACE INTERFACE_NAME http_server_interface.rb LISTEN_ADDRESS 127.0.0.1   plugin.txt Pythonの例：  INTERFACE INTERFACE_NAME openc3/interfaces/http_server_interface.py 88   ","version":"次へ","tagName":"h3"},{"title":"MQTTインターフェース​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#mqttインターフェース","content":" MQTTインターフェースは一般的にIoT（Internet of Things）デバイスとの接続に使用されます。COSMOS MQTTインターフェースはメッセージ（コマンドとテレメトリ）の公開と受信の両方ができるクライアントです。SSL証明書と認証のためのサポートが組み込まれています。MQTTストリーミングインターフェースとは、コマンドとテレメトリがコマンドとテレメトリの定義でMETA TOPICで指定されたトピックを介して送信される点が異なります。  パラメータ\t説明\t必須\tデフォルトHost\tMQTTブローカーのホスト名またはIPアドレス\tはい Port\t接続するMQTTブローカー上のポート。SSLを使用するかどうかを考慮してください。\tいいえ\t1883 SSL\t接続にSSLを使用するかどうか\tいいえ\tfalse  インターフェースオプション​  オプションは例に示すように、インターフェース定義の直下に追加されます。  オプション\t説明ACK_TIMEOUT\tMQTTブローカーに接続するときに待機する時間 USERNAME\tMQTTブローカーとの認証用のユーザー名 PASSWORD\tMQTTブローカーとの認証用のパスワード CERT\tクライアントTLSベースの認証にKEYと共に使用されるPEMエンコードされたクライアント証明書ファイル名 KEY\tPEMエンコードされたクライアント秘密鍵ファイル名 KEYFILE_PASSWORD\tCERTとKEYファイルを復号化するためのパスワード（Pythonのみ） CA_FILE\tこのクライアントが信頼すべき認証局証明書ファイル名  plugin.txt Rubyの例：  INTERFACE MQTT_INT mqtt_interface.rb test.mosquitto.org 1883   plugin.txt Pythonの例（注：この例ではSECRETキーワードを使用してインターフェースのPASSWORDオプションを設定しています）：  INTERFACE MQTT_INT openc3/interfaces/mqtt_interface.py test.mosquitto.org 8884 OPTION USERNAME rw # PASSWORDという名前のシークレットでMQTT_PASSWORDという環境変数を作成し、 # シークレット値を持つPASSWORDというオプションを設定します # シークレットの詳細については、管理ツールのページを参照してください SECRET ENV PASSWORD MQTT_PASSWORD PASSWORD   パケット定義​  MQTTインターフェースはコマンドとテレメトリの定義ファイルで「META TOPIC &lt;トピック名&gt;」を利用して、メッセージを公開および受信するトピックを決定します。したがって、「TEST」というトピックに送信するには、次のようなコマンドを作成します（注：コマンド名「TEST」はトピック名と一致する必要はありません）：  COMMAND MQTT TEST BIG_ENDIAN &quot;Test&quot; META TOPIC TEST # &lt;- トピック名は'TEST' APPEND_PARAMETER DATA 0 BLOCK '' &quot;MQTT Data&quot;   同様に、「TEST」というトピックから受信するには、次のようなテレメトリパケットを作成します（注：テレメトリ名「TEST」はトピック名と一致する必要はありません）：  TELEMETRY MQTT TEST BIG_ENDIAN &quot;Test&quot; META TOPIC TEST # &lt;- トピック名は'TEST' APPEND_ITEM DATA 0 BLOCK &quot;MQTT Data&quot;   完全な例については、COSMOSソースのopenc3-cosmos-mqtt-testを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"MQTTストリーミングインターフェース​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#mqttストリーミングインターフェース","content":" MQTTストリーミングインターフェースは一般的にIoT（Internet of Things）デバイスとの接続に使用されます。COSMOS MQTTストリーミングインターフェースはメッセージ（コマンドとテレメトリ）の公開と受信の両方ができるクライアントです。SSL証明書と認証のためのサポートが組み込まれています。MQTTインターフェースとは、すべてのコマンドが単一のトピックで送信され、すべてのテレメトリが単一のトピックで受信される点が異なります。  パラメータ\t説明\t必須\tデフォルトHost\tMQTTブローカーのホスト名またはIPアドレス\tはい Port\t接続するMQTTブローカー上のポート。SSLを使用するかどうかを考慮してください。\tいいえ\t1883 SSL\t接続にSSLを使用するかどうか\tいいえ\tfalse Write Topic\tすべてのコマンド用の書き込みトピック名。nil / Noneを渡すとインターフェースは読み取り専用になります。\tいいえ\tnil / None Read Topic\tすべてのテレメトリ用の読み取りトピック名。nil / Noneを渡すとインターフェースは書き込み専用になります。\tいいえ\tnil / None Protocol Type\tプロトコルを参照してください。\tいいえ Protocol Arguments\t各ストリームプロトコルが取る引数については、プロトコルを参照してください。\tいいえ\t  インターフェースオプション​  オプションは例に示すように、インターフェース定義の直下に追加されます。  オプション\t説明ACK_TIMEOUT\tMQTTブローカーに接続するときに待機する時間 USERNAME\tMQTTブローカーとの認証用のユーザー名 PASSWORD\tMQTTブローカーとの認証用のパスワード CERT\tクライアントTLSベースの認証にKEYと共に使用されるPEMエンコードされたクライアント証明書ファイル名 KEY\tPEMエンコードされたクライアント秘密鍵ファイル名 KEYFILE_PASSWORD\tCERTとKEYファイルを復号化するためのパスワード（Pythonのみ） CA_FILE\tこのクライアントが信頼すべき認証局証明書ファイル名  plugin.txt Rubyの例：  INTERFACE MQTT_INT mqtt_stream_interface.rb test.mosquitto.org 1883 false write read   plugin.txt Pythonの例（注：この例ではSECRETキーワードを使用してインターフェースのPASSWORDオプションを設定しています）：  INTERFACE MQTT_INT openc3/interfaces/mqtt_stream_interface.py test.mosquitto.org 8884 False write read OPTION USERNAME rw # PASSWORDという名前のシークレットでMQTT_PASSWORDという環境変数を作成し、 # シークレット値を持つPASSWORDというオプションを設定します # シークレットの詳細については、管理ツールのページを参照してください SECRET ENV PASSWORD MQTT_PASSWORD PASSWORD   パケット定義​  MQTTストリーミングインターフェースはインターフェースに渡されたトピック名を使用するため、定義に追加情報は必要ありません。  完全な例については、COSMOSソースのopenc3-cosmos-mqtt-testを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"シリアルインターフェース​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#シリアルインターフェース","content":" シリアルインターフェースはシリアルポート経由でターゲットに接続します。COSMOSはWindowsとUNIXベースのシステム用のPOSIXドライバの両方を提供しています。シリアルインターフェースは現在Rubyでのみ実装されています。  パラメータ\t説明\t必須Write Port\t書き込み用のシリアルポート名（例：'COM1'または'/dev/ttyS0'）。nil / Noneを渡すと書き込みを無効にします。\tはい Read Port\t読み取り用のシリアルポート名（例：'COM1'または'/dev/ttyS0'）。nil / Noneを渡すと読み取りを無効にします。\tはい Baud Rate\t読み書きに使用するボーレート\tはい Parity\tシリアルポートのパリティ。'NONE'、'EVEN'、'ODD'のいずれかでなければなりません。\tはい Stop Bits\tストップビット数（例：1）\tはい Write Timeout\t書き込みを中止するまで待機する秒数\tはい Read Timeout\t読み取りを中止するまで待機する秒数。nil / Noneを渡すと読み取りでブロックします。\tはい Protocol Type\tプロトコルを参照してください。\tいいえ Protocol Arguments\t各ストリームプロトコルが取る引数については、プロトコルを参照してください。\tいいえ  インターフェースオプション​  オプションは例に示すように、インターフェース定義の直下に追加されます。  オプション\t説明\tデフォルトFLOW_CONTROL\tシリアルポートのフロー制御。NONEまたはRTSCTSのいずれかでなければなりません。\tNONE DATA_BITS\tデータビット数\t8  plugin.txt Rubyの例：  INTERFACE INTERFACE_NAME serial_interface.rb COM1 COM1 9600 NONE 1 10.0 nil LENGTH 0 16 0 1 BIG_ENDIAN 4 0xBA5EBA11 INTERFACE INTERFACE_NAME serial_interface.rb /dev/ttyS1 /dev/ttyS1 38400 ODD 1 10.0 nil BURST 4 0xDEADBEEF INTERFACE INTERFACE_NAME serial_interface.rb COM2 COM2 19200 EVEN 1 10.0 nil FIXED 6 0 nil true INTERFACE INTERFACE_NAME serial_interface.rb COM4 COM4 115200 NONE 1 10.0 10.0 TERMINATED 0x0D0A 0x0D0A true 0 0xF005BA11 INTERFACE INTERFACE_NAME serial_interface.rb COM4 COM4 115200 NONE 1 10.0 10.0 TEMPLATE 0xA 0xA INTERFACE INTERFACE_NAME serial_interface.rb /dev/ttyS0 /dev/ttyS0 57600 NONE 1 10.0 nil PREIDENTIFIED 0xCAFEBABE INTERFACE INTERFACE_NAME serial_interface.rb COM4 COM4 115200 NONE 1 10.0 10.0 # ビルトインプロトコルなし OPTION FLOW_CONTROL RTSCTS OPTION DATA_BITS 7   ","version":"次へ","tagName":"h3"},{"title":"SNMPインターフェース（Enterprise）​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#snmpインターフェースenterprise","content":" SNMPインターフェースは簡易ネットワーク管理プロトコルデバイスへの接続用です。SNMPインターフェースは現在Rubyでのみ実装されています。  パラメータ\t説明\t必須\tデフォルトHost\tSNMPデバイスのホスト名\tはい Port\tSNMPデバイス上のポート\tいいえ\t161  インターフェースオプション​  オプションは例に示すように、インターフェース定義の直下に追加されます。  オプション\t説明\tデフォルトVERSION\tSNMPバージョン：1、2、または3\t1 COMMUNITY\tデバイスへのアクセスを許可するパスワードやユーザーID\tprivate USERNAME\tユーザー名\tN/A RETRIES\tリクエスト送信時の再試行回数\tN/A TIMEOUT\tエージェントからの応答を待つタイムアウト\tN/A CONTEXT\tSNMPコンテキスト\tN/A SECURITY_LEVEL\tNO_AUTH、AUTH_PRIV、AUTH_NO_PRIVのいずれかでなければなりません\tN/A AUTH_PROTOCOL\tMD5、SHA、SHA256のいずれかでなければなりません\tN/A PRIV_PROTOCOL\tDESまたはAESのいずれかでなければなりません\tN/A AUTH_PASSWORD\t認証パスワード\tN/A PRIV_PASSWORD\tプライバシーパスワード\tN/A  plugin.txt Rubyの例：  INTERFACE SNMP_INT snmp_interface.rb 192.168.1.249 161 OPTION VERSION 1   完全な例については、COSMOS Enterpriseプラグインのopenc3-cosmos-apc-switched-pduを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"SNMPトラップインターフェース（Enterprise）​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#snmpトラップインターフェースenterprise","content":" SNMPトラップインターフェースは簡易ネットワーク管理プロトコルトラップを受信するためのものです。SNMPトラップインターフェースは現在Rubyでのみ実装されています。  パラメータ\t説明\t必須\tデフォルトRead Port\t読み取り元のポート\tいいえ\t162 Read Timeout\t読み取りタイムアウト\tいいえ\tnil Bind Address\tUDPポートをバインドするアドレス\tはい\t0.0.0.0  インターフェースオプション​  オプションは例に示すように、インターフェース定義の直下に追加されます。  オプション\t説明\tデフォルトVERSION\tSNMPバージョン：1、2、または3\t1  plugin.txt Rubyの例：  INTERFACE SNMP_INT snmp_trap_interface.rb 162 OPTION VERSION 1   完全な例については、COSMOS Enterpriseプラグインのopenc3-cosmos-apc-switched-pduを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"gRPC Interface (Enterprise)​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#grpc-interface-enterprise","content":" gRPCインターフェースはgRPCと対話するためのものです。gRPCインターフェースは現在Rubyでのみ実装されています。  パラメータ\t説明\t必須Hostname\tgRPCサーバー\tはい Port\tgRPCポート\tはい  plugin.txt Rubyの例：  INTERFACE GRPC_INT grpc_interface.rb my.grpc.org 8080   コマンド​  GrpcInterfaceをコマンド定義に使用するには、各コマンドに使用するGRPC_METHODを定義するためにMETAを使用する必要があります。  COMMAND PROTO GET_USER BIG_ENDIAN 'Get a User' META GRPC_METHOD /example.photoservice.ExamplePhotoService/GetUser   完全な例については、COSMOS Enterpriseプラグインのopenc3-cosmos-proto-targetを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"カスタムインターフェース​","type":1,"pageTitle":"インターフェース","url":"/ja/docs/configuration/interfaces#カスタムインターフェース","content":" インターフェースには、実装する必要のある以下のメソッドがあります：  connect - ソケットやポートを開いたり、ターゲットへの接続を確立したりします。注意：このメソッドは無期限にブロックすることはできません。実装内でsuper()を呼び出すことを忘れないでください。connected? - 接続状態に応じてtrueまたはfalseを返します。注意：このメソッドはすぐに戻る必要があります。disconnect - ソケットやポートを閉じたり、ターゲットから切断したりします。注意：このメソッドは無期限にブロックすることはできません。実装内でsuper()を呼び出すことを忘れないでください。read_interface - インターフェース上のデータの最低レベルの読み取り。注意：このメソッドはデータが利用可能になるか、インターフェースが切断されるまでブロックする必要があります。クリーンな切断の場合はnilを返す必要があります。write_interface - インターフェース上のデータの最低レベルの書き込み。注意：このメソッドは無期限にブロックすることはできません。  インターフェースには以下のメソッドも存在し、デフォルト実装があります。必要に応じてオーバーライドできますが、デフォルト実装が実行されるようにsuper()を呼び出すことを忘れないでください。  read_interface_base - このメソッドは常にread_interface()から呼び出されるべきです。読み取ったバイト数、最近読み取られた生データなど、CmdTLmServerに表示されるインターフェース固有の変数を更新し、有効な場合は生ロギングを処理します。write_interface_base - このメソッドは常にwrite_interface()から呼び出されるべきです。書き込んだバイト数、最近書き込まれた生データなど、CmdTLmServerに表示されるインターフェース固有の変数を更新し、有効な場合は生ロギングを処理します。read - インターフェースから次のパケットを読み取ります。COSMOSはこのメソッドを実装して、返される前にプロトコルシステムがデータとパケットを操作できるようにします。write - パケットをインターフェースに送信します。COSMOSはこのメソッドを実装して、送信される前にプロトコルシステムがパケットとデータを操作できるようにします。write_raw - 生のバイナリデータ文字列をターゲットに送信します。COSMOSはこのメソッドを実装して、基本的に生データでwrite_interfaceを呼び出します。  命名規則 独自のインターフェースを作成する場合、ほとんどの場合、以下に説明する組み込みインターフェースのサブクラスになります。インターフェースファイルのファイル名とクラス名は、大文字と小文字を正確に一致させる必要があることを知っておくことが重要です。そうしないと、新しいインターフェースをロードしようとするときに「クラスが見つかりません」というエラーが発生します。例えば、labview_interface.rbというインターフェースファイルには、LabviewInterfaceというクラスが含まれている必要があります。例えば、クラスがLabVIEWInterfaceという名前だった場合、予期しない大文字と小文字のためにCOSMOSはクラスを見つけることができません。 ","version":"次へ","tagName":"h2"},{"title":"プラグイン","type":0,"sectionRef":"#","url":"/ja/docs/configuration/plugins","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#はじめに","content":" このドキュメントは、COSMOSプラグインを設定するために必要な情報を提供します。プラグインはCOSMOSを設定および拡張する方法です。  プラグインでは、ターゲット（およびそれに対応するコマンドとテレメトリパケット定義）を定義し、ターゲットと通信するために必要なインターフェースを設定し、COSMOSから生データをストリームするためのルーターを定義し、COSMOSユーザーインターフェースに新しいツールを追加する方法、そして新しい機能を提供するための追加のマイクロサービスを実行する方法を定義します。  各プラグインはRubyのgemとして構築されるため、プラグインをビルドするためのplugin.gemspecファイルを持っています。プラグインには、プラグインで使用されるすべての変数と、それに含まれるターゲットへのインターフェース方法を宣言するplugin.txtファイルがあります。  ","version":"次へ","tagName":"h2"},{"title":"概念​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#概念","content":" ","version":"次へ","tagName":"h2"},{"title":"TARGET​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#target","content":" ターゲットは、COSMOSが通信する外部のハードウェアやソフトウェアです。これらは、フロントエンドプロセッサ（FEP）、地上支援機器（GSE）、カスタムソフトウェアツール、衛星自体などのハードウェアなどです。ターゲットは、COSMOSがコマンドを送信し、テレメトリを受信できるものです。  ","version":"次へ","tagName":"h3"},{"title":"INTERFACE​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#interface","content":" インターフェースは、1つ以上のターゲットへの物理的な接続を実装します。通常、TCPやUDPを使用したイーサネット接続ですが、シリアルポートなどの他の接続も可能です。インターフェースはターゲットにコマンドを送信し、ターゲットからテレメトリを受信します。  ","version":"次へ","tagName":"h3"},{"title":"ROUTER​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#router","content":" ルーターは、テレメトリパケットのストリームをCOSMOSから流出させ、コマンドのストリームをCOSMOSに受信します。コマンドはCOSMOSによって関連するインターフェースに転送されます。テレメトリは関連するインターフェースから来ます。  ","version":"次へ","tagName":"h3"},{"title":"TOOL​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#tool","content":" COSMOSツールは、テレメトリの表示、コマンドの送信、スクリプトの実行などのタスクを実行するためにCOSMOS APIと通信するウェブベースのアプリケーションです。  ","version":"次へ","tagName":"h3"},{"title":"MICROSERVICE​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#microservice","content":" マイクロサービスは、COSMOS環境内で実行される永続的なバックエンドコードです。データを処理し、その他の有用なタスクを実行できます。  ","version":"次へ","tagName":"h3"},{"title":"プラグインのディレクトリ構造​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#プラグインのディレクトリ構造","content":" COSMOSプラグインには、コードジェネレーターのドキュメントに詳細に記載されている、明確に定義されたディレクトリ構造があります。  ","version":"次へ","tagName":"h2"},{"title":"plugin.txt設定ファイル​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#plugintxt-configuration-file","content":" plugin.txt設定ファイルは、すべてのCOSMOSプラグインに必要です。これはプラグインの内容を宣言し、プラグインが最初にインストールまたはアップグレードされるときに設定できる変数を提供します。 このファイルは、キーワードの後に0個以上のスペース区切りのパラメータが続く標準のCOSMOS設定ファイル形式に従っています。plugin.txt設定ファイルでサポートされる以下のキーワードがあります：  ","version":"次へ","tagName":"h2"},{"title":"VARIABLE​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#variable","content":" プラグインの設定可能な変数を定義する  VARIABLEキーワードは、プラグインのインストール中にユーザーが入力を求められる変数を定義します。変数は、特定のIPアドレスやポートなど、ユーザーが定義するターゲットの詳細を処理するために使用できます。また、変数は、ユーザーがターゲットを好きな名前に変更し、同じターゲットを異なる名前で複数インストールすることをサポートするためにも使用する必要があります。変数は、Ruby ERB構文を使用してplugin.txtまたはプラグインに含まれる他の設定ファイルで後で使用できます。変数はファイル内のアクセス可能なローカル変数に割り当てられます。高レベルでは、ERBを使用すると設定ファイル内でRubyコードを実行できます。  パラメータ\t説明\t必須Variable Name\t変数の名前\tTrue Default Value\t変数のデフォルト値\tTrue  ","version":"次へ","tagName":"h2"},{"title":"NEEDS_DEPENDENCIES​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#needs_dependencies","content":"  (Since 5.5.0) プラグインが依存関係を必要とし、GEM_HOME環境変数を設定することを示す   プラグインにトップレベルのlibフォルダがある場合、またはgemspecにランタイム依存関係がリストされている場合、NEEDS_DEPENDENCIESは実質的に既に設定されています。Enterprise版では、NEEDS_DEPENDENCIESを持つことで、KubernetesポッドにNFSボリュームマウントが追加されることに注意してください。  ","version":"次へ","tagName":"h2"},{"title":"INTERFACE​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#interface-1","content":" 物理的なターゲットへの接続を定義する  インターフェースは、OpenC3が特定のハードウェアと通信するために使用するものです。インターフェースには、ハードウェアと通信するために必要なすべてのインターフェースメソッドを実装するRubyまたはPythonファイルが必要です。OpenC3は多くの組み込みインターフェースを定義していますが、インターフェースプロトコルを実装する限り、独自のインターフェースを定義することもできます。  パラメータ\t説明\t必須Interface Name\tインターフェースの名前。この名前はサーバーのインターフェースタブに表示され、他のキーワードからも参照されます。OpenC3の慣例では、インターフェースにはターゲットの名前に '_INT' を付けた名前を付けます。例えば、INSTターゲットの場合は INST_INT です。\tTrue Filename\tインターフェースをインスタンス化する際に使用するRubyまたはPythonファイル。 有効な値: tcpip_client_interface, tcpip_server_interface, udp_interface, serial_interface\tTrue  追加のパラメータが必要です。詳細については、インターフェースのドキュメントを参照してください。  ","version":"次へ","tagName":"h2"},{"title":"INTERFACE MODIFIERS​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#interface-modifiers","content":" 以下のキーワードはINTERFACEキーワードに続いて使用する必要があります。  ","version":"次へ","tagName":"h2"},{"title":"MAP_TARGET​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#map_target","content":" ターゲット名をインターフェースにマッピングする  パラメータ\t説明\t必須Target Name\tこのインターフェースにマッピングするターゲット名\tTrue  Rubyの例:  INTERFACE DATA_INT tcpip_client_interface.rb host.docker.internal 8080 8081 10.0 nil BURST MAP_TARGET DATA   Pythonの例:  INTERFACE DATA_INT openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8081 10.0 nil BURST MAP_TARGET DATA   ","version":"次へ","tagName":"h3"},{"title":"MAP_CMD_TARGET​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#map_cmd_target","content":"  (Since 5.2.0) コマンド専用のターゲット名をインターフェースにマッピングする   パラメータ\t説明\t必須Target Name\tこのインターフェースにマッピングするコマンドターゲット名\tTrue  Rubyの例:  INTERFACE CMD_INT tcpip_client_interface.rb host.docker.internal 8080 8081 10.0 nil BURST MAP_CMD_TARGET DATA # DATAコマンドのみがCMD_INTインターフェースで送信される   Pythonの例:  INTERFACE CMD_INT openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8081 10.0 nil BURST MAP_CMD_TARGET DATA # DATAコマンドのみがCMD_INTインターフェースで送信される   ","version":"次へ","tagName":"h3"},{"title":"MAP_TLM_TARGET​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#map_tlm_target","content":"  (Since 5.2.0) テレメトリ専用のターゲット名をインターフェースにマッピングする   パラメータ\t説明\t必須Target Name\tこのインターフェースにマッピングするテレメトリターゲット名\tTrue  Rubyの例:  INTERFACE TLM_INT tcpip_client_interface.rb host.docker.internal 8080 8081 10.0 nil BURST MAP_TLM_TARGET DATA # DATAテレメトリのみがTLM_INTインターフェースで受信される   Pythonの例:  INTERFACE TLM_INT openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8081 10.0 nil BURST MAP_TLM_TARGET DATA # DATAテレメトリのみがTLM_INTインターフェースで受信される   ","version":"次へ","tagName":"h3"},{"title":"DONT_CONNECT​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#dont_connect","content":" サーバーは起動時にインターフェースに自動的に接続しようとしない  ","version":"次へ","tagName":"h3"},{"title":"DONT_RECONNECT​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#dont_reconnect","content":" 接続が失われた場合、サーバーはインターフェースに再接続しようとしない  ","version":"次へ","tagName":"h3"},{"title":"RECONNECT_DELAY​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#reconnect_delay","content":" 再接続の遅延（秒）  DONT_RECONNECTが存在しない場合、接続が失われるとサーバーはインターフェースへの再接続を試みます。再接続遅延は、再接続試行の間隔を秒単位で設定します。  パラメータ\t説明\t必須Delay\t再接続試行の間隔（秒）。デフォルトは15秒です。\tTrue  ","version":"次へ","tagName":"h3"},{"title":"DISABLE_DISCONNECT​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#disable_disconnect","content":" サーバーのインターフェースタブの切断ボタンを無効にする  このキーワードを使用して、ユーザーがインターフェースから切断できないようにします。これは通常、ユーザーが誤ってターゲットから切断することを防ぎたい「本番」環境で使用されます。  ","version":"次へ","tagName":"h3"},{"title":"LOG_RAW​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#log_raw","content":" 非推奨、LOG_STREAMを使用してください  ","version":"次へ","tagName":"h3"},{"title":"LOG_STREAM​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#log_stream","content":"  (Since 5.5.2) インターフェースのすべてのデータを送受信されたままの形式で記録する   LOG_STREAMはOpenC3ヘッダーを追加しないため、OpenC3ツールで読み取ることはできません。主にインターフェースの低レベルデバッグに役立ちます。これらのログは、16進エディタなどのアプリケーションを使用して手動で解析する必要があります。  パラメータ\t説明\t必須Cycle Time\tログファイルをサイクルする前に待機する時間。デフォルトは10分。nilの場合はCycle HourとCycle Minuteを参照します。\tFalse Cycle Size\tログファイルをサイクルする前に書き込むデータ量。デフォルトは50MB。\tFalse Cycle Hour\tログをサイクルする時刻。Cycle Minuteと組み合わせて、指定された時刻に毎日ログをサイクルします。nilの場合、ログは指定されたCycle Minuteに毎時サイクルされます。Cycle Timeがnilの場合にのみ適用されます。\tFalse Cycle Minute\tCycle Hourを参照してください。\tFalse  使用例:  INTERFACE EXAMPLE example_interface.rb # デフォルトのログ時間600をオーバーライド LOG_STREAM 60   ","version":"次へ","tagName":"h3"},{"title":"PROTOCOL​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#protocol","content":"  (Since 4.0.0) プロトコルはデータを処理することでインターフェースを修正する   プロトコルはREAD、WRITE、またはREAD_WRITEのいずれかになります。READプロトコルはインターフェースが受信したデータに作用し、WRITEは送信される前のデータに作用します。READ_WRITEはプロトコルを読み書きの両方に適用します。 独自のカスタムプロトコルの作成についての情報は、プロトコルを参照してください。  パラメータ\t説明\t必須Type\tプロトコルを受信データ、送信データ、またはその両方に適用するかどうか 有効な値: READ, WRITE, READ_WRITE\tTrue Protocol Filename or Classname\tプロトコルを実装するRubyまたはPythonのファイル名またはクラス名\tTrue Protocol specific parameters\tプロトコルで使用される追加パラメータ\tFalse  Rubyの例:  INTERFACE DATA_INT tcpip_client_interface.rb host.docker.internal 8080 8081 10.0 nil nil MAP_TARGET DATA # INTERFACE行でLENGTHプロトコルを定義するのではなく、ここで定義します PROTOCOL READ LengthProtocol 0 16 0 1 BIG_ENDIAN 4 0xBA5EBA11   Pythonの例:  INTERFACE DATA_INT openc3/interfaces/tcpip_client_interface.py host.docker.internal 8080 8081 10.0 nil BURST MAP_TARGET DATA PROTOCOL READ IgnorePacketProtocol INST IMAGE # すべてのINST IMAGEパケットをドロップする   ","version":"次へ","tagName":"h3"},{"title":"OPTION​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#option","content":" インターフェースにパラメータを設定する  オプションが設定されると、インターフェースクラスはset_optionメソッドを呼び出します。カスタムインターフェースはset_optionをオーバーライドして、追加のオプションを処理できます。  パラメータ\t説明\t必須Name\t設定するオプション。OpenC3はコア提供インターフェースにいくつかのオプションを定義しています。SerialInterfaceはFLOW_CONTROL（NONE（デフォルト）またはRTSCTS）とDATA_BITS（シリアルインターフェースのデータビットを変更する）を定義します。TcpipServerInterfaceとHttpServerInterfaceはLISTEN_ADDRESS（接続を受け付けるIPアドレス、デフォルトは0.0.0.0）を定義します。\tTrue Parameters\tオプションに渡すパラメータ\tFalse  使用例:  INTERFACE SERIAL_INT serial_interface.rb COM1 COM1 115200 NONE 1 10.0 nil OPTION FLOW_CONTROL RTSCTS OPTION DATA_BITS 8 ROUTER SERIAL_ROUTER tcpip_server_interface.rb 2950 2950 10.0 nil BURST ROUTE SERIAL_INT OPTION LISTEN_ADDRESS 127.0.0.1   ","version":"次へ","tagName":"h3"},{"title":"SECRET​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#secret","content":"  (Since 5.3.0) このインターフェースが必要とする秘密を定義する   このインターフェースの秘密を定義し、オプションでその値をオプションに割り当てます。詳細については、管理者のシークレットを参照してください。  パラメータ\t説明\t必須Type\tENVまたはFILE。ENVは秘密を環境変数にマウントします。FILEは秘密をファイルにマウントします。\tTrue Secret Name\t管理者/シークレットタブから取得する秘密の名前。詳細については、管理者のシークレットを参照してください。\tTrue Environment Variable or File Path\t秘密を格納する環境変数名またはファイルパス。Option Nameを使用して秘密の値にオプションを設定する場合、この値は一意である限り、実際には重要ではないことに注意してください。\tTrue Option Name\t秘密の値を渡すインターフェースオプション。これは秘密をインターフェースに渡す主要な方法です。\tFalse Secret Store Name\tマルチパートキーを持つストアのシークレットストア名\tFalse  使用例:  SECRET ENV USERNAME ENV_USERNAME USERNAME SECRET FILE KEY &quot;/tmp/DATA/cert&quot; KEY   ","version":"次へ","tagName":"h3"},{"title":"ENV​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#env","content":"  (Since 5.7.0) マイクロサービスに環境変数を設定する   パラメータ\t説明\t必須Key\t環境変数名\tTrue Value\t環境変数値\tTrue  使用例:  ENV COMPANY OpenC3   ","version":"次へ","tagName":"h3"},{"title":"WORK_DIR​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#work_dir","content":"  (Since 5.7.0) 作業ディレクトリを設定する   マイクロサービスのCMDを実行する作業ディレクトリ。プラグイン内のマイクロサービスフォルダからの相対パス、またはマイクロサービスが実行されるコンテナ内の絶対パスのいずれかです。  パラメータ\t説明\t必須Directory\tマイクロサービスのCMDを実行する作業ディレクトリ。プラグイン内のマイクロサービスフォルダからの相対パス、またはマイクロサービスが実行されるコンテナ内の絶対パスのいずれかです。\tTrue  使用例:  WORK_DIR '/openc3/lib/openc3/microservices'   ","version":"次へ","tagName":"h3"},{"title":"PORT​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#port","content":"  (Since 5.7.0) マイクロサービスのポートを開く   Kubernetesがポートを開くためにServiceを適用する必要があるため、Kubernetesサポートにはこれが必要です  パラメータ\t説明\t必須Number\tポート番号\tTrue Protocol\tポートプロトコル。デフォルトはTCPです。\tFalse  使用例:  PORT 7272   ","version":"次へ","tagName":"h3"},{"title":"CMD​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#cmd","content":"  (Since 5.7.0) マイクロサービスを実行するためのコマンドライン   マイクロサービスを実行するために実行するコマンドライン。  パラメータ\t説明\t必須Args\tマイクロサービスを実行するためにexecする1つ以上の引数。\tTrue  Rubyの例:  CMD ruby interface_microservice.rb DEFAULT__INTERFACE__INT1   Pythonの例:  CMD python interface_microservice.py DEFAULT__INTERFACE__INT1   ","version":"次へ","tagName":"h3"},{"title":"CONTAINER​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#container","content":"  (Since 5.7.0) Dockerコンテナ   マイクロサービスを実行するコンテナ。COSMOS Enterprise Editionでのみ使用されます。  パラメータ\t説明\t必須Args\tコンテナの名前\tFalse  ","version":"次へ","tagName":"h3"},{"title":"ROUTE_PREFIX​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#route_prefix","content":"  (Since 5.7.0) ルートのプレフィックス   Traefikで外部に公開するマイクロサービスへのルートのプレフィックス  パラメータ\t説明\t必須Route Prefix\tルートプレフィックス。すべてのスコープで一意である必要があります。/myprefixのようなもの\tTrue  使用例:  ROUTE_PREFIX /interface   ","version":"次へ","tagName":"h3"},{"title":"SHARD​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#shard","content":"  (Since 6.0.0) ターゲットマイクロサービスを実行するオペレーターシャード   オペレーターシャード。複数のオペレーターコンテナ（通常はKubernetesで）を実行している場合にのみ使用されます  パラメータ\t説明\t必須Shard\t0から始まるシャード番号\tFalse  使用例:  SHARD 0   ","version":"次へ","tagName":"h3"},{"title":"ROUTER​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#router-1","content":" 一つ以上のインターフェースからコマンドを受信し、テレメトリパケットを出力するルーターを作成する  リモートクライアントからコマンドパケットを受信し、それらを関連するインターフェースに送信するルーターを作成します。インターフェースからテレメトリパケットを受信し、それらをリモートクライアントに送信します。これにより、ルーターは外部クライアントと実際のデバイスの間の仲介者になることができます。  パラメータ\t説明\t必須Name\tルーターの名前\tTrue Filename\tインターフェースをインスタンス化する際に使用するRubyまたはPythonファイル。 有効な値: tcpip_client_interface, tcpip_server_interface, udp_interface, serial_interface\tTrue  追加のパラメータが必要です。詳細については、インターフェースのドキュメントを参照してください。  ","version":"次へ","tagName":"h2"},{"title":"TARGET​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#target-1","content":" 新しいターゲットを定義する  パラメータ\t説明\t必須Folder Name\tターゲットフォルダ\tTrue Name\tターゲット名。これはほとんどの場合、Folder Nameと同じですが、同じターゲットフォルダに基づいて複数のターゲットを作成するために異なる場合があります。\tTrue  使用例:  TARGET INST INST   ","version":"次へ","tagName":"h2"},{"title":"TARGET MODIFIERS​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#target-modifiers","content":" 以下のキーワードはTARGETキーワードに続いて使用する必要があります。  ","version":"次へ","tagName":"h2"},{"title":"CMD_BUFFER_DEPTH​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#cmd_buffer_depth","content":"  (Since 5.2.0) 順序どおりにログに記録されることを確実にするためにバッファリングするコマンドの数   パラメータ\t説明\t必須Buffer Depth\tパケット単位のバッファ深度（デフォルト = 5）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CMD_LOG_CYCLE_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#cmd_log_cycle_time","content":" コマンドバイナリログは時間間隔でサイクルさせることができます  パラメータ\t説明\t必須Time\tファイル間の最大時間（秒）（デフォルト = 600）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CMD_LOG_CYCLE_SIZE​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#cmd_log_cycle_size","content":" コマンドバイナリログは、特定のログファイルサイズに達した後にサイクルさせることができます  パラメータ\t説明\t必須Size\t最大ファイルサイズ（バイト単位）（デフォルト = 50_000_000）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CMD_LOG_RETAIN_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#cmd_log_retain_time","content":" 生のコマンドログを保持する期間（秒）  パラメータ\t説明\t必須Time\t生のコマンドログを保持する秒数（デフォルト = nil = 永久）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CMD_DECOM_LOG_CYCLE_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#cmd_decom_log_cycle_time","content":" コマンドデコミュテーションログは時間間隔でサイクルさせることができます  パラメータ\t説明\t必須Time\tファイル間の最大時間（秒）（デフォルト = 600）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CMD_DECOM_LOG_CYCLE_SIZE​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#cmd_decom_log_cycle_size","content":" コマンドデコミュテーションログは、特定のログファイルサイズに達した後にサイクルさせることができます  パラメータ\t説明\t必須Size\t最大ファイルサイズ（バイト単位）（デフォルト = 50_000_000）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CMD_DECOM_LOG_RETAIN_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#cmd_decom_log_retain_time","content":" デコミュテーションコマンドログを保持する期間（秒）  パラメータ\t説明\t必須Time\tデコミュテーションコマンドログを保持する秒数（デフォルト = nil = 永久）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"TLM_BUFFER_DEPTH​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#tlm_buffer_depth","content":"  (Since 5.2.0) 順序どおりにログに記録されることを確実にするためにバッファリングするテレメトリパケットの数   パラメータ\t説明\t必須Buffer Depth\tパケット単位のバッファ深度（デフォルト = 60）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"TLM_LOG_CYCLE_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#tlm_log_cycle_time","content":" テレメトリバイナリログは時間間隔でサイクルさせることができます  パラメータ\t説明\t必須Time\tファイル間の最大時間（秒）（デフォルト = 600）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"TLM_LOG_CYCLE_SIZE​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#tlm_log_cycle_size","content":" テレメトリバイナリログは、特定のログファイルサイズに達した後にサイクルさせることができます  パラメータ\t説明\t必須Size\t最大ファイルサイズ（バイト単位）（デフォルト = 50_000_000）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"TLM_LOG_RETAIN_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#tlm_log_retain_time","content":" 生のテレメトリログを保持する期間（秒）  パラメータ\t説明\t必須Time\t生のテレメトリログを保持する秒数（デフォルト = nil = 永久）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"TLM_DECOM_LOG_CYCLE_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#tlm_decom_log_cycle_time","content":" テレメトリデコミュテーションログは時間間隔でサイクルさせることができます  パラメータ\t説明\t必須Time\tファイル間の最大時間（秒）（デフォルト = 600）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"TLM_DECOM_LOG_CYCLE_SIZE​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#tlm_decom_log_cycle_size","content":" テレメトリデコミュテーションログは、特定のログファイルサイズに達した後にサイクルさせることができます  パラメータ\t説明\t必須Size\t最大ファイルサイズ（バイト単位）（デフォルト = 50_000_000）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"TLM_DECOM_LOG_RETAIN_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#tlm_decom_log_retain_time","content":" デコミュテーションテレメトリログを保持する期間（秒）  パラメータ\t説明\t必須Time\tデコミュテーションテレメトリログを保持する秒数（デフォルト = nil = 永久）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"REDUCED_MINUTE_LOG_RETAIN_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#reduced_minute_log_retain_time","content":" 縮小された分テレメトリログを保持する期間（秒）  パラメータ\t説明\t必須Time\t縮小された分テレメトリログを保持する秒数（デフォルト = nil = 永久）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"REDUCED_HOUR_LOG_RETAIN_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#reduced_hour_log_retain_time","content":" 縮小された時間テレメトリログを保持する期間（秒）  パラメータ\t説明\t必須Time\t縮小された時間テレメトリログを保持する秒数（デフォルト = nil = 永久）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"REDUCED_DAY_LOG_RETAIN_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#reduced_day_log_retain_time","content":" 縮小された日テレメトリログを保持する期間（秒）  パラメータ\t説明\t必須Time\t縮小された日テレメトリログを保持する秒数（デフォルト = nil = 永久）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"LOG_RETAIN_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#log_retain_time","content":" すべての通常のテレメトリログを保持する期間（秒）  パラメータ\t説明\t必須Time\tすべての通常のテレメトリログを保持する秒数（デフォルト = nil = 永久）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"REDUCED_LOG_RETAIN_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#reduced_log_retain_time","content":" すべての縮小されたテレメトリログを保持する期間（秒）  パラメータ\t説明\t必須Time\tすべての縮小されたテレメトリログを保持する秒数（デフォルト = nil = 永久）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CLEANUP_POLL_TIME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#cleanup_poll_time","content":" クリーンアッププロセスを実行する周期  パラメータ\t説明\t必須Time\tクリーンアッププロセスの実行間隔の秒数（デフォルト = 600 = 10分）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"REDUCER_DISABLE​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#reducer_disable","content":" ターゲットのデータ削減マイクロサービスを無効にする  ","version":"次へ","tagName":"h3"},{"title":"REDUCER_MAX_CPU_UTILIZATION​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#reducer_max_cpu_utilization","content":" データ削減に適用するCPU使用率の最大量  パラメータ\t説明\t必須Percentage\t0から100パーセント（デフォルト = 30）\tTrue  ","version":"次へ","tagName":"h3"},{"title":"TARGET_MICROSERVICE​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#target_microservice","content":"  (Since 5.2.0) ターゲットマイクロサービスを独自のプロセスに分割する   処理が遅れているリソースにより多くのリソースを与えるために使用できます。同じタイプに対して複数回定義すると、複数のプロセスが作成されます。各プロセスは、PACKETキーワードで処理する特定のパケットを指定できます。  パラメータ\t説明\t必須Type\tターゲットマイクロサービスのタイプ。DECOM、COMMANDLOG、DECOMCMDLOG、PACKETLOG、DECOMLOG、REDUCER、またはCLEANUPのいずれかでなければなりません\tTrue  ","version":"次へ","tagName":"h3"},{"title":"PACKET​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#packet","content":"  (Since 5.2.0) 現在のTARGET_MICROSERVICEに割り当てるパケット名   パラメータ\t説明\t必須Packet Name\tパケット名。REDUCERまたはCLEANUPターゲットマイクロサービスタイプには適用されません。\tTrue  ","version":"次へ","tagName":"h3"},{"title":"DISABLE_ERB​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#disable_erb","content":"  (Since 5.12.0) ERB処理を無効にする   ターゲット全体またはそのファイル名に対する一連の正規表現のERB処理を無効にします  パラメータ\t説明\t必須Regex\tファイル名に対して一致する正規表現。一致する場合、ERB処理は行われません\tFalse  ","version":"次へ","tagName":"h3"},{"title":"SHARD​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#shard-1","content":"  (Since 6.0.0) ターゲットマイクロサービスを実行するオペレーターシャード   オペレーターシャード。複数のオペレーターコンテナ（通常はKubernetesで）を実行している場合にのみ使用されます  パラメータ\t説明\t必須Shard\t0から始まるシャード番号\tFalse  使用例:  SHARD 0   ","version":"次へ","tagName":"h3"},{"title":"MICROSERVICE​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#microservice-1","content":" 新しいマイクロサービスを定義する  プラグインがOpenC3システムに追加するマイクロサービスを定義します。マイクロサービスは、永続的な処理を実行するバックグラウンドソフトウェアプロセスです。  パラメータ\t説明\t必須Microservice Folder Name\tプラグイン内のマイクロサービスフォルダの正確な名前。例：microservices/MicroserviceFolderName\tTrue Microservice Name\tOpenC3システム内のこのマイクロサービスインスタンスの特定の名前\tTrue  使用例:  MICROSERVICE EXAMPLE openc3-example   ","version":"次へ","tagName":"h2"},{"title":"MICROSERVICE修飾子​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#microservice修飾子","content":" 以下のキーワードはMICROSERVICEキーワードに続いて使用する必要があります。  ","version":"次へ","tagName":"h2"},{"title":"ENV​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#env-1","content":" マイクロサービスに環境変数を設定する  パラメータ\t説明\t必須Key\t環境変数名\tTrue Value\t環境変数値\tTrue  使用例:  MICROSERVICE EXAMPLE openc3-example ENV COMPANY OpenC3   ","version":"次へ","tagName":"h3"},{"title":"WORK_DIR​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#work_dir-1","content":" 作業ディレクトリを設定する  マイクロサービスのCMDを実行する作業ディレクトリ。プラグイン内のマイクロサービスフォルダからの相対パス、またはマイクロサービスが実行されるコンテナ内の絶対パスのいずれかです。  パラメータ\t説明\t必須Directory\tマイクロサービスのCMDを実行する作業ディレクトリ。プラグイン内のマイクロサービスフォルダからの相対パス、またはマイクロサービスが実行されるコンテナ内の絶対パスのいずれかです。\tTrue  使用例:  MICROSERVICE EXAMPLE openc3-example WORK_DIR .   ","version":"次へ","tagName":"h3"},{"title":"PORT​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#port-1","content":"  (Since 5.0.10) マイクロサービスのポートを開く   Kubernetesがポートを開くためにServiceを適用する必要があるため、Kubernetesサポートにはこれが必要です  パラメータ\t説明\t必須Number\tポート番号\tTrue Protocol\tポートプロトコル。デフォルトはTCPです。\tFalse  使用例:  MICROSERVICE EXAMPLE openc3-example PORT 7272   ","version":"次へ","tagName":"h3"},{"title":"TOPIC​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#topic","content":" Redisトピックを関連付ける  このマイクロサービスに関連付けるRedisトピック。decom_microserviceなどの標準的なOpenC3マイクロサービスは、この情報を使用して、購読するパケットストリームを知ります。TOPICキーワードは、必要なすべてのトピックを関連付けるために必要なだけ使用できます。  パラメータ\t説明\t必須Topic Name\tマイクロサービスに関連付けるRedisトピック\tTrue  使用例:  MICROSERVICE EXAMPLE openc3-example # トピックを手動で割り当てることは高度なトピックであり、 # 内部COSMOS データ構造の詳細な知識が必要です。 TOPIC DEFAULT__openc3_log_messages TOPIC DEFAULT__TELEMETRY__EXAMPLE__STATUS   ","version":"次へ","tagName":"h3"},{"title":"TARGET_NAME​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#target_name","content":" OpenC3ターゲットを関連付ける  マイクロサービスに関連付けるOpenC3ターゲット。decom_microserviceなどの標準的なOpenC3マイクロサービスでは、これによりターゲット設定がマイクロサービスのコンテナにロードされます。  パラメータ\t説明\t必須Target Name\tマイクロサービスに関連付けるOpenC3ターゲット\tTrue  使用例:  MICROSERVICE EXAMPLE openc3-example TARGET_NAME EXAMPLE   ","version":"次へ","tagName":"h3"},{"title":"CMD​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#cmd-1","content":" マイクロサービスを実行するためのコマンドライン  マイクロサービスを実行するために実行するコマンドライン。  パラメータ\t説明\t必須Args\tマイクロサービスを実行するためにexecする1つ以上の引数。\tTrue  Rubyの例:  MICROSERVICE EXAMPLE openc3-example CMD ruby example_target.rb   Pythonの例:  MICROSERVICE EXAMPLE openc3-example CMD python example_target.py   ","version":"次へ","tagName":"h3"},{"title":"OPTION​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#option-1","content":" マイクロサービスにオプションを渡す  マイクロサービスに渡す汎用キー/値オプション。これらはOpenC3設定ファイルの行のようにKEYWORD/PARAMSの形式を取ります。複数のOPTIONキーワードを使用して、複数のオプションをマイクロサービスに渡すことができます。  パラメータ\t説明\t必須Option Name\tオプションの名前\tTrue Option Value(s)\tオプションに関連付ける1つ以上の値\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CONTAINER​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#container-1","content":" Dockerコンテナ  マイクロサービスを実行するコンテナ。COSMOS Enterprise Editionでのみ使用されます。  パラメータ\t説明\t必須Args\tコンテナの名前\tFalse  ","version":"次へ","tagName":"h3"},{"title":"SECRET​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#secret-1","content":"  (Since 5.3.0) このマイクロサービスが必要とする秘密を定義する   このマイクロサービスの秘密を定義します。詳細については、管理者のシークレットを参照してください。  パラメータ\t説明\t必須Type\tENVまたはFILE。ENVは秘密を環境変数にマウントします。FILEは秘密をファイルにマウントします。\tTrue Secret Name\t管理者/シークレットタブから取得する秘密の名前。詳細については、管理者のシークレットを参照してください。\tTrue Environment Variable or File Path\t秘密を格納する環境変数名またはファイルパス\tTrue Secret Store Name\tマルチパートキーを持つストアのシークレットストア名\tFalse  使用例:  SECRET ENV USERNAME ENV_USERNAME SECRET FILE KEY &quot;/tmp/DATA/cert&quot;   ","version":"次へ","tagName":"h3"},{"title":"ROUTE_PREFIX​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#route_prefix-1","content":"  (Since 5.5.0) ルートのプレフィックス   Traefikで外部に公開するマイクロサービスへのルートのプレフィックス  パラメータ\t説明\t必須Route Prefix\tルートプレフィックス。すべてのスコープで一意である必要があります。/myprefixのようなもの\tTrue  使用例:  MICROSERVICE CFDP CFDP ROUTE_PREFIX /cfdp   ","version":"次へ","tagName":"h3"},{"title":"DISABLE_ERB​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#disable_erb-1","content":"  (Since 5.12.0) ERB処理を無効にする   マイクロサービス全体またはそのファイル名に対する一連の正規表現のERB処理を無効にします  パラメータ\t説明\t必須Regex\tファイル名に対して一致する正規表現。一致する場合、ERB処理は行われません\tFalse  ","version":"次へ","tagName":"h3"},{"title":"SHARD​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#shard-2","content":"  (Since 6.0.0) ターゲットマイクロサービスを実行するオペレーターシャード   オペレーターシャード。複数のオペレーターコンテナ（通常はKubernetesで）を実行している場合にのみ使用されます  パラメータ\t説明\t必須Shard\t0から始まるシャード番号\tFalse  使用例:  SHARD 0   ","version":"次へ","tagName":"h3"},{"title":"STOPPED​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#stopped","content":"  (Since 6.2.0) 初期的にマイクロサービスを停止状態（有効でない）で作成する   使用例:  STOPPED   ","version":"次へ","tagName":"h3"},{"title":"TOOL​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#tool-1","content":" ツールを定義する  プラグインがOpenC3システムに追加するツールを定義します。ツールは、Single-SPAjavascriptライブラリを利用するウェブベースのアプリケーションで、独立したフロントエンドマイクロサービスとして実行中のシステムに動的に追加できます。  パラメータ\t説明\t必須Tool Folder Name\tプラグイン内のツールフォルダの正確な名前。例：tools/ToolFolderName\tTrue Tool Name\tOpenC3ナビゲーションメニューに表示されるツールの名前\tTrue  使用例:  TOOL DEMO Demo   ","version":"次へ","tagName":"h2"},{"title":"TOOL修飾子​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#tool修飾子","content":" 以下のキーワードはTOOLキーワードに続いて使用する必要があります。  ","version":"次へ","tagName":"h2"},{"title":"URL​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#url","content":" ツールにアクセスするために使用されるURL  ツールにアクセスするための相対URL。デフォルトは&quot;/tools/ToolFolderName&quot;です。  パラメータ\t説明\t必須Url\tURL。指定されない場合、デフォルトはtools/ToolFolderNameです。通常、外部ツールにリンクする場合を除いて指定する必要はありません。\tTrue  ","version":"次へ","tagName":"h3"},{"title":"INLINE_URL​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#inline_url","content":" ツールをロードするための内部URL  ツールをsingle-SPAにロードするために使用されるjavascriptファイルのURL。デフォルトは&quot;main.js&quot;です。  パラメータ\t説明\t必須Url\tインラインURL。指定されない場合、デフォルトはmain.jsです。通常、非標準のファイル名を使用する場合を除いて指定する必要はありません。\tTrue  ","version":"次へ","tagName":"h3"},{"title":"WINDOW​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#window","content":" ナビゲーション時にツールを表示する方法  ツールを表示するためのウィンドウモード。INLINEはSingle-SPAフレームワークを使用してページをリフレッシュせずに内部的にツールを開きます。IFRAMEはOpenC3内のIframeで外部ツールを開きます。NEWは新しいタブでツールを開きます。  パラメータ\t説明\t必須Window Mode\tツール表示モード 有効な値: INLINE, IFRAME, NEW\tTrue  ","version":"次へ","tagName":"h3"},{"title":"ICON​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#icon","content":" ツールアイコンを設定する  OpenC3ナビゲーションメニューでツール名の横に表示されるアイコン。  パラメータ\t説明\t必須Icon Name\tツール名の横に表示するアイコン。アイコンはFont Awesome、Material Design（https://materialdesignicons.com/）、およびAstroから来ています。\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CATEGORY​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#category","content":" ツールのカテゴリ  ツールをカテゴリに関連付けます。これはナビゲーションメニューのサブメニューになります。  パラメータ\t説明\t必須Category Name\tツールを関連付けるカテゴリ\tTrue  ","version":"次へ","tagName":"h3"},{"title":"SHOWN​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#shown","content":" ツールを表示するかどうか  ツールがナビゲーションメニューに表示されるかどうか。通常はtrueであるべきですが、openc3ベースツールを除きます。  パラメータ\t説明\t必須Shown\tツールが表示されるかどうか。TRUEまたはFALSE 有効な値: true, false\tTrue  ","version":"次へ","tagName":"h3"},{"title":"POSITION​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#position","content":"  (Since 5.0.8) ナビゲーションバーでのツールの位置   2から始まるツールの位置（1はAdmin Consoleのために予約されています）。ポジションのないツールは、インストールされるとき末尾に追加されます。すべてのCOSMOSオープンソースツールは、ポジションに連続した整数値を持っています。  パラメータ\t説明\t必須Position\t数値位置\tTrue  ","version":"次へ","tagName":"h3"},{"title":"DISABLE_ERB​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#disable_erb-2","content":"  (Since 5.12.0) ERB処理を無効にする   ツール全体またはそのファイル名に対する一連の正規表現のERB処理を無効にします  パラメータ\t説明\t必須Regex\tファイル名に対して一致する正規表現。一致する場合、ERB処理は行われません\tFalse  ","version":"次へ","tagName":"h3"},{"title":"IMPORT_MAP_ITEM​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#import_map_item","content":"  (Since 6.0.0) インポートマップにアイテムを追加する   パラメータ\t説明\t必須key\tインポートマップキー\tTrue value\tインポートマップ値\tTrue  ","version":"次へ","tagName":"h3"},{"title":"WIDGET​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#widget","content":" カスタムウィジェットを定義する  テレメトリビューア画面で使用できるカスタムウィジェットを定義します。  パラメータ\t説明\t必須Widget Name\tウィジェットの名前は、ウィジェット実装へのパスを構築するために使用されます。例えば、WIDGET HELLOWORLDはビルドされたファイルtools/widgets/HelloworldWidget/HelloworldWidget.umd.min.jsを見つけます。詳細については、カスタムウィジェットガイドを参照してください。\tTrue Label\tData Viewerコンポーネントのドロップダウンに表示されるウィジェットのラベル\tFalse  使用例:  WIDGET HELLOWORLD   ","version":"次へ","tagName":"h2"},{"title":"WIDGET修飾子​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#widget修飾子","content":" 以下のキーワードはWIDGETキーワードに続いて使用する必要があります。  ","version":"次へ","tagName":"h2"},{"title":"DISABLE_ERB​","type":1,"pageTitle":"プラグイン","url":"/ja/docs/configuration/plugins#disable_erb-3","content":"  (Since 5.12.0) ERB処理を無効にする   ウィジェット全体またはそのファイル名に対する一連の正規表現のERB処理を無効にします  パラメータ\t説明\t必須Regex\tファイル名に対して一致する正規表現。一致する場合、ERB処理は行われません\tFalse ","version":"次へ","tagName":"h3"},{"title":"リトルエンディアンのビットフィールド","type":0,"sectionRef":"#","url":"/ja/docs/guides/little-endian-bitfields","content":"リトルエンディアンのビットフィールド リトルエンディアンのビットフィールドを定義することは少し変わっていますが、COSMOSでは可能です。ただし、APPENDはリトルエンディアンのビットフィールドでは機能しないことに注意してください。 以下は、COSMOSがLITTLE_ENDIANデータを扱う際のルールです： COSMOSのビットオフセットは常にBIG_ENDIANの用語で定義されます。ビット0は常にパケットの最初のバイトの最上位ビットであり、そこから増加していきます。 すべての8ビット、16ビット、32ビット、64ビットのバイト境界が合ったLITTLE_ENDIANデータ型は、パケット内のアイテムの一部を含む最初のバイトの最上位ビットとしてbit_offsetを定義します（これはBIG_ENDIANと全く同じです）。8ビットのLITTLE_ENDIANアイテムを除くすべてのアイテムでは、これはアイテムの最下位バイトになることに注意してください。 LITTLE_ENDIANビットフィールドは、8ビット、16ビット、32ビット、または64ビットではなく、バイト境界が合っていないLITTLE_ENDIAN INTまたはUINTアイテムとして定義されます。 LITTLE_ENDIANビットフィールドは、上記のルール1で説明されているように、BIG_ENDIANスペースでのビットフィールドの最上位ビットの位置としてbit_offsetを定義する必要があります。例えば、パケットの先頭にある次のC構造体は次のように定義されます： struct { unsigned short a:4; unsigned short b:8; unsigned short c:4; } ITEM A 4 4 UINT &quot;struct item a&quot; ITEM B 12 8 UINT &quot;struct item b&quot; ITEM C 8 4 UINT &quot;struct item c&quot; これは視覚化するのが難しいですが、上記の構造はバイトスワップ後、バイト配列内で次のように展開されます：bの最下位4ビット、aの4ビット、cの4ビット、bの最上位4ビット。 最良のアドバイスは、実験を行い、コマンドとテレメトリサービスのView Raw機能を使用してパケットのバイトを検査し、必要に応じて調整することです。","keywords":"","version":"次へ"},{"title":"カスタムウィジェット","type":0,"sectionRef":"#","url":"/ja/docs/guides/custom-widgets","content":"","keywords":"","version":"次へ"},{"title":"カスタムウィジェット​","type":1,"pageTitle":"カスタムウィジェット","url":"/ja/docs/guides/custom-widgets#カスタムウィジェット","content":" 基本的にCOSMOSのデモに従って、そのカスタムウィジェットがどのように作成されたかを説明します。  デモのplugin.txtファイルの下部を見ると、ウィジェットを宣言しているのが分かります：  WIDGET BIG WIDGET HELLOWORLD   プラグインがデプロイされると、COSMOSはビルド済みのウィジェットを探します。BIGウィジェットの場合、tools/widgets/BigWidget/BigWidget.umd.min.jsでウィジェットを探します。同様に、HELLOWORLDはtools/widgets/HelloworldWidget/HelloworldWidget.umd.min.jsで探します。これらのディレクトリとファイル名は不思議に思えるかもしれませんが、それはウィジェットがどのようにビルドされるかに関係しています。  ","version":"次へ","tagName":"h2"},{"title":"Helloworldウィジェット​","type":1,"pageTitle":"カスタムウィジェット","url":"/ja/docs/guides/custom-widgets#helloworldウィジェット","content":" Helloworldウィジェットのソースコードはプラグインのsrcディレクトリにあり、HelloworldWidget.vueと呼ばれています。基本構造は次の通りです：  &lt;template&gt; &lt;!-- ここにウィジェットを実装 --&gt; &lt;/template&gt; &lt;script&gt; import { Widget } from &quot;@openc3/vue-common/widgets&quot;; export default { mixins: [Widget], data() { return { // リアクティブデータ項目 }; }, }; &lt;/script&gt; &lt;style scoped&gt; /* ウィジェット固有のスタイル */ &lt;/style&gt;   Vue &amp; Vuetify COSMOSフロントエンド（すべてのウィジェットを含む）がどのように構築されているかについての詳細は、Vue.jsとVuetifyをご確認ください。  このカスタムウィジェットをビルドするために、デモのRakefileを変更して、プラグインがビルドされるときにyarn run buildを呼び出すようにしました。yarn run XXXはpackage.jsonファイル内で実行する「スクリプト」を探します。package.jsonを開くと、次のようになっています：   &quot;scripts&quot;: { &quot;build&quot;: &quot;vue-cli-service build --target lib --dest tools/widgets/HelloworldWidget --formats umd-min src/HelloworldWidget.vue --name HelloworldWidget &amp;&amp; vue-cli-service build --target lib --dest tools/widgets/BigWidget --formats umd-min src/BigWidget.vue --name BigWidget&quot; },   これはvue-cli-serviceを使用して、src/HelloworldWidget.vueにあるコードをビルドし、umd-min形式でフォーマットして、tools/widgets/HelloworldWidgetディレクトリに配置します。そのため、プラグインはtools/widgets/HelloworldWidget/HelloworldWidget.umd.min.jsでプラグインを探します。vue-cli-service buildのドキュメントについてはこちらをクリックしてください。  デモプラグインのsimple.txt画面を見ると、ウィジェットを使用していることがわかります：  SCREEN AUTO AUTO 0.5 LABELVALUE &lt;%= target_name %&gt; HEALTH_STATUS CCSDSSEQCNT HELLOWORLD BIG &lt;%= target_name %&gt; HEALTH_STATUS TEMP1   テレメトリビューアでこの画面を開くと、次のようになります：    これは単純な例ですが、カスタムウィジェットの可能性は無限大です！ ","version":"次へ","tagName":"h3"},{"title":"動的パケット","type":0,"sectionRef":"#","url":"/ja/docs/guides/dynamic-packets","content":"","keywords":"","version":"次へ"},{"title":"動的更新の使用​","type":1,"pageTitle":"動的パケット","url":"/ja/docs/guides/dynamic-packets#動的更新の使用","content":" あなた自身のコードで動的更新機能を使用するには、TargetModelのdynamic_updateメソッドを呼び出す必要があります。このメソッドは、パケットの配列/リスト、パケットがコマンドかテレメトリかの区別、および設定バケットに作成するファイル名を引数に取ります。  以下がメソッドのシグネチャです：  def dynamic_update(packets, cmd_or_tlm = :TELEMETRY, filename = &quot;dynamic_tlm.txt&quot;)   def dynamic_update(self, packets, cmd_or_tlm=&quot;TELEMETRY&quot;, filename=&quot;dynamic_tlm.txt&quot;)   このメソッドの使用例は以下の通りです：  # 新しいパケットを作成 packet = Packet.new('INST', 'NEW_PACKET') # または既存のパケットを取得 packet = System.telemetry.packet('INST', 'METRICS') # 新しいアイテムを追加してパケットを変更 packet.append_item('NEW_ITEM', 32, :FLOAT) # パケットのターゲットに関連付けられたTargetModelを取得 target_model = TargetModel.get_model(name: 'INST', scope: 'DEFAULT') # 新しいパケットでターゲットモデルを更新 target_model.dynamic_update([packet])   # 新しいパケットを作成 packet = Packet('INST', 'NEW_PACKET') # または既存のパケットを取得 packet = System.telemetry.packet('INST', 'METRICS') # 新しいアイテムを追加してパケットを変更 packet.append_item('NEW_ITEM', 32, 'FLOAT') # パケットのターゲットに関連付けられたTargetModelを取得 target_model = TargetModel.get_model(name='INST', scope='DEFAULT') # 新しいパケットでターゲットモデルを更新 target_model.dynamic_update([packet])   このメソッドが呼び出されると、いくつかのことが起こります：  COSMOS Redisデータベースが新しいパケットで更新され、現在値テーブルが初期化されますパケットの設定ファイルが作成され、&lt;SCOPE&gt;/targets_modified/&lt;TARGET&gt;/cmd_tlm/dynamic_tlm.txtに保存されます。dynamic_updateを複数回呼び出す場合は、ファイル名を更新して上書きされないようにする必要があります。COSMOSマイクロサービスに、生のパケットデータと分解されたパケットデータを含む新しいストリーミングトピックが通知されます。このアクションの一部として、マイクロサービスが再起動され、これらの変更が適用されます。COMMANDSの場合、次のものが再起動されます：&lt;SCOPE&gt;__COMMANDLOG__&lt;TARGET&gt;と&lt;SCOPE&gt;__DECOMCMDLOG__&lt;TARGET&gt;。TELEMETRYの場合、次のものが再起動されます：&lt;SCOPE&gt;__PACKET_LOG__&lt;TARGET&gt;、&lt;SCOPE&gt;__DECOMLOG__&lt;TARGET&gt;、および&lt;SCOPE&gt;__DECOM__&lt;TARGET&gt;。  dynamic_updateはLOGマイクロサービスを再起動するため、再起動中にパケットが失われる可能性があります。したがって、重要なテレメトリ処理期間中にはdynamic_updateを呼び出すべきではありません。 ","version":"次へ","tagName":"h2"},{"title":"ロギング","type":0,"sectionRef":"#","url":"/ja/docs/guides/logging","content":"","keywords":"","version":"次へ"},{"title":"decom_logs & raw_logs​","type":1,"pageTitle":"ロギング","url":"/ja/docs/guides/logging#decom_logs--raw_logs","content":" decom_logsとraw_logsフォルダには、デコミュテーション（復調）された、および生のコマンドとテレメトリデータが含まれています。どちらもさらにターゲット、パケット、そして日付ごとに分けられています。例えば、DEFAULT/raw_logs/tlm/INST2/&lt;YYYYMMDD&gt;/ディレクトリを閲覧すると：    生のバイナリデータを含むgzip圧縮された.binファイルが存在していることに注目してください。これらのファイルの構造について詳しくは、ログ構造の開発者ドキュメントを参照してください。  ロギングマイクロサービスのデフォルト設定では、10分ごとまたは50MBごとにいずれか早い方で新しいログファイルを開始します。低データレートのデモの場合、10分の区切りが先に来ます。  ロギング設定を変更するには、plugin.txtファイル内の宣言されたTARGET名の下に、様々なCYCLE_TIME ターゲット修飾子を追加します。  ","version":"次へ","tagName":"h3"},{"title":"text_logs​","type":1,"pageTitle":"ロギング","url":"/ja/docs/guides/logging#text_logs","content":" text_logsフォルダにはopenc3_log_messagesが含まれており、これには再び日付順にソートされタイムスタンプが付けられたテキストファイルが含まれています。これらのログメッセージは、サーバーやターゲットマイクロサービスを含む様々なマイクロサービスから生成されます。したがって、これらのログには送信されたすべてのコマンド（プレーンテキスト形式）と、チェックされたテレメトリが含まれています。これらのログメッセージファイルは、CmdTlmServerのログメッセージウィンドウに表示されるメッセージの長期的な記録です：    ","version":"次へ","tagName":"h3"},{"title":"ローカルモード","type":0,"sectionRef":"#","url":"/ja/docs/guides/local-mode","content":"","keywords":"","version":"次へ"},{"title":"ローカルモードの使用​","type":1,"pageTitle":"ローカルモード","url":"/ja/docs/guides/local-mode#ローカルモードの使用","content":" このチュートリアルでは、インストールガイドで設定されたCOSMOSデモを使用します。cosmos-projectをクローンし、openc3.sh runを使用して起動しているはずです。  プロジェクトディレクトリを確認すると、plugins/DEFAULT/openc3-cosmos-demoディレクトリが表示されるはずです。これには、インストールされたgemとplugin_instance.jsonファイルの両方が含まれています。plugin_instance.jsonファイルは、プラグインがインストールされたときのplugin.txtの値を取得します。注意点として、pluginsディレクトリ内のすべてのファイルはプロジェクトと共に設定管理されることを意図しています。これにより、ローカルで編集してチェックインすると、別のユーザーがプロジェクトをクローンして全く同じ設定を取得できます。これについては後で説明します。  ","version":"次へ","tagName":"h2"},{"title":"スクリプトの編集​","type":1,"pageTitle":"ローカルモード","url":"/ja/docs/guides/local-mode#スクリプトの編集","content":" Visual Studio Code このチュートリアルでは、COSMOSの開発者が使用しているエディタであるVS Codeを使用します。  ローカルモードの最も一般的なユースケースはスクリプト開発です。Script Runnerを起動し、INST/procedures/checks.rbファイルを開きます。このスクリプトを実行すると、完了まで実行できないいくつかのエラー（設計上）があることに気付くでしょう。修正しましょう！7行目と9行目をコメントアウトして、スクリプトを保存します。これでローカルモードがスクリプトのコピーをplugins/targets_modified/INST/procedures/checks.rbに保存したことに気付くはずです。    この時点で、ローカルモードはこれらのスクリプトを同期させているため、どちらの場所でも編集できます。ローカルスクリプトを編集して、先頭に簡単なコメントを追加してみましょう：# This is a script。Script Runnerに戻ると、変更は_自動的に_表示されていません。ただし、ファイル名の横にあるReloadボタンがあり、これをクリックするとバックエンドからファイルを更新できます。    これをクリックすると、COSMOSに同期されたファイルがリロードされ、コメントが表示されます。    ","version":"次へ","tagName":"h3"},{"title":"ローカルモードの無効化​","type":1,"pageTitle":"ローカルモード","url":"/ja/docs/guides/local-mode#ローカルモードの無効化","content":" ローカルモードを無効にしたい場合は、.envファイルを編集して設定OPENC3_LOCAL_MODE=1を削除できます。  ","version":"次へ","tagName":"h3"},{"title":"構成管理​","type":1,"pageTitle":"ローカルモード","url":"/ja/docs/guides/local-mode#構成管理","content":" pluginsディレクトリを含むプロジェクト全体を構成管理することをお勧めします。これにより、COSMOSを起動するすべてのユーザーが同一の構成を起動できます。プラグインはtargets_modifiedディレクトリで見つかった変更で作成および更新されます。  いずれかの時点で、おそらくローカルの変更を元のプラグインに戻したいと思うでしょう。targets_modified/TARGETディレクトリ全体を元のプラグインにコピーするだけです。その時点で、CLIを使用してプラグインを再ビルドできます。  openc3-cosmos-demo % ./openc3.sh cli rake build VERSION=1.0.1 Successfully built RubyGem Name: openc3-cosmos-demo Version: 1.0.1 File: openc3-cosmos-demo-1.0.1.gem   管理者プラグインタブとアップグレードリンクを使用してプラグインをアップグレードします。新しくビルドしたプラグインを選択すると、COSMOSは既存の変更を検出し、それらを削除するかどうか尋ねます。これは永久に変更を削除するため、警告が付いています。変更を移動してプラグインを再ビルドしたので、チェックボックスをオンにしてINSTALLします。    新しいプラグインがインストールされると、プロジェクトのpluginsディレクトリが新しいプラグインで更新され、targets_modifiedディレクトリの下にあるすべてのものは新しいインストールでは変更がないため削除されます。  ローカルモードは、ローカルファイルシステム上でスクリプトや画面を開発し、自動的にそれらをCOSMOSと同期させる強力な方法です。 ","version":"次へ","tagName":"h2"},{"title":"Raspberry Pi","type":0,"sectionRef":"#","url":"/ja/docs/guides/raspberrypi","content":"","keywords":"","version":"次へ"},{"title":"Raspberry Pi 4でCOSMOSを実行する​","type":1,"pageTitle":"Raspberry Pi","url":"/ja/docs/guides/raspberrypi#raspberry-pi-4でcosmosを実行する","content":" Raspberry Pi 4は、Linuxを実行する低コストで強力なARMベースのミニコンピュータです。そして、最新のLinuxを実行するため、COSMOSも実行できます！以下の手順で、セットアップと実行方法を説明します。  必要なもの：  Raspberry Pi 4ボード（8GB RAMでテスト済み）Piケース（オプション）Raspberry Pi電源アダプタ32GB以上のSDカード - 速いものほど良いSDカードに書き込み可能なノートパソコン  それでは始めましょう！  SDカードに64-bit Raspbian OS Liteをセットアップする https://www.raspberrypi.com/software/ からRaspberry Pi Imagerアプリを入手していることを確認してください SDカードをコンピュータに挿入します（注意：この処理によりSDカード上のすべてのデータが消去されます！）Raspberry Pi Imagerアプリを開きます「Choose Device」ボタンをクリックしますお使いのRaspberry Piモデルを選択します「Choose OS」ボタンをクリックします「Raspberry Pi OS (other)」を選択します「Raspberry Pi OS Lite (64-bit)」を選択します「Choose Storage」ボタンをクリックしますSDカードを選択しますEdit Settings（設定を編集）をクリックしますWi-Fi情報を事前に入力するかどうか尋ねられたら、OKを選択しますホスト名を cosmos.local に設定しますユーザー名とパスワードを設定します。デフォルトのユーザー名はあなたのユーザー名ですが、システムを安全にするためにパスワードも設定する必要がありますWi-Fi情報を入力し、国を適切に設定します（例：JP）正しいタイムゾーンを設定しますサービスタブに移動し、SSHを有効にしますパスワード認証を使用するか、コンピュータがすでにパスワードなしSSH用に設定されている場合は公開鍵のみを使用できますオプションタブに移動し、「Enable Telemetry」（テレメトリを有効にする）がチェックされていないことを確認しますすべて入力したら「Save」（保存）をクリックしますOS カスタマイズ設定を適用するために「Yes」をクリックし、「Are You Sure」（本当によろしいですか）に「Yes」と答え、完了するまで待ちます Raspberry Piの電源が入っていないことを確認します SDカードをコンピュータから取り出し、Raspberry Piに挿入します Raspberry Piに電源を供給し、起動するまで約1分待ちます Raspberry PiにSSH接続します ターミナルウィンドウを開き、SSHを使用してPiに接続します Mac / Linux: ssh yourusername@cosmos.localWindowsでは、Puttyを使用して接続します。.localアドレスを機能させるには、Windows用のBonjourをインストールする必要がある場合があります。 SSHから、以下のコマンドを入力します   sudo sysctl -w vm.max_map_count=262144 sudo sysctl -w vm.overcommit_memory=1 sudo apt update sudo apt upgrade sudo apt install git -y curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh sudo usermod -aG docker $USER newgrp docker git clone https://github.com/OpenC3/cosmos-project.git cosmos cd cosmos # compose.yamlを編集し、openc3-traefikサービスのportsセクションから127.0.0.1:を削除します ./openc3.sh run   約2分後、コンピュータでウェブブラウザを開き、http://cosmos.local:2900 にアクセスします おめでとうございます！これでRaspberry PiでCOSMOSが実行されています！ ","version":"次へ","tagName":"h3"},{"title":"tool_logs​","type":1,"pageTitle":"ロギング","url":"/ja/docs/guides/logging#tool_logs","content":" tool_logsディレクトリには、様々なCOSMOSツールからのログが含まれています。まだツールを実行していない場合、このディレクトリは必要に応じて作成されるため表示されない場合があることに注意してください。ツールのサブディレクトリも必要に応じて作成されます。例えば、Script Runnerでスクリプトを実行した後、スクリプト実行の結果としてのスクリプトランナーログを含む新しい「sr」サブディレクトリが表示されます。場合によっては、このディレクトリ内のログはツール自体から直接利用できることもあります。Script Runnerの場合、スクリプトの下にあるScript Messagesペインには、最後のスクリプトからの出力メッセージが表示されます。Downloadリンクをクリックすると、これらのメッセージをファイルとしてダウンロードできます。   ","version":"次へ","tagName":"h3"},{"title":"コマンドラインインターフェース","type":0,"sectionRef":"#","url":"/ja/docs/getting-started/cli","content":"","keywords":"","version":"次へ"},{"title":"Rake​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#rake","content":" openc3.sh cli rakeを使用してrakeタスクを実行できます。最も一般的な使用法は、プラグインを生成してからビルドすることです。例えば：  % openc3.sh cli rake build VERSION=1.0.0   ","version":"次へ","tagName":"h2"},{"title":"IRB​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#irb","content":" IRBはInteractive Rubyの略で、Rubyインタープリタを起動して使う事ができる方法です。CLIから使用する場合、COSMOSのRubyパスが含まれているため、require 'cosmos'を実行して様々なメソッドを試すことができます。例えば：  % openc3.sh cli irb irb(main):001:0&gt; require 'cosmos' =&gt; true irb(main):002:0&gt; Cosmos::Api::WHITELIST =&gt; [&quot;get_interface&quot;, &quot;get_interface_names&quot;, ... ]   ","version":"次へ","tagName":"h2"},{"title":"Script​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#script","content":" スクリプトメソッドを使用すると、利用可能なスクリプトの一覧表示、スクリプトの起動、出力を監視しながらスクリプトの実行が可能です。オープンソース版ではOPENC3_API_PASSWORDを、Enterprise版ではOPENC3_API_USERとOPENC3_API_PASSWORDの両方を設定する必要があることに注意してください。  オフラインアクセストークン 他のスクリプトCLIメソッドが機能するようになる前に、OPENC3_API_USERとしてフロントエンドのScript Runnerページにアクセスするか、「openc3.sh cli script init」を実行してオフラインアクセストークンを取得する必要があります。  ","version":"次へ","tagName":"h2"},{"title":"List​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#list","content":" すべてのターゲットディレクトリにあるすべてのファイルを含む、利用可能なすべてのスクリプトを一覧表示します。bashを使ってこのリストをフィルタリングし、procedures、Rubyファイル、Pythonファイルなどだけを含めることができます。  % export OPENC3_API_USER=operator % export OPENC3_API_PASSWORD=operator % openc3.sh cli script list EXAMPLE/cmd_tlm/example_cmds.txt EXAMPLE/cmd_tlm/example_tlm.txt ...   ","version":"次へ","tagName":"h3"},{"title":"Spawn​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#spawn","content":" 起動されたスクリプトのIDが返されます。Script Runnerでhttp://localhost:2900/tools/scriptrunner/1にアクセスすることで接続できます。最後の値はIDです。  % openc3.sh spawn INST/procedures/checks.rb 1   ","version":"次へ","tagName":"h3"},{"title":"Run​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#run","content":" Runはスクリプトを起動し、出力をキャプチャしてシェルに表示します。これはユーザー入力プロンプトでは機能しないため、スクリプトはユーザー入力を防ぐように書かれている必要があります。CLIヘルプに示されているように、スクリプトに変数を渡すこともできます。  % openc3.sh cli script run INST/procedures/stash.rb Filename INST/procedures/stash.rb scope DEFAULT 2025/03/22 19:50:40.429 (SCRIPTRUNNER): Script config/DEFAULT/targets/INST/procedures/stash.rb spawned in 0.796683293 seconds &lt;ruby 3.2.6&gt; 2025/03/22 19:50:40.453 (SCRIPTRUNNER): Starting script: stash.rb, line_delay = 0.1 At [INST/procedures/stash.rb:3] state [running] At [INST/procedures/stash.rb:4] state [running] 2025/03/22 19:50:40.732 (stash.rb:4): key1: val1 At [INST/procedures/stash.rb:5] state [running] At [INST/procedures/stash.rb:6] state [running] 2025/03/22 19:50:40.936 (stash.rb:6): key2: val2 At [INST/procedures/stash.rb:7] state [running] 2025/03/22 19:50:41.039 (stash.rb:7): CHECK: 'val1' == 'val1' is TRUE At [INST/procedures/stash.rb:8] state [running] 2025/03/22 19:50:41.146 (stash.rb:8): CHECK: 'val2' == 'val2' is TRUE At [INST/procedures/stash.rb:9] state [running] 2025/03/22 19:50:41.256 (stash.rb:9): CHECK: '[&quot;key1&quot;, &quot;key2&quot;]' == '[&quot;key1&quot;, &quot;key2&quot;]' is TRUE At [INST/procedures/stash.rb:10] state [running] At [INST/procedures/stash.rb:11] state [running] At [INST/procedures/stash.rb:12] state [running] 2025/03/22 19:50:41.556 (stash.rb:12): CHECK: '{&quot;key1&quot;=&gt;1, &quot;key2&quot;=&gt;2}' == '{&quot;key1&quot;=&gt;1, &quot;key2&quot;=&gt;2}' is TRUE At [INST/procedures/stash.rb:13] state [running] At [INST/procedures/stash.rb:14] state [running] 2025/03/22 19:50:41.763 (stash.rb:14): CHECK: true == true is TRUE At [INST/procedures/stash.rb:15] state [running] At [INST/procedures/stash.rb:16] state [running] At [INST/procedures/stash.rb:17] state [running] At [INST/procedures/stash.rb:18] state [running] 2025/03/22 19:50:42.176 (stash.rb:18): CHECK: '[1, 2, [3, 4]]' == '[1, 2, [3, 4]]' is TRUE At [INST/procedures/stash.rb:19] state [running] At [INST/procedures/stash.rb:21] state [running] At [INST/procedures/stash.rb:22] state [running] At [INST/procedures/stash.rb:23] state [running] 2025/03/22 19:50:42.587 (stash.rb:23): CHECK: '{&quot;one&quot;=&gt;1, &quot;two&quot;=&gt;2, &quot;string&quot;=&gt;&quot;string&quot;}' == '{&quot;one&quot;=&gt;1, &quot;two&quot;=&gt;2, &quot;string&quot;=&gt;&quot;string&quot;}' is TRUE At [INST/procedures/stash.rb:24] state [running] 2025/03/22 19:50:42.697 (SCRIPTRUNNER): Script completed: stash.rb At [INST/procedures/stash.rb:0] state [stopped] script complete %   ","version":"次へ","tagName":"h3"},{"title":"Validate​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#validate","content":" ValidateはビルドされたCOSMOSプラグインを検証するために使用されます。プラグインを実際にインストールせずにインストールプロセスをステップバイステップで実行します。  % openc3.sh cli validate openc3-cosmos-cfdp-1.0.0.gem Installing openc3-cosmos-cfdp-1.0.0.gem Successfully validated openc3-cosmos-cfdp-1.0.0.gem   ","version":"次へ","tagName":"h2"},{"title":"Load​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#load","content":" LoadはGUIを使用せずにプラグインをCOSMOSにロードできます。これはスクリプトやCI/CDパイプラインに役立ちます。  % openc3.sh cli load openc3-cosmos-cfdp-1.0.0.gem Loading new plugin: openc3-cosmos-cfdp-1.0.0.gem {&quot;name&quot;=&gt;&quot;openc3-cosmos-cfdp-1.0.0.gem&quot;, &quot;variables&quot;=&gt;{&quot;cfdp_microservice_name&quot;=&gt;&quot;CFDP&quot;, &quot;cfdp_route_prefix&quot;=&gt;&quot;/cfdp&quot;, &quot;cfdp_port&quot;=&gt;&quot;2905&quot;, &quot;cfdp_cmd_target_name&quot;=&gt;&quot;CFDP2&quot;, &quot;cfdp_cmd_packet_name&quot;=&gt;&quot;CFDP_PDU&quot;, &quot;cfdp_cmd_item_name&quot;=&gt;&quot;PDU&quot;, &quot;cfdp_tlm_target_name&quot;=&gt;&quot;CFDP2&quot;, &quot;cfdp_tlm_packet_name&quot;=&gt;&quot;CFDP_PDU&quot;, &quot;cfdp_tlm_item_name&quot;=&gt;&quot;PDU&quot;, &quot;source_entity_id&quot;=&gt;&quot;1&quot;, &quot;destination_entity_id&quot;=&gt;&quot;2&quot;, &quot;root_path&quot;=&gt;&quot;/DEFAULT/targets_modified/CFDP/tmp&quot;, &quot;bucket&quot;=&gt;&quot;config&quot;, &quot;plugin_test_mode&quot;=&gt;&quot;false&quot;}, &quot;plugin_txt_lines&quot;=&gt;[&quot;VARIABLE cfdp_microservice_name CFDP&quot;, &quot;VARIABLE cfdp_route_prefix /cfdp&quot;, &quot;VARIABLE cfdp_port 2905&quot;, &quot;&quot;, &quot;VARIABLE cfdp_cmd_target_name CFDP2&quot;, &quot;VARIABLE cfdp_cmd_packet_name CFDP_PDU&quot;, &quot;VARIABLE cfdp_cmd_item_name PDU&quot;, &quot;&quot;, &quot;VARIABLE cfdp_tlm_target_name CFDP2&quot;, &quot;VARIABLE cfdp_tlm_packet_name CFDP_PDU&quot;, &quot;VARIABLE cfdp_tlm_item_name PDU&quot;, &quot;&quot;, &quot;VARIABLE source_entity_id 1&quot;, &quot;VARIABLE destination_entity_id 2&quot;, &quot;VARIABLE root_path /DEFAULT/targets_modified/CFDP/tmp&quot;, &quot;VARIABLE bucket config&quot;, &quot;&quot;, &quot;# Set to true to enable a test configuration&quot;, &quot;VARIABLE plugin_test_mode \\&quot;false\\&quot;&quot;, &quot;&quot;, &quot;MICROSERVICE CFDP &lt;%= cfdp_microservice_name %&gt;&quot;, &quot; WORK_DIR .&quot;, &quot; ROUTE_PREFIX &lt;%= cfdp_route_prefix %&gt;&quot;, &quot; ENV OPENC3_ROUTE_PREFIX &lt;%= cfdp_route_prefix %&gt;&quot;, &quot; ENV SECRET_KEY_BASE 324973597349867207430793759437697498769349867349674&quot;, &quot; PORT &lt;%= cfdp_port %&gt;&quot;, &quot; CMD rails s -b 0.0.0.0 -p &lt;%= cfdp_port %&gt; -e production&quot;, &quot; # MIB Options Follow -&quot;, &quot; # You will need to modify these for your mission&quot;, &quot; OPTION source_entity_id &lt;%= source_entity_id %&gt;&quot;, &quot; OPTION tlm_info &lt;%= cfdp_tlm_target_name %&gt; &lt;%= cfdp_tlm_packet_name %&gt; &lt;%= cfdp_tlm_item_name %&gt;&quot;, &quot; OPTION destination_entity_id &lt;%= destination_entity_id %&gt;&quot;, &quot; OPTION cmd_info &lt;%= cfdp_cmd_target_name %&gt; &lt;%= cfdp_cmd_packet_name %&gt; &lt;%= cfdp_cmd_item_name %&gt;&quot;, &quot; OPTION root_path &lt;%= root_path %&gt;&quot;, &quot; &lt;% if bucket.to_s.strip != '' %&gt;&quot;, &quot; OPTION bucket &lt;%= bucket %&gt;&quot;, &quot; &lt;% end %&gt;&quot;, &quot;&quot;, &quot;&lt;% include_test = (plugin_test_mode.to_s.strip.downcase == \\&quot;true\\&quot;) %&gt;&quot;, &quot;&lt;% if include_test %&gt;&quot;, &quot; TARGET CFDPTEST CFDP&quot;, &quot; TARGET CFDPTEST CFDP2&quot;, &quot;&quot;, &quot; MICROSERVICE CFDP CFDP2&quot;, &quot; WORK_DIR .&quot;, &quot; ROUTE_PREFIX /cfdp2&quot;, &quot; ENV OPENC3_ROUTE_PREFIX /cfdp2&quot;, &quot; ENV SECRET_KEY_BASE 324973597349867207430793759437697498769349867349674&quot;, &quot; PORT 2906&quot;, &quot; CMD rails s -b 0.0.0.0 -p 2906 -e production&quot;, &quot; OPTION source_entity_id &lt;%= destination_entity_id %&gt;&quot;, &quot; OPTION tlm_info CFDP CFDP_PDU PDU&quot;, &quot; OPTION destination_entity_id &lt;%= source_entity_id %&gt;&quot;, &quot; OPTION cmd_info CFDP CFDP_PDU PDU&quot;, &quot; OPTION root_path &lt;%= root_path %&gt;&quot;, &quot; &lt;% if bucket.to_s.strip != '' %&gt;&quot;, &quot; OPTION bucket &lt;%= bucket %&gt;&quot;, &quot; &lt;% end %&gt;&quot;, &quot;&quot;, &quot; &lt;% test_host = ENV['KUBERNETES_SERVICE_HOST'] ? (scope.to_s.downcase + \\&quot;-interface-cfdp2-int-service\\&quot;) : \\&quot;openc3-operator\\&quot; %&gt;&quot;, &quot; INTERFACE CFDP_INT tcpip_client_interface.rb &lt;%= test_host %&gt; 2907 2907 10.0 nil LENGTH 0 32 4 1 BIG_ENDIAN 0 nil nil true&quot;, &quot; MAP_TARGET CFDP&quot;, &quot;&quot;, &quot; INTERFACE CFDP2_INT tcpip_server_interface.rb 2907 2907 10.0 nil LENGTH 0 32 4 1 BIG_ENDIAN 0 nil nil true&quot;, &quot; PORT 2907&quot;, &quot; MAP_TARGET CFDP2&quot;, &quot;&lt;% end %&gt;&quot;], &quot;needs_dependencies&quot;=&gt;false, &quot;updated_at&quot;=&gt;nil} Updating local plugin files: /plugins/DEFAULT/openc3-cosmos-cfdp   ","version":"次へ","tagName":"h2"},{"title":"List​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#list-1","content":" Listはインストールされているすべてのプラグインを表示します。  % openc3.sh cli list openc3-cosmos-cfdp-1.0.0.gem__20250325160956 openc3-cosmos-demo-6.2.2.pre.beta0.20250325143120.gem__20250325160201 openc3-cosmos-enterprise-tool-admin-6.2.2.pre.beta0.20250325155648.gem__20250325160159 openc3-cosmos-tool-autonomic-6.2.2.pre.beta0.20250325155658.gem__20250325160225 openc3-cosmos-tool-bucketexplorer-6.2.2.pre.beta0.20250325143107.gem__20250325160227 openc3-cosmos-tool-calendar-6.2.2.pre.beta0.20250325155654.gem__20250325160224 openc3-cosmos-tool-cmdhistory-6.2.2.pre.beta0.20250325155651.gem__20250325160212 openc3-cosmos-tool-cmdsender-6.2.2.pre.beta0.20250325143111.gem__20250325160211 openc3-cosmos-tool-cmdtlmserver-6.2.2.pre.beta0.20250325143114.gem__20250325160208 openc3-cosmos-tool-dataextractor-6.2.2.pre.beta0.20250325143104.gem__20250325160219 openc3-cosmos-tool-dataviewer-6.2.2.pre.beta0.20250325143108.gem__20250325160220 openc3-cosmos-tool-docs-6.2.2.pre.beta0.20250325155535.gem__20250325160228 openc3-cosmos-tool-grafana-6.2.2.pre.beta0.20250325155658.gem__20250325160233 openc3-cosmos-tool-handbooks-6.2.2.pre.beta0.20250325143113.gem__20250325160222 openc3-cosmos-tool-iframe-6.2.2.pre.beta0.20250325143110.gem__20250325160158 openc3-cosmos-tool-limitsmonitor-6.2.2.pre.beta0.20250325155448.gem__20250325160209 openc3-cosmos-tool-packetviewer-6.2.2.pre.beta0.20250325143104.gem__20250325160215 openc3-cosmos-tool-scriptrunner-6.2.2.pre.beta0.20250325143111.gem__20250325160214 openc3-cosmos-tool-tablemanager-6.2.2.pre.beta0.20250325143116.gem__20250325160223 openc3-cosmos-tool-tlmgrapher-6.2.2.pre.beta0.20250325143105.gem__20250325160218 openc3-cosmos-tool-tlmviewer-6.2.2.pre.beta0.20250325143108.gem__20250325160216 openc3-enterprise-tool-base-6.2.2.pre.beta0.20250325155704.gem__20250325160153   ","version":"次へ","tagName":"h2"},{"title":"Generate​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#generate","content":" Generateは新しいCOSMOSプラグイン、ターゲット、変換などを構築するために使用されます！詳細については、ジェネレーターページを参照してください。  ","version":"次へ","tagName":"h2"},{"title":"Bridge​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#bridge","content":" COSMOS Bridgeは、Dockerコンテナで利用できないハードウェアに接続するためにローカルコンピュータで実行される小さなアプリケーションです。良い例としては、非Linuxシステム上のシリアルポートへの接続があります。詳細については、ブリッジガイドを参照してください。  ","version":"次へ","tagName":"h2"},{"title":"Pkginstall と pkguninstall​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#pkginstall-と-pkguninstall","content":" RubyのgemやPythonのホイールをCOSMOSにインストールまたは削除することができます。これらは、COSMOSプラグイン自体にパッケージ化されていない依存関係です。  % openc3.sh cli pkginstall rspec-3.13.0.gem   ","version":"次へ","tagName":"h2"},{"title":"Rubysloc (非推奨)​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#rubysloc-非推奨","content":" 現在のディレクトリから再帰的にRubyのSource Lines of Code (SLOC)を計算します。任意のプログラミング言語で動作し、より多くの統計を計算し、非常に高速なsccを使用することをお勧めします。  ","version":"次へ","tagName":"h2"},{"title":"XTCE Converter​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#xtce-converter","content":" XTCE形式からCOSMOS形式への変換と、COSMOSプラグインからXTCEファイルをエクスポートします。  % openc3.sh cli xtce_converter Usage: xtce_converter [options] --import input_xtce_filename --output output_dir xtce_converter [options] --plugin /PATH/FILENAME.gem --output output_dir --variables variables.txt -h, --help このメッセージを表示 -i, --import VALUE 指定された.xtceファイルをインポート -o, --output DIRECTORY ディレクトリにファイルを作成 -p, --plugin PLUGIN プラグインから.xtceファイルをエクスポート -v, --variables プラグインに渡すオプションの変数ファイル   ","version":"次へ","tagName":"h2"},{"title":"CSTOL Converter​","type":1,"pageTitle":"コマンドラインインターフェース","url":"/ja/docs/getting-started/cli#cstol-converter","content":" Colorado System Test and Operations Language (CSTOL)からCOSMOS Script Runner Rubyスクリプトに変換します。現在、Pythonへの変換はサポートしていません。CSTOLファイル（*.prc）と同じディレクトリで実行するだけで、すべてのファイルを変換します。  % openc3.sh cli cstol_converter  ","version":"次へ","tagName":"h2"},{"title":"Contributing","type":0,"sectionRef":"#","url":"/ja/docs/meta/contributing","content":"","keywords":"","version":"次へ"},{"title":"Test Dependencies​","type":1,"pageTitle":"Contributing","url":"/ja/docs/meta/contributing#test-dependencies","content":" To run the test suite and build the gem you'll need to install COSMOS's dependencies. COSMOS uses Bundler, so a quick run of the bundle command and you're all set!  \\$ bundle   Before you start, run the tests and make sure that they pass (to confirm your environment is configured properly):  \\$ bundle exec rake build spec   ","version":"次へ","tagName":"h2"},{"title":"Workflow​","type":1,"pageTitle":"Contributing","url":"/ja/docs/meta/contributing#workflow","content":" Here's the most direct way to get your work merged into the project:  Fork the project.Clone down your fork:  git clone git://github.com/&lt;username&gt;/openc3.git   Create a topic branch to contain your change:  git checkout -b my_awesome_feature   Hack away, add tests. Not necessarily in that order.Make sure everything still passes by running bundle exec rake.If necessary, rebase your commits into logical chunks, without errors.Push the branch up:  git push origin my_awesome_feature   Create a pull request against openc3/cosmos:main and describe what your change does and the why you think it should be merged.  Find a problem in the code or documentation? Please create an issue on GitHub describing what we can do to make it better. ","version":"次へ","tagName":"h2"},{"title":"マイクロサービスの公開","type":0,"sectionRef":"#","url":"/ja/docs/guides/exposing-microservices","content":"","keywords":"","version":"次へ"},{"title":"PORTとROUTE_PREFIXキーワードを使用してマイクロサービスを公開する​","type":1,"pageTitle":"マイクロサービスの公開","url":"/ja/docs/guides/exposing-microservices#portとroute_prefixキーワードを使用してマイクロサービスを公開する","content":" plugin.txtファイルでは、INTERFACEとMICROSERVICEの両方がPORTとROUTE_PREFIXキーワードをサポートしています。  PORTは、マイクロサービスが接続をリッスンしているポートを宣言するために使用されます。これはROUTE_PREFIXと組み合わせて、マイクロサービスへの動的なtraefikルートを作成するために使用されます。  以下のコードは、traefikがマイクロサービスに内部で接続する場所を知らせるために内部的に使用されます：  if ENV['OPENC3_OPERATOR_HOSTNAME'] url = &quot;http://#{ENV['OPENC3_OPERATOR_HOSTNAME']}:#{port}&quot; else if ENV['KUBERNETES_SERVICE_HOST'] url = &quot;http://#{microservice_name.downcase.gsub('__', '-').gsub('_', '-')}-service:#{port}&quot; else url = &quot;http://openc3-operator:#{port}&quot; end end   これはマイクロサービスへの内部ルートであることに注意してください。このルートを決定するには、2つの異なる環境変数をチェックします。  OPENC3_OPERATOR_HOSTNAMEは、通常のdocker composeオペレータの「openc3-operator」のデフォルトサービス名を上書きするために使用されます。通常、これは設定されていません。  OpenC3 Enterpriseでは、KUBERNETES_SERVICE_HOSTはKubernetes環境で実行されているかどうかを検出するために使用されます（Kubernetesによって設定されます）。その場合、サービスはscope-user-microservicename-serviceという名前のKubernetesサービスを持つことが期待されます。例えば、DEFAULTスコープを使用していて、MYMICROSERVICEという名前のマイクロサービスがある場合、サービスはdefault-user-mymicroservice-serviceというホスト名で見つかります。二重アンダースコアまたは単一アンダースコアはダッシュに置き換えられ、名前はすべて小文字になります。  ROUTE_PREFIXは外部ルートを定義するために使用されます。外部ルートはhttp(s)://YOURCOSMOSDOMAIN:PORT/ROUTE_PREFIXという形式になります。例えば、ROUTE_PREFIXを/mymicroserviceに設定した場合、デフォルトのローカルインストールではhttp://localhost:2900/mymicroserviceでアクセスできます。http://localhost:2900の部分は、COSMOSにアクセスしているドメインで置き換える必要があります。  以下は、plugin.txtファイル内でPORTとROUTE_PREFIXを使用している例です：  VARIABLE cfdp_microservice_name CFDP VARIABLE cfdp_route_prefix /cfdp VARIABLE cfdp_port 2905 MICROSERVICE CFDP &lt;%= cfdp_microservice_name %&gt; WORK_DIR . ROUTE_PREFIX &lt;%= cfdp_route_prefix %&gt; PORT &lt;%= cfdp_port %&gt;   変数をデフォルト値のままにすると、以下のようになります：  マイクロサービスはDocker（オープンソースまたはEnterprise）に内部的にhttp://openc3-operator:2905で公開されますマイクロサービスはKubernetes（Enterprise）に内部的にhttp://default-user-cfdp-service:2905で公開されますマイクロサービスはネットワークに外部的にhttp://localhost:2900/cfdpで公開されます  同様のことがINTERFACEでも可能ですが、Kubernetesサービス名はSCOPE__INTERFACE__INTERFACENAMEの形式をとるインターフェースのマイクロサービス名を使用することに注意してください。  以下は、INTERFACEでPORTとROUTE_PREFIXを使用する例です：  VARIABLE my_interface_name MY_INT VARIABLE my_route_prefix /myint VARIABLE my_port 2910 INTERFACE &lt;%= my_interface_name %&gt; http_server_interface.rb &lt;%= my_port %&gt; ROUTE_PREFIX &lt;%= my_route_prefix %&gt; PORT &lt;%= my_port %&gt;   インターフェースはDocker（オープンソースまたはEnterprise）に内部的にhttp://openc3-operator:2910で公開されますインターフェースはKubernetes（Enterprise）に内部的にhttp://default-interface-my-int-service:2905で公開されますインターフェースはネットワークに外部的にhttp://localhost:2900/myintで公開されます  Kubernetesでのシャーディングされたオペレータ（Enterprise） シャーディングされたオペレータは、Kubernetesオペレータが使用されていない場合にKubernetesで使用されることが期待されています。通常、これはユーザーがKubernetes APIを直接使用してコンテナを起動する権限がないためです（これはKubernetesオペレータを使用するために必要です）。この場合、Kubernetesサービスは自動的に作成されず、Kubernetesでの権限を持つユーザーによって手動で作成されるか、他の承認された方法（カスタムフレームワークダッシュボードや設定ファイルなど）を通じて作成する必要があります。  ","version":"次へ","tagName":"h2"},{"title":"plugin.txtの異なるINTERFACEからマイクロサービスに接続する​","type":1,"pageTitle":"マイクロサービスの公開","url":"/ja/docs/guides/exposing-microservices#plugintxtの異なるinterfaceからマイクロサービスに接続する","content":" 時には、実行しているマイクロサービスにINTERFACEを接続したい場合があります。この場合、内部的に接続するだけでROUTE_PREFIXは使用されないため、INTERFACEまたはMICROSERVICEにはPORTキーワードのみが必要です。  デモプラグインから取得した以下のコードは、plugin.txtファイル内でオープンソースとEnterpriseの両方のCOSMOSバージョンで正しいホスト名を計算する方法の例を提供しています：   &lt;% example_host = ENV['KUBERNETES_SERVICE_HOST'] ? &quot;#{scope}-user-#{example_microservice_name.downcase.gsub('__', '-').gsub('_', '-')}-service&quot; : &quot;openc3-operator&quot; %&gt; INTERFACE &lt;%= example_int_name %&gt; example_interface.rb &lt;%= example_host %&gt; &lt;%= example_port %&gt; MAP_TARGET &lt;%= example_target_name %&gt;   上記のコードはOPENC3_OPERATOR_HOSTNAME環境変数を処理していないことに注意してください。これはopenc3-operatorのデフォルト名を変更する可能性があります。必要に応じて更新してください。 ","version":"次へ","tagName":"h2"},{"title":"COSMOSのハードウェア要件","type":0,"sectionRef":"#","url":"/ja/docs/guides/performance","content":"","keywords":"","version":"次へ"},{"title":"メモリ​","type":1,"pageTitle":"COSMOSのハードウェア要件","url":"/ja/docs/guides/performance#メモリ","content":" COSMOSは、Raspberry Piからクラウド上のKubernetesクラスタまで実行できます。すべてのプラットフォームで、主なパフォーマンス要因はターゲットの数と複雑さ、およびそれらが定義するパケットです。ターゲットは、100MBのRAMを使用する単純なものから、400MBを使用する複雑なものまでさまざまです。ベースとなるCOSMOSコンテナには約800MBのRAMが必要です。経験則として、ターゲットあたり平均約300MBのRAMを見積もるとよいでしょう。例として、COSMOSデモには4つのターゲットがあり、2つが複雑（INSTとINST2）、2つが比較的シンプル（EXAMPLEとTEMPLATED）で、800MBのRAMが必要です（ベースコンテナRAMの800MBに加えて）。  基本RAM MB計算式 = 800 + (ターゲット数) * 300  さらに、Redisストリームには、すべてのターゲットの生データとデコミュテーション（復調）データの過去10分間のデータが含まれています。したがって、実際のメモリ使用量のピークを確認するには約15分待つ必要があります。COSMOSデモでは、INSTとINST2ターゲットは比較的シンプルで、約15項目を持つ4つの1Hzパケットと、20項目を持つ1つの10Hzパケットがあります。docker statsによると、これはRedisのRAM使用量を50MiBにしかしません。各パケットに1000項目ある10個のパケットを10Hzで送信するCOSMOS LoadSimをインストールすると、Redisのメモリ使用量は約350MiBになりました。  ","version":"次へ","tagName":"h2"},{"title":"CPU​","type":1,"pageTitle":"COSMOSのハードウェア要件","url":"/ja/docs/guides/performance#cpu","content":" もう一つの考慮事項はCPUパフォーマンスです。オープンソース版では、デフォルトでCOSMOSはターゲットごとに2つのマイクロサービスを起動します。1つはパケットのロギングとデータのデコミュテーションを組み合わせ、もう1つはデータリダクションを実行します。Kubernetes上のCOSMOS Enterprise Editionでは、各プロセスはクラスタにデプロイされる独立したコンテナになり、水平スケーリングが可能になります。  COSMOSのコマンドとテレメトリAPIおよびスクリプト実行APIサーバーは専用のコアを持つべきですが、ターゲットは一般的にコアを共有できます。アーキテクチャ、クロックスピード、コア数が多様なため、一般的な目安を示すのは難しいです。ベストプラクティスは、予想される負荷でCOSMOSをインストールし、htopでモニタリングして様々なコアの負荷を視覚化することです。単一のコアが過負荷（100%）になるとシステムの遅延が発生する可能性があるため、これは懸念事項です。  ","version":"次へ","tagName":"h2"},{"title":"パフォーマンス比較​","type":1,"pageTitle":"COSMOSのハードウェア要件","url":"/ja/docs/guides/performance#パフォーマンス比較","content":" パフォーマンス特性評価は、Dockerごとの仮想化を可能にするために選択されたAzureのStandard D4s v5（4 vcpu、16 GiBメモリ）で実行されました。COSMOS 5.9.1 Enterprise EditionがWindows 11 Pro 1とUbuntu 22の両方にインストールされました。注意：Enterprise Editionはコンテナオーケストレーションにはコンテナエンジンを使用していて、Kubernetesは使っていません。テストでは、COSMOSデモを起動し、すべてのターゲット（EXAMPLE、INST、INST2、TEMPLATED）を接続し、次のTlmViewerスクリーン（ADCS、ARRAY、BLOCK、COMMANDING、HS、LATEST、LIMITS、OTHER、PARAMS、SIMPLE、TABS）を開き、INST HEALTH_STATUS TEMP[1-4]とINST ADCS POS[X,Y,Z]およびINST ADCS VEL[X,Y,Z]で構成される2つのTlmGrapherグラフを作成しました。これは1時間実行され、結果はhtopを使用して収集されました：  プラットフォーム\tコアCPU %\tRAMWindows 11 Pro\t12% 12% 10% 10%\t3.9G / 7.7G Headless Ubuntu 22\t7% 7% 8% 6%\t3.2G / 15.6G  Windowsは.wslconfig設定により、割り当てられたRAMが8GBのみでした。Ubuntuはヘッドレスで実行されていたため、画面とグラフは別のマシンで表示されました。  docker statsも実行され、個々のコンテナのCPUとメモリ使用量が表示されました：  名前\tWindows CPU %\tUbuntu CPU %\tWindows MEM\tUbuntu MEMcosmos-enterprise-project-openc3-traefik-1\t4.16%\t1.32%\t43.54MiB\t51.38MiB cosmos-enterprise-project-openc3-cosmos-cmd-tlm-api-1\t10.16%\t6.14%\t401.6MiB\t392MiB cosmos-enterprise-project-openc3-keycloak-1\t0.17%\t0.13%\t476.8MiB\t476.8MiB cosmos-enterprise-project-openc3-operator-1\t21.27%\t13.91%\t1.214GiB\t1.207GiB cosmos-enterprise-project-openc3-cosmos-script-runner-api-1\t0.01%\t0.01%\t127.4MiB\t117.1MiB cosmos-enterprise-project-openc3-metrics-1\t0.01%\t0.00%\t105.2MiB\t83.87MiB cosmos-enterprise-project-openc3-redis-ephemeral-1\t4.05%\t1.89%\t46.22MiB\t69.84MiB cosmos-enterprise-project-openc3-redis-1\t1.56%\t0.72%\t12.82MiB\t9.484MiB cosmos-enterprise-project-openc3-minio-1\t0.01%\t0.00%\t152.9MiB\t169.8MiB cosmos-enterprise-project-openc3-postgresql-1\t0.00%\t0.39%\t37.33MiB\t41.02MiB  メモリプロファイルは両プラットフォーム間で類似していますredis-ephemeralは小さなパケットを持つ基本デモではあまりメモリを使用していません  この時点で、デフォルト設定のCOSMOS LoadSimがインストールされ、それぞれに1000項目ある10個のパケットを10Hz（110kB/s）で生成します。1時間の実行後、htopは次のような結果を示しました：  プラットフォーム\tコアCPU %\tRAMWindows 11 Pro\t40% 35% 39% 42%\t4.64G / 7.7G Headless Ubuntu 22\t17% 20% 16% 18%\t3.74G / 15.6G  LoadSimターゲットの大きなパケットとデータレートにより、両プラットフォームでCPU使用率が劇的に増加しましたが、Linuxマシンはかなり高いパフォーマンスを維持しています。  docker statsも実行され、個々のコンテナのCPUとメモリ使用量が表示されました：  名前\tWindows CPU %\tUbuntu CPU %\tWindows MEM\tUbuntu MEMcosmos-enterprise-project-openc3-traefik-1\t4.09%\t0.01%\t44.3MiB\t0.34MiB cosmos-enterprise-project-openc3-cosmos-cmd-tlm-api-1\t17.78%\t6.18%\t407.9MiB\t405.8MiB cosmos-enterprise-project-openc3-keycloak-1\t0.20%\t0.12%\t480.2MiB\t481.5MiB cosmos-enterprise-project-openc3-operator-1\t221.15%\t66.72%\t1.6GiB\t1.512GiB cosmos-enterprise-project-openc3-cosmos-script-runner-api-1\t0.01%\t0.01%\t136.6MiB\t127.5MiB cosmos-enterprise-project-openc3-metrics-1\t0.01%\t0.01%\t106.3MiB\t84.87MiB cosmos-enterprise-project-openc3-redis-ephemeral-1\t19.63%\t3.91%\t333.8MiB\t370.8MiB cosmos-enterprise-project-openc3-redis-1\t7.42%\t1.49%\t15.87MiB\t11.81MiB cosmos-enterprise-project-openc3-minio-1\t0.10%\t0.02%\t167.8MiB\t179.2MiB cosmos-enterprise-project-openc3-postgresql-1\t0.00%\t0.00%\t35.4MiB\t42.93MiB  メモリプロファイルは両プラットフォーム間で類似していますredis-ephemeralは大きなLoadSimパケットを保存しているため、より多くのRAMを使用していますWindowsはオペレータ、cmd-tlm、redisの実行に多くのCPUパワーを使用しています  結論  どのDockerプラットフォームでもCOSMOSを実行するのは簡単ですが、ターゲットの数と複雑さを増やすには、適切なハードウェアを選択する必要があります。サイジングは概算できますが、最良の解決策は代表的なターゲットをインストールし、docker statsとhtopを使用して特定のハードウェア上のCPUとメモリの負荷を判断することです。  Kubernetes上のCOSMOS Enterprise Editionは、システムのニーズを満たすためにクラスタをスケーリングすることで、ハードウェアサイジングの問題を解消するのに役立ちます。RyanがGSAWで行った最近の講演をチェックして、EKS上の4ノードKubernetesクラスタで160以上の衛星にスケールした方法を確認してください。      Footnotes​ Windows プラットフォームの詳細仕様： Windows 11 Pro Docker Desktop 4.22.0 WSL version: 1.2.5.0 Kernel version: 5.15.90.1 WSLg version: 1.0.51 MSRDC version: 1.2.3770 Direct3D version: 1.608.2-61064218 DXCore version: 10.0.25131.1002-220531-1700.rs-onecore-base2-hyp Windows version: 10.0.22621.2134 ↩ ","version":"次へ","tagName":"h2"},{"title":"COSMOSとNASA cFS","type":0,"sectionRef":"#","url":"/ja/docs/guides/cfs","content":"","keywords":"","version":"次へ"},{"title":"動作確認済み構成​","type":1,"pageTitle":"COSMOSとNASA cFS","url":"/ja/docs/guides/cfs#動作確認済み構成","content":" このチュートリアルは、以下のコンポーネントを使用してテストされています：  COSMOS v5リリース 5.0.6cFS masterブランチコミット: 561b128 (2022年6月1日)Docker Desktop 4.9.0 on Windows  すべての &lt;xxxxxx&gt; を対応するパスや名前に置き換えてください。例：&lt;USERNAME&gt;。  ","version":"次へ","tagName":"h2"},{"title":"COSMOSのセットアップ​","type":1,"pageTitle":"COSMOSとNASA cFS","url":"/ja/docs/guides/cfs#cosmosのセットアップ","content":" 公式のインストール手順に従ってCOSMOSをインストールします。  ","version":"次へ","tagName":"h2"},{"title":"COSMOSの設定​","type":1,"pageTitle":"COSMOSとNASA cFS","url":"/ja/docs/guides/cfs#cosmosの設定","content":" NASA cFSとの相互運用性のためにDocker設定を変更します。テレメトリをサブスクライブするには、compose.yamlファイルのopenc3-operatorセクションにポートバインディングを追加する必要があります。 ポート番号はcFSがテレメトリを送信するポート番号と一致させる必要があります。  openc3-operator: ports: - &quot;1235:1235/udp&quot;   COSMOSを実行します。初回の実行には時間がかかります（約15分）。  openc3.sh start   起動したら、ブラウザでhttp://localhost:2900に接続します。  COSMOSをシャットダウンするには：  openc3.sh stop   ","version":"次へ","tagName":"h3"},{"title":"cFSのセットアップ​","type":1,"pageTitle":"COSMOSとNASA cFS","url":"/ja/docs/guides/cfs#cfsのセットアップ","content":" NASA cFSをDockerコンテナとして実行するには、以下の手順を実行します：  ","version":"次へ","tagName":"h2"},{"title":"cFSのクローン​","type":1,"pageTitle":"COSMOSとNASA cFS","url":"/ja/docs/guides/cfs#cfsのクローン","content":" git clone --recurse-submodules https://github.com/nasa/cFS.git   ","version":"次へ","tagName":"h3"},{"title":"cFSディレクトリにDockerfileを作成​","type":1,"pageTitle":"COSMOSとNASA cFS","url":"/ja/docs/guides/cfs#cfsディレクトリにdockerfileを作成","content":" FROM ubuntu:22.10 AS builder ARG DEBIAN_FRONTEND=noninteractive ARG SIMULATION=native ENV SIMULATION=${SIMULATION} ARG BUILDTYPE=debug ENV BUILDTYPE=${BUILDTYPE} ARG OMIT_DEPRECATED=true ENV OMIT_DEPRECATED=${OMIT_DEPRECATED} RUN \\ apt-get update &amp;&amp; \\ apt-get -y upgrade &amp;&amp; \\ apt-get install -y build-essential git cmake &amp;&amp; \\ rm -rf /var/lib/apt/lists/* WORKDIR /cFS COPY . . RUN git submodule init \\ &amp;&amp; git submodule update \\ &amp;&amp; cp cfe/cmake/Makefile.sample Makefile \\ &amp;&amp; cp -r cfe/cmake/sample_defs . RUN make prep RUN make RUN make install FROM ubuntu:22.10 COPY --from=builder /cFS/build /cFS/build WORKDIR /cFS/build/exe/cpu1 ENTRYPOINT [ &quot;./core-cpu1&quot; ]   ","version":"次へ","tagName":"h3"},{"title":"cFSのビルドと実行​","type":1,"pageTitle":"COSMOSとNASA cFS","url":"/ja/docs/guides/cfs#cfsのビルドと実行","content":" COSMOSネットワーク（docker network lsで確認できます）に接続し、cFSポートを公開していることに注意してください。  docker build -t cfs . docker run --cap-add CAP_SYS_RESOURCE --net=openc3-cosmos-network --name cfs -p1234:1234/udp -p1235:1235 cfs   ","version":"次へ","tagName":"h3"},{"title":"cFSとのTM/TCインターフェース用COSMOSプラグインの作成​","type":1,"pageTitle":"COSMOSとNASA cFS","url":"/ja/docs/guides/cfs#cfsとのtmtcインターフェース用cosmosプラグインの作成","content":" プラグインの作成に関する詳細な手順は、こちらの「ハードウェアとのインターフェース」の章にあります。  CFSという名前で新しいプラグインを作成します。COSMOSドキュメントによると、CFSはプラグイン名であり、 大文字である必要があります。このコマンドはプラグイン構造を作成するはずです。 その後、プラグインのディレクトリに移動してターゲットを作成します。  # cd .. でcfsディレクトリの場所に移動 $PATH_TO_OPENC3/openc3.sh cli generate plugin CFS cd openc3-cosmos-cfs $PATH_TO_OPENC3/openc3.sh cli generate target CFS   この新しく作成されたプラグインで、plugin.txtファイルを変更して、 通信がUDP経由で行われるようにします。port_tmはcFSがテレメトリメッセージを送信するポート番号です。port_tcはcFSがテレコマンドをリッスンするポートを示します。  VARIABLE ip 127.0.0.1 VARIABLE port_tm 1235 VARIABLE port_tc 1234 VARIABLE cfs_target_name CFS TARGET CFS &lt;%= cfs_target_name %&gt; # hostname write_dest_port read_port write_src_port interface_address ttl write_timeout read_timeout bind_address INTERFACE &lt;%= cfs_target_name %&gt;_INT udp_interface.rb &lt;%= ip %&gt; &lt;%= port_tc %&gt; &lt;%= port_tm %&gt; nil nil 128 nil nil MAP_TARGET &lt;%= cfs_target_name %&gt;   TARGETパラメータへの2つの引数に注意してください：  プラグインの名前と一致する物理ターゲット名、つまりCFS。 この名前はtargetsフォルダ内のフォルダ名と一致する必要があります。例：CFSプラグインでは、ターゲット仕様はopenc3-cfs/targets/CFSにある必要があります。この 規則に従わない場合、サーバーは次のステップでプラグインのインストールを拒否します。 ターゲットの名前と、それがユーザーインターフェースでどのように表示されるか。  この例では、両方の名前をCFSにしています。  ","version":"次へ","tagName":"h2"},{"title":"TM/TC定義の作成​","type":1,"pageTitle":"COSMOSとNASA cFS","url":"/ja/docs/guides/cfs#tmtc定義の作成","content":" ターゲットフォルダに移動し、既存のファイルを削除して独自のファイルを作成します。  cd openc3-cfs/targets/CFS/cmd_tlm rm * touch cfs_cmds.txt touch cfs_tlm.txt touch to_lab_cmds.txt   これらの新しく作成されたファイルをテキストエディタで開き、以下の内容を入力します。  to_lab_cmds.txt：  COMMAND CFS TO_LAB_ENABLE BIG_ENDIAN &quot;Enable telemetry&quot; # NAME BITS TYPE min VAL max VAL init VAL DESCRIPTION APPEND_ID_PARAMETER STREAM_ID 16 UINT 0x1880 0x1880 0x1880 &quot;Stream ID&quot; FORMAT_STRING &quot;0x%04X&quot; APPEND_PARAMETER SEQUENCE 16 UINT 0xC000 MAX_UINT16 0xC000 &quot;&quot; FORMAT_STRING &quot;0x%04X&quot; APPEND_PARAMETER PKT_LEN 16 UINT 0x0001 0xFFFF 0x0012 &quot;length of the packet&quot; APPEND_PARAMETER CMD_ID 8 UINT 6 6 6 &quot;&quot; APPEND_PARAMETER CHECKSUM 8 UINT MIN_UINT8 MAX_UINT8 0x98 &quot;&quot; FORMAT_STRING &quot;0x%2X&quot; APPEND_PARAMETER DEST_IP 144 STRING &quot;127.0.0.1&quot; &quot;Destination IP, i.e. 172.16.9.112, pc-57&quot;   テレメトリの有効化 コマンド0x1880はテレメトリを有効にするために必要です。cFSがこのコマンドを受信すると、DEST_IPフィールドで提供されたIPアドレスにテレメトリの送信を開始します。  cfs_cmds.txt：  COMMAND CFS NOOP BIG_ENDIAN &quot;NOOP Command&quot; # cFS primary header APPEND_ID_PARAMETER STREAM_ID 16 UINT 0x1882 0x1882 0x1882 &quot;Packet Identification&quot; FORMAT_STRING &quot;0x%04X&quot; APPEND_PARAMETER SEQUENCE 16 UINT MIN_UINT16 MAX_UINT16 0xC000 &quot;&quot; FORMAT_STRING &quot;0x%04X&quot; APPEND_PARAMETER PKT_LEN 16 UINT 0x0001 0x0001 0x0001 &quot;Packet length&quot; # cFS CMD secondary header APPEND_PARAMETER CMD_ID 8 UINT 0 0 0 &quot;&quot; APPEND_PARAMETER CHECKSUM 8 UINT MIN_UINT8 MAX_UINT8 MIN_UINT8 &quot;&quot; COMMAND CFS RESET BIG_ENDIAN &quot;Reset Counters Command&quot; APPEND_ID_PARAMETER STREAM_ID 16 UINT 0x1882 0x1882 0x1882 &quot;Packet Identification&quot; FORMAT_STRING &quot;0x%04X&quot; APPEND_PARAMETER SEQUENCE 16 UINT MIN_UINT16 MAX_UINT16 0xC000 &quot;&quot; FORMAT_STRING &quot;0x%04X&quot; APPEND_PARAMETER PKT_LEN 16 UINT 0x0001 0x0001 0x0001 &quot;Packet length&quot; APPEND_PARAMETER CMD_ID 8 UINT 1 1 1 &quot;&quot; APPEND_PARAMETER CHECKSUM 8 UINT MIN_UINT8 MAX_UINT8 MIN_UINT8 &quot;&quot; COMMAND CFS PROCESS BIG_ENDIAN &quot;Process Command&quot; APPEND_ID_PARAMETER STREAM_ID 16 UINT 0x1882 0x1882 0x1882 &quot;Packet Identification&quot; FORMAT_STRING &quot;0x%04X&quot; APPEND_PARAMETER SEQUENCE 16 UINT MIN_UINT16 MAX_UINT16 0xC000 &quot;&quot; FORMAT_STRING &quot;0x%04X&quot; APPEND_PARAMETER PKT_LEN 16 UINT 0x0001 0x0001 0x0001 &quot;Packet length&quot; APPEND_PARAMETER CMD_ID 8 UINT 2 2 2 &quot;&quot; APPEND_PARAMETER CHECKSUM 8 UINT MIN_UINT8 MAX_UINT8 MIN_UINT8 &quot;&quot;   cfs_tlm.txt：  TELEMETRY CFS HK BIG_ENDIAN &quot;housekeeping telemetry&quot; # NAME BITS TYPE ID DESCRIPTION APPEND_ID_ITEM STREAM_ID 16 UINT 0x0883 &quot;Stream ID&quot; FORMAT_STRING &quot;0x%04X&quot; APPEND_ITEM SEQUENCE 16 UINT &quot;Packet Sequence&quot; FORMAT_STRING &quot;0x%04X&quot; APPEND_ITEM PKT_LEN 16 UINT &quot;Length of the packet&quot; # telemetry secondary header APPEND_ITEM SECONDS 32 UINT &quot;&quot; UNITS Seconds sec APPEND_ITEM SUBSECS 16 UINT &quot;&quot; UNITS Milliseconds ms # some bytes not known for what APPEND_ITEM SPARE2ALIGN 32 UINT &quot;Spares&quot; # payload APPEND_ITEM CMD_ERRS 8 UINT &quot;Command Error Counter&quot; APPEND_ITEM CMD_CNT 8 UINT &quot;Command Counter&quot; # spare / alignment APPEND_ITEM SPARE 16 UINT &quot;Spares&quot;   プラグインフォルダのベースからプラグインをビルドします：  # cd openc3-cfs $PATH_TO_OPENC3/openc3.sh cli rake build VERSION=1.0.0   プラグインのバージョン管理 プラグインのバージョン間をより簡単に区別したい場合は、ビルドごとにバージョン番号を変更するのを忘れないでください。 バージョンがプラグインの.gemファイル名に表示されると、既存のバージョンと新しくアップロードされたバージョンを 視覚化しやすくなります。  プラグインパラメータ プラグイン設定には複数のパラメータが利用可能です。プラグインページを参照してください。  ","version":"次へ","tagName":"h2"},{"title":"プラグインのアップロード​","type":1,"pageTitle":"COSMOSとNASA cFS","url":"/ja/docs/guides/cfs#プラグインのアップロード","content":" プラグインがビルドされたら、ページの管理エリアでプラグインをインポートできます。  ブラウザでhttp://localhost:2900/tools/adminに接続します。  クリップアイコンをクリックし、プラグインが保存されている場所に移動してopenc3-cosmos-cfs-1.0.0.gemファイルを選択します。選択行の右側にあるUPLOADをクリックします。  cFSコンテナとCOSMOS operatorコンテナが実行されているIPアドレスを確認します：  docker network ls NETWORK ID NAME DRIVER SCOPE d842f813f1c7 openc3-cosmos-network bridge local docker network inspect openc3-cosmos-network [ { &quot;Name&quot;: &quot;openc3-cosmos-network&quot;, ... &quot;Containers&quot;: { &quot;03cb6bf1b27c631fad1366e9342aeaa5b80f458a437195e4a95e674bb5f5983d&quot;: { &quot;Name&quot;: &quot;cfs&quot;, &quot;IPv4Address&quot;: &quot;172.20.0.9/16&quot;, }, &quot;ceb9ea99b00849fd8867dcd1646838fef3471f7d64b69014703dbedbcc8147fc&quot;: { &quot;Name&quot;: &quot;openc3_openc3-operator_1&quot;, &quot;IPv4Address&quot;: &quot;172.20.0.8/16&quot;, } } ... } ]   このプラグインを使用する際は、アップロード時にip変数をcFSが実行されている場所に合わせて変更してください。 上記の例では、172.20.0.9に設定します。port_tmはcFSがテレメトリメッセージを送信するポート番号です。port_tcはcFSがテレコマンドをリッスンしているポートを示します。  cfs_target_nameでこのプラグインのターゲット名を変更できます。 プラグインがCFSとして表示されることに問題がなければ、このステップはオプションです。    ポートサブスクリプション COSMOS上で最後にアップロードされたプラグインがポート1235でテレメトリをサブスクライブします。 他のプラグインはテレメトリを受信しなくなります。  タイプミスエラー プラグインファイルの一つにタイプミスがあると、プラグインの.gemファイルのアップロードとインストール時に 問題が発生する可能性があります。設定にタイプミスがないことを確認してください。  上記の例では、operatorイメージは172.20.0.8で実行されています。テレメトリを有効にするには、ブラウザでhttp://localhost:2900/tools/cmdsender/CFS/TO_LAB_ENABLEに接続します。DEST_IPをoperatorイメージのIPアドレス（172.20.0.8）に変更し、コマンドを送信します。  http://localhost:2900/tools/cmdtlmserver/tlm-packetsで、 受信パケットが表示されるはずです。CmdTlmServerでは、CFS_INT UNKNOWNパケットも表示されることに注意してください。 これは完全なcFSパケットセットを定義していないためです。この演習は読者に委ねられています。 ","version":"次へ","tagName":"h2"},{"title":"アクセサー","type":0,"sectionRef":"#","url":"/ja/docs/configuration/accessors","content":"","keywords":"","version":"次へ"},{"title":"バイナリアクセサー​","type":1,"pageTitle":"アクセサー","url":"/ja/docs/configuration/accessors#バイナリアクセサー","content":" バイナリアクセサーは、バッファに書き込む際にデータをバイナリ形式にシリアル化します。これは、CCSDSスタンダードに従うものを含む多くのデバイスがデータを期待する方法です。COSMOSは、符号付きおよび符号なし整数、浮動小数点、文字列などをバッファ内のバイナリ表現に変換します。これにはビッグエンディアンとリトルエンディアン、ビットフィールド、可変長フィールドの処理が含まれます。バイナリは非常に一般的であるため、これはデフォルトのアクセサーであり、他のアクセサーが指定されていない場合に使用されます。  コマンド​  COMMAND INST COLLECT BIG_ENDIAN &quot;Starts a collect&quot; ACCESSOR BinaryAccessor # デフォルトであるため通常は明示的に定義されません PARAMETER TYPE 64 16 UINT MIN MAX 0 &quot;Collect type&quot; PARAMETER DURATION 80 32 FLOAT 0.0 10.0 1.0 &quot;Collect duration&quot; PARAMETER OPCODE 112 8 UINT 0x0 0xFF 0xAB &quot;Collect opcode&quot;   テレメトリ​  TELEMETRY INST HEALTH_STATUS BIG_ENDIAN &quot;Health and status&quot; ACCESSOR BinaryAccessor # デフォルトであるため通常は明示的に定義されません APPEND_ITEM CMD_ACPT_CNT 32 UINT &quot;Command accept count&quot; APPEND_ITEM COLLECTS 16 UINT &quot;Number of collects&quot; APPEND_ITEM DURATION 32 FLOAT &quot;Most recent collect duration&quot;   ","version":"次へ","tagName":"h3"},{"title":"CBORアクセサー​","type":1,"pageTitle":"アクセサー","url":"/ja/docs/configuration/accessors#cborアクセサー","content":" Concise Binary Object Representation（CBOR）アクセサーは、ゆるくJSONに基づいたバイナリ形式にデータをシリアル化します。これはJSONアクセサーのサブクラスであり、COSMOSがログファイルを保存するためにネイティブに使用するものです。  コマンド​  コマンド定義でCBORアクセサーを使用するには、TEMPLATE_FILEとKEYを使用して、ユーザーがCBORデータ内の値を設定できるようにする必要があります。KEYの値はJSONPathを使用していることに注意してください。  COMMAND CBOR CBORCMD BIG_ENDIAN &quot;CBOR Accessor Command&quot; ACCESSOR CborAccessor TEMPLATE_FILE _cbor_template.bin APPEND_ID_PARAMETER ID_ITEM 32 INT 2 2 2 &quot;Int Item&quot; KEY $.id_item APPEND_PARAMETER ITEM1 16 UINT MIN MAX 101 &quot;Int Item 2&quot; KEY $.item1 UNITS CELSIUS C APPEND_PARAMETER ITEM2 16 UINT MIN MAX 12 &quot;Int Item 3&quot; KEY $.more.item2 FORMAT_STRING &quot;0x%X&quot; APPEND_PARAMETER ITEM3 64 FLOAT MIN MAX 3.14 &quot;Float Item&quot; KEY $.more.item3 APPEND_PARAMETER ITEM4 128 STRING &quot;Example&quot; &quot;String Item&quot; KEY $.more.item4 APPEND_ARRAY_PARAMETER ITEM5 8 UINT 0 &quot;Array Item&quot; KEY $.more.item5   テンプレートファイルを作成するには、RubyまたはPythonのCBORライブラリを使用する必要があります。Rubyからの例を以下に示します：  require 'cbor' data = {&quot;id_item&quot; : 2, &quot;item1&quot; : 101, &quot;more&quot; : { &quot;item2&quot; : 12, &quot;item3&quot; : 3.14, &quot;item4&quot; : &quot;Example&quot;, &quot;item5&quot; : [4, 3, 2, 1] } } File.open(&quot;_cbor_template.bin&quot;, 'wb') do |file| file.write(data.to_cbor) end   テレメトリ​  テレメトリ定義でCBORアクセサーを使用するには、KEYを使用してCBORデータから値を取得するだけで済みます。KEYの値はJSONPathを使用していることに注意してください。  TELEMETRY CBOR CBORTLM BIG_ENDIAN &quot;CBOR Accessor Telemetry&quot; ACCESSOR CborAccessor APPEND_ID_ITEM ID_ITEM 32 INT 2 &quot;Int Item&quot; KEY $.id_item APPEND_ITEM ITEM1 16 UINT &quot;Int Item 2&quot; KEY $.item1 GENERIC_READ_CONVERSION_START UINT 16 value * 2 GENERIC_READ_CONVERSION_END UNITS CELSIUS C APPEND_ITEM ITEM2 16 UINT &quot;Int Item 3&quot; KEY $.more.item2 FORMAT_STRING &quot;0x%X&quot; APPEND_ITEM ITEM3 64 FLOAT &quot;Float Item&quot; KEY $.more.item3 APPEND_ITEM ITEM4 128 STRING &quot;String Item&quot; KEY $.more.item4 APPEND_ARRAY_ITEM ITEM5 8 UINT 0 &quot;Array Item&quot; KEY $.more.item5   ","version":"次へ","tagName":"h3"},{"title":"フォームアクセサー​","type":1,"pageTitle":"アクセサー","url":"/ja/docs/configuration/accessors#フォームアクセサー","content":" フォームアクセサーは通常、HTTPクライアントインターフェースで使用され、リモートHTTPサーバーにフォームを送信します。  コマンド​  コマンド定義でフォームアクセサーを使用するには、KEYを使用して、ユーザーがHTTPフォーム内の値を設定できるようにする必要があります。KEYの値はXPathを使用していることに注意してください。  COMMAND FORM FORMCMD BIG_ENDIAN &quot;Form Accessor Command&quot; ACCESSOR FormAccessor APPEND_ID_PARAMETER ID_ITEM 32 INT 2 2 2 &quot;Int Item&quot; KEY $.id_item APPEND_PARAMETER ITEM1 16 UINT MIN MAX 101 &quot;Int Item 2&quot; KEY $.item1 UNITS CELSIUS C   テレメトリ​  テレメトリ定義でフォームアクセサーを使用するには、KEYを使用してHTTPレスポンスデータから値を取得するだけで済みます。KEYの値はXPathを使用していることに注意してください。  TELEMETRY FORM FORMTLM BIG_ENDIAN &quot;Form Accessor Telemetry&quot; ACCESSOR FormAccessor APPEND_ID_ITEM ID_ITEM 32 INT 1 &quot;Int Item&quot; KEY $.id_item APPEND_ITEM ITEM1 16 UINT &quot;Int Item 2&quot; KEY $.item1   ","version":"次へ","tagName":"h3"},{"title":"HTMLアクセサー​","type":1,"pageTitle":"アクセサー","url":"/ja/docs/configuration/accessors#htmlアクセサー","content":" HTMLアクセサーは通常、HTTPクライアントインターフェースでウェブページを解析するために使用されます。  完全な例については、openc3-cosmos-http-getを参照してください。  コマンド​  HTMLアクセサーは通常コマンドには使用されませんが、XPathキーを使用するテレメトリと同様になります。  テレメトリ​  TELEMETRY HTML RESPONSE BIG_ENDIAN &quot;Search results&quot; # 通常、返されるページを解析するためにHtmlAccessorを使用します # HtmlAccessorはHttpAccessorに渡され、内部で使用されます ACCESSOR HttpAccessor HtmlAccessor APPEND_ITEM NAME 240 STRING # キーは手動検索を行い、ページを調査して見つけました # 探しているテキストを右クリックし、コピー -&gt; XPathをコピー KEY normalize-space(//main/div/a[2]/span/h2/text()) APPEND_ITEM DESCRIPTION 480 STRING KEY //main/div/a[2]/span/p/text() APPEND_ITEM VERSION 200 STRING KEY //main/div/a[2]/span/h2/span/text() APPEND_ITEM DOWNLOADS 112 STRING KEY normalize-space(//main/div/a[2]/p/text())   ","version":"次へ","tagName":"h3"},{"title":"HTTPアクセサー​","type":1,"pageTitle":"アクセサー","url":"/ja/docs/configuration/accessors#http-accessor","content":" HTTPアクセサーは通常、HTTPクライアントまたはHTTPサーバーインターフェースでウェブページを解析するために使用されます。アイテムの低レベルの読み書きを行うために別のアクセサーを取ります。デフォルトのアクセサーはFormAccessorです。HtmlAccessor、XmlAccessor、JsonAccessorもHTML、XML、JSONをそれぞれ操作するために一般的です。  完全な例については、openc3-cosmos-http-getを参照してください。  コマンド​  HTTPクライアントインターフェースで使用する場合、HTTPアクセサーは以下のコマンドパラメータを利用します：  パラメータ\t説明HTTP_PATH\tこのパスでリクエスト HTTP_METHOD\tリクエストメソッド（GET、POST、DELETE） HTTP_PACKET\tレスポンスを格納するテレメトリパケット HTTP_ERROR_PACKET\tエラーレスポンス（ステータスコード &gt;= 300）を格納するテレメトリパケット HTTP_QUERY_XXX\tリクエストに渡されるパラメータに値を設定（XXX =&gt; 値、またはKEY =&gt; 値）、下の例を参照 HTTP_HEADER_XXX\tリクエストに渡されるヘッダーに値を設定（XXX =&gt; 値、またはKEY =&gt; 値）、下の例を参照  HTTPサーバーインターフェースで使用する場合、HTTPアクセサーは以下のコマンドパラメータを利用します：  パラメータ\t説明HTTP_STATUS\tクライアントに返すステータス HTTP_PATH\tサーバーのマウントポイント HTTP_PACKET\tリクエストを格納するテレメトリパケット HTTP_HEADER_XXX\tレスポンスヘッダーに値を設定（XXX =&gt; 値、またはKEY =&gt; 値）、下の例を参照  COMMAND HTML SEARCH BIG_ENDIAN &quot;Searches Rubygems.org&quot; # FormAccessorはHttpAccessorのデフォルト引数であるため、通常は指定されません ACCESSOR HttpAccessor PARAMETER HTTP_PATH 0 0 DERIVED nil nil &quot;/search&quot; PARAMETER HTTP_METHOD 0 0 DERIVED nil nil &quot;GET&quot; PARAMETER HTTP_PACKET 0 0 DERIVED nil nil &quot;RESPONSE&quot; PARAMETER HTTP_ERROR_PACKET 0 0 DERIVED nil nil &quot;ERROR&quot; # これはパラメータquery=openc3+cosmosを設定します # HTTP_QUERY_QUERYに基づいてパラメータ名「query」に注目 PARAMETER HTTP_QUERY_QUERY 0 0 DERIVED nil nil &quot;openc3 cosmos&quot; GENERIC_READ_CONVERSION_START value.split.join('+') GENERIC_READ_CONVERSION_END # これはヘッダーContent-Type=text/htmlを設定します # KEYが指定されているためTYPEは使用されません PARAMETER HTTP_HEADER_TYPE 0 0 DERIVED nil nil &quot;text/html&quot; KEY Content-Type   テレメトリ​  HTTPアクセサーは以下のテレメトリアイテムを利用します：  パラメータ\t説明HTTP_STATUS\tリクエストステータス HTTP_HEADERS\tレスポンスヘッダーのハッシュ HTTP_REQUEST\tすべてのリクエストパラメータを返すオプショナルハッシュ、HTTPクライアントインターフェースを参照  TELEMETRY HTML RESPONSE BIG_ENDIAN &quot;Search results&quot; # 通常、返されるページを解析するためにHtmlAccessorを使用します ACCESSOR HttpAccessor HtmlAccessor APPEND_ITEM NAME 240 STRING # キーは手動検索を行い、ページを調査して見つけました # 探しているテキストを右クリックし、コピー -&gt; XPathをコピー KEY normalize-space(//main/div/a[2]/span/h2/text()) APPEND_ITEM DESCRIPTION 480 STRING KEY //main/div/a[2]/span/p/text() APPEND_ITEM VERSION 200 STRING KEY //main/div/a[2]/span/h2/span/text() APPEND_ITEM DOWNLOADS 112 STRING KEY normalize-space(//main/div/a[2]/p/text())   ","version":"次へ","tagName":"h3"},{"title":"JSONアクセサー​","type":1,"pageTitle":"アクセサー","url":"/ja/docs/configuration/accessors#json-accessor","content":" JSONアクセサーは、JavaScript Object Notation（JSON）形式にデータをシリアル化します。JSONは、キーと値のペアや配列からなるデータを送信するために、人間が読める形式のテキストを使用するデータ交換形式です。  完全な例については、openc3-cosmos-accessor-testを参照してください。  コマンド​  コマンド定義でJSONアクセサーを使用するには、TEMPLATEとKEYを使用して、ユーザーがJSONデータ内の値を設定できるようにする必要があります。KEYの値はJSONPathを使用していることに注意してください。  COMMAND JSON JSONCMD BIG_ENDIAN &quot;JSON Accessor Command&quot; ACCESSOR JsonAccessor TEMPLATE '{&quot;id_item&quot;:1, &quot;item1&quot;:101, &quot;more&quot;: { &quot;item2&quot;:12, &quot;item3&quot;:3.14, &quot;item4&quot;:&quot;Example&quot;, &quot;item5&quot;:[4, 3, 2, 1] } }' APPEND_ID_PARAMETER ID_ITEM 32 INT 2 2 2 &quot;Int Item&quot; KEY $.id_item APPEND_PARAMETER ITEM1 16 UINT MIN MAX 101 &quot;Int Item 2&quot; KEY $.item1 UNITS CELSIUS C APPEND_PARAMETER ITEM2 16 UINT MIN MAX 12 &quot;Int Item 3&quot; KEY $.more.item2 FORMAT_STRING &quot;0x%X&quot; APPEND_PARAMETER ITEM3 64 FLOAT MIN MAX 3.14 &quot;Float Item&quot; KEY $.more.item3 APPEND_PARAMETER ITEM4 128 STRING &quot;Example&quot; &quot;String Item&quot; KEY $.more.item4 APPEND_ARRAY_PARAMETER ITEM5 8 UINT 0 &quot;Array Item&quot; KEY $.more.item5   テレメトリ​  テレメトリ定義でJSONアクセサーを使用するには、KEYを使用してJSONデータから値を取得するだけで済みます。KEYの値はJSONPathを使用していることに注意してください。  TELEMETRY JSON JSONTLM BIG_ENDIAN &quot;JSON Accessor Telemetry&quot; ACCESSOR JsonAccessor APPEND_ID_ITEM ID_ITEM 32 INT 1 &quot;Int Item&quot; KEY $.id_item APPEND_ITEM ITEM1 16 UINT &quot;Int Item 2&quot; KEY $.item1 GENERIC_READ_CONVERSION_START UINT 16 value * 2 GENERIC_READ_CONVERSION_END UNITS CELSIUS C APPEND_ITEM ITEM2 16 UINT &quot;Int Item 3&quot; KEY $.more.item2 FORMAT_STRING &quot;0x%X&quot; APPEND_ITEM ITEM3 64 FLOAT &quot;Float Item&quot; KEY $.more.item3 APPEND_ITEM ITEM4 128 STRING &quot;String Item&quot; KEY $.more.item4 APPEND_ARRAY_ITEM ITEM5 8 UINT 0 &quot;Array Item&quot; KEY $.more.item5   ","version":"次へ","tagName":"h3"},{"title":"テンプレートアクセサー​","type":1,"pageTitle":"アクセサー","url":"/ja/docs/configuration/accessors#テンプレートアクセサー","content":" テンプレートアクセサーは、CmdResponseProtocolなどの文字列ベースのコマンド/レスポンスプロトコルでよく使用されます。  完全な例については、COSMOS Enterprise Pluginsのopenc3-cosmos-scpi-power-supplyを参照してください。  コマンド​  コマンド定義でテンプレートアクセサーを使用するには、TEMPLATEを使用して、コマンドパラメータを使用して入力されるオプションパラメータを持つ文字列テンプレートを定義する必要があります。  # 一部のコマンドにはパラメータがなく、テンプレートがそのまま送信されます COMMAND SCPI_PS RESET BIG_ENDIAN &quot;Reset the power supply state&quot; ACCESSOR TemplateAccessor TEMPLATE &quot;*RST&quot; # このコマンドには&lt;XXX&gt;で定義された2つのパラメータがテンプレートにあります COMMAND SCPI_PS VOLTAGE BIG_ENDIAN &quot;Sets the voltage of a power supply channel&quot; ACCESSOR TemplateAccessor # &lt;VOLTAGE&gt;と&lt;CHANNEL&gt;はパラメータ値に置き換えられます TEMPLATE &quot;VOLT &lt;VOLTAGE&gt;, (@&lt;CHANNEL&gt;)&quot; APPEND_PARAMETER VOLTAGE 32 FLOAT MIN MAX 0.0 &quot;Voltage Setting&quot; UNITS VOLTS V APPEND_PARAMETER CHANNEL 8 UINT 1 2 1 &quot;Output Channel&quot;   テレメトリ​  テレメトリ定義でテンプレートアクセサーを使用するには、TEMPLATEを使用して、テレメトリ値が文字列バッファから取得されるテンプレートを定義する必要があります。  TELEMETRY SCPI_PS STATUS BIG_ENDIAN &quot;Power supply status&quot; ACCESSOR TemplateAccessor # ターゲットからの生の文字列は &quot;1.234,2.345&quot;のようなものです # 文字列はカンマで分割され、MEAS_VOLTAGE_1、MEAS_VOLTAGE_2に入れられます TEMPLATE &quot;&lt;MEAS_VOLTAGE_1&gt;,&lt;MEAS_VOLTAGE_2&gt;&quot; APPEND_ITEM MEAS_VOLTAGE_1 32 FLOAT &quot;Current Reading for Channel 1&quot; APPEND_ITEM MEAS_VOLTAGE_2 32 FLOAT &quot;Current Reading for Channel 2&quot;   ","version":"次へ","tagName":"h3"},{"title":"XMLアクセサー​","type":1,"pageTitle":"アクセサー","url":"/ja/docs/configuration/accessors#xmlアクセサー","content":" XMLアクセサーは通常、HTTPクライアントインターフェースでウェブサーバーとXMLを送受信するために使用されます。  完全な例については、openc3-cosmos-accessor-testを参照してください。  コマンド​  コマンド定義でXMLアクセサーを使用するには、TEMPLATEとKEYを使用して、ユーザーがXMLデータ内の値を設定できるようにする必要があります。KEYの値はXPathを使用していることに注意してください。  COMMAND XML XMLCMD BIG_ENDIAN &quot;XML Accessor Command&quot; ACCESSOR XmlAccessor TEMPLATE '&lt;html&gt;&lt;head&gt;&lt;script src=&quot;3&quot;&gt;&lt;/script&gt;&lt;noscript&gt;101&lt;/noscript&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;12&quot;/&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;3.14&lt;/li&gt;&lt;li&gt;Example&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;' APPEND_ID_PARAMETER ID_ITEM 32 INT 3 3 3 &quot;Int Item&quot; KEY &quot;/html/head/script/@src&quot; APPEND_PARAMETER ITEM1 16 UINT MIN MAX 101 &quot;Int Item 2&quot; KEY &quot;/html/head/noscript/text()&quot; UNITS CELSIUS C APPEND_PARAMETER ITEM2 16 UINT MIN MAX 12 &quot;Int Item 3&quot; KEY &quot;/html/body/img/@src&quot; FORMAT_STRING &quot;0x%X&quot; APPEND_PARAMETER ITEM3 64 FLOAT MIN MAX 3.14 &quot;Float Item&quot; KEY &quot;/html/body/div/ul/li[1]/text()&quot; APPEND_PARAMETER ITEM4 128 STRING &quot;Example&quot; &quot;String Item&quot; KEY &quot;/html/body/div/ul/li[2]/text()&quot;   テレメトリ​  テレメトリ定義でXMLアクセサーを使用するには、KEYを使用してXMLデータから値を取得するだけで済みます。KEYの値はXPathを使用していることに注意してください。  TELEMETRY XML XMLTLM BIG_ENDIAN &quot;XML Accessor Telemetry&quot; ACCESSOR XmlAccessor # テンプレートはテレメトリには必須ではありませんが、シミュレーションに役立ちます TEMPLATE '&lt;html&gt;&lt;head&gt;&lt;script src=&quot;3&quot;&gt;&lt;/script&gt;&lt;noscript&gt;101&lt;/noscript&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;12&quot;/&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;3.14&lt;/li&gt;&lt;li&gt;Example&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;' APPEND_ID_ITEM ID_ITEM 32 INT 3 &quot;Int Item&quot; KEY &quot;/html/head/script/@src&quot; APPEND_ITEM ITEM1 16 UINT &quot;Int Item 2&quot; KEY &quot;/html/head/noscript/text()&quot; GENERIC_READ_CONVERSION_START UINT 16 value * 2 GENERIC_READ_CONVERSION_END UNITS CELSIUS C APPEND_ITEM ITEM2 16 UINT &quot;Int Item 3&quot; KEY &quot;/html/body/img/@src&quot; FORMAT_STRING &quot;0x%X&quot; APPEND_ITEM ITEM3 64 FLOAT &quot;Float Item&quot; KEY &quot;/html/body/div/ul/li[1]/text()&quot; APPEND_ITEM ITEM4 128 STRING &quot;String Item&quot; KEY &quot;/html/body/div/ul/li[2]/text()&quot;   ","version":"次へ","tagName":"h3"},{"title":"GEMS Ascii (Enterprise)​","type":1,"pageTitle":"アクセサー","url":"/ja/docs/configuration/accessors#gems-ascii-enterprise","content":" GemsAsciiAccessorはTemplateAccessorを継承して、送信コマンドの以下の文字をエスケープします：「&amp;」=&gt;「&amp;a」、「|」=&gt;「&amp;b」、「,」=&gt;「&amp;c」、「;」=&gt;「&amp;d」、そしてテレメトリではその逆変換を行います。詳細についてはGEMSの仕様を参照してください。  完全な例については、COSMOS Enterprise Pluginsのopenc3-cosmos-gems-interfaceを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"Prometheus (Enterprise)​","type":1,"pageTitle":"アクセサー","url":"/ja/docs/configuration/accessors#prometheus-enterprise","content":" PrometheusAccessorはPrometheusエンドポイントから読み取り、結果を自動的にパケットに解析することができます。PrometheusAccessorは現在Rubyでのみ実装されています。  完全な例については、COSMOS Enterprise Pluginsのopenc3-cosmos-prometheus-metricsを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"Protocol Buffer (Enterprise)​","type":1,"pageTitle":"アクセサー","url":"/ja/docs/configuration/accessors#protocol-buffer-enterprise","content":" ProtoAccessorはプロトコルバッファの読み書きに使用されます。主にGrpcInterfaceと組み合わせて使用されます。ProtoAccessorは現在Rubyでのみ実装されています。  パラメータ\t説明\t必須Filename\tプロトコルバッファコンパイラによって生成されたファイル\tはい Class\tバッファのエンコードとデコードに使用するクラス\tはい  完全な例については、COSMOS Enterprise Pluginsのopenc3-cosmos-proto-targetを参照してください。 ","version":"次へ","tagName":"h3"},{"title":"OpenC3, Inc. Privacy Policy","type":0,"sectionRef":"#","url":"/ja/docs/privacy","content":"","keywords":"","version":"次へ"},{"title":"Our Commitment​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#our-commitment","content":" • Your information will not be shared, rented or sold to any third party. • We use state-of-the-art security measures to protect your information from unauthorized users. • We give you the possibility to control the information that you shared with us (opt-out)  OpenC3, Inc. is committed to processing data in accordance with its responsibilities under the GDPR. Article 5 of the GDPR requires that personal data shall be:  a. processed lawfully, fairly and in a transparent manner in relation to individuals;  b. collected for specified, explicit and legitimate purposes and not further processed in a manner that is incompatible with those purposes; further processing for archiving purposes in the public interest, scientific or historical research purposes or statistical purposes shall not be considered to be incompatible with the initial purposes;  c. adequate, relevant and limited to what is necessary in relation to the purposes for which they are processed;  d. accurate and, where necessary, kept up to date; every reasonable step must be taken to ensure that personal data that are inaccurate, having regard to the purposes for which they are processed, are erased or rectified without delay;  e. kept in a form which permits identification of data subjects for no longer than is necessary for the purposes for which the personal data are processed; personal data may be stored for longer periods insofar as the personal data will be processed solely for archiving purposes in the public interest, scientific or historical research purposes or statistical purposes subject to implementation of the appropriate technical and organisational measures required by the GDPR in order to safeguard the rights and freedoms of individuals; and  f. processed in a manner that ensures appropriate security of the personal data, including protection against unauthorised or unlawful processing and against accidental loss, destruction or damage, using appropriate technical or organisational measures.”  ","version":"次へ","tagName":"h2"},{"title":"1. Notice​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#1-notice","content":" We will clearly inform you when information that personally identifies you (&quot;personal information&quot;) is asked for and you will have the choice to provide it or not. Generally, this information is requested when you subscribe to product updates, newsletters or other online services.  ","version":"次へ","tagName":"h2"},{"title":"2. Usage​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#2-usage","content":" We use your personal information for the following purposes: • To provide you information that will allow you to use our services • To automatically customize your documents with your information • To alert you of software upgrades, updates, discounts or other services from OpenC3, Inc.  We collect your email when you subscribe to our services or newsletter in order to send you informational communications about OpenC3 Inc's products, such as their purpose and the best use you can make of them. We also collect your email to send you our promotional offers.  We may also collect your name, language, currency, operating system, document searched and country information for a better experience with our products/services.  When you place your order with us, we collect your email in order to communicate with you. We also collect your phone number in order to contact you in case these emails bounce back because of a typo in your email address and if we cannot figure out what the correct email address is.  We also contact the phone number that is provided if we suspect that the cardholder’s credit card information has been compromised, i.e used in a fraudulent way.  We also use our clients’ email in order to notify of the release of updated versions of the software, new services or promotional offers.  ","version":"次へ","tagName":"h2"},{"title":"3. Consent​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#3-consent","content":" When you provide your personal information, you consent that it can be used for the above purposes and that OpenC3, Inc. is an authorized holder of such information. If you choose not to register or provide personal information, you can still use our website but you will not be able to receive additional services or access certain areas that require registration. When you activate your account, you are providing your consent to occasionally receive information from us. In each communication from us you will have the opportunity to unsubscribe from further communications; alternatively, you may contact us to express your choices at the address provided at the bottom of this page.  ","version":"次へ","tagName":"h2"},{"title":"4. Access to your information​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#4-access-to-your-information","content":" You are entitled to review the personal information you have provided us and ensure that it is accurate and current at all times. To review or update this information simply request that we send you this information.  ","version":"次へ","tagName":"h2"},{"title":"5. Security of information​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#5-security-of-information","content":" OpenC3, Inc. is strongly committed to protecting your information and ensuring that your choices are honored. We have taken strong security measures to protect your data from loss, misuse, unauthorized access, disclosure, alteration, or destruction. All sensitive data is stored behind multiple firewalls on secure servers with restricted employee access.  We guarantee that all e-commerce transactions follow the latest security measures and use the best available technologies. Secure Sockets Layer (SSL) technology is employed when you place online orders or transmit sensitive information. SSL is one of the safest methods of passing information over the Internet.  ","version":"次へ","tagName":"h2"},{"title":"6. Retention of information​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#6-retention-of-information","content":" We retain information as long as it is necessary to provide the services requested by you and others, subject to any legal obligations to further retain such information. Information associated with your account will generally be kept until it is no longer necessary to provide the services or until you ask us to delete it or your account is deleted whichever comes first. Additionally, we may retain information from deleted accounts to comply with the law, prevent fraud, resolve disputes, troubleshoot problems, assist with investigations, enforce the Terms of Use, and take other actions permitted by law. The information we retain will be handled in accordance with this Privacy Policy. Finally, your data could also be stored for sales statistical purposes.  ","version":"次へ","tagName":"h2"},{"title":"7. EU and EEA Users’ Rights​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#7-eu-and-eea-users-rights","content":" If you are habitually located in the European Union or European Economic Area, you have the right to access, rectify, download or erase your information, as well as the right to restrict and object to certain processing of your information. While some of these rights apply generally, certain rights apply only in certain limited circumstances. We describe these rights below:  You have the right to access your personal data and, if necessary, have it amended or deleted or restricted. In certain instances, you may have the right to the portability of your data. You can also ask us to not send marketing communications and not to use your personal data when we carry out profiling for direct marketing purposes. You can opt out of receiving email newsletters and other marketing communications by following the opt-out instructions provided to you in those emails. Transactional account messages will be unaffected if you opt-out from marketing communications.  ","version":"次へ","tagName":"h2"},{"title":"8. What we do with the Information you share​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#8-what-we-do-with-the-information-you-share","content":" Your information is never shared outside the company without your permission. Inside the company, data is stored behind multiple firewalls on secure servers with restricted user access.  When you register to our website, you are asked to provide your contact information, including a valid email address. We use this information to send you updates about order confirmations and information about our services. When you order from us, we ask for your credit card number and billing address. We use this information only to bill you for the product(s) you ordered at that time.  We may on occasion require the help of other companies to provide limited services on our behalf, such as packaging, shipping and delivery, customer support and processing event registrations. We will only provide such companies with the information required for them to perform these services; these service providers are bound by strict privacy policies and are prohibited from using your information for any other purpose.  In very rare instances OpenC3, Inc. may disclose your personal information, without notice, only if required to do so by law or in the good faith belief that such action is necessary to: (a) conform to the edicts of the law or comply with legal process served on OpenC3, Inc. or the site; (b) protect and defend the rights or property of OpenC3, Inc. and its family of websites and properties; and (c) act in urgent circumstances to protect the personal safety of users of OpenC3, Inc., its websites, or the public.  ","version":"次へ","tagName":"h2"},{"title":"9. How to opt-out​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#9-how-to-opt-out","content":" We provide users with the opportunity to opt-out from receiving updates on our products, newsletters and other communications from us. You can opt-out by clicking on the link provided in our electronic mailings or by contacting us at the address at the bottom of this page.  ","version":"次へ","tagName":"h2"},{"title":"10. Does OpenC3 Inc's privacy policy apply to linked websites?​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#10-does-openc3-incs-privacy-policy-apply-to-linked-websites","content":" Our Privacy Policy applies solely to information collected on our website or through interactions with our company. The Site contains links to web sites of third parties. OpenC3, Inc. is not responsible for the actions of these third parties, including their privacy practices and any content posted on their web sites. We encourage you to review their privacy policies to learn more about what, why and how they collect and use personal information. OpenC3, Inc. adheres to industry recognized standards to secure any personal information in our possession, and to secure it from unauthorized access and tampering.  However, as is true with all online actions, it is possible that third parties may unlawfully intercept transmissions of personal information, or other users of the Site may misuse or abuse your personal information that they may collect from the Site.  ","version":"次へ","tagName":"h2"},{"title":"11. Changes to this policy​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#11-changes-to-this-policy","content":" If we make changes to our Privacy Policy, we will post these changes here so that you are always aware of what information we collect, how we use it and under what circumstances, if any, we disclose it. If at any point we decide to use your information in a manner different from that stated at the time it was collected, we will notify you by email.  ","version":"次へ","tagName":"h2"},{"title":"12. Enforcement of policy​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#12-enforcement-of-policy","content":" If for some reason you believe OpenC3, Inc. has not adhered to these principles, please notify us and we will do our best to promptly make corrections.  ","version":"次へ","tagName":"h2"},{"title":"13. Questions or comments​","type":1,"pageTitle":"OpenC3, Inc. Privacy Policy","url":"/ja/docs/privacy#13-questions-or-comments","content":" If you have questions or comments about this privacy policy, please email us at: support@openc3.com  For additional information about how to contact OpenC3, Inc. please visit our help page.  Dated: August 11th, 2022 ","version":"次へ","tagName":"h2"},{"title":"オートノミック (Enterprise)","type":0,"sectionRef":"#","url":"/ja/docs/tools/autonomic","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"オートノミック (Enterprise)","url":"/ja/docs/tools/autonomic#はじめに","content":" オートノミックは、ユーザー定義のルールに基づいてコマンドとスクリプトを自動実行することができます。  ","version":"次へ","tagName":"h2"},{"title":"概要​","type":1,"pageTitle":"オートノミック (Enterprise)","url":"/ja/docs/tools/autonomic#概要","content":" オートノミックは、トリガーグループ、トリガー、リアクションという基本的な構成要素で動作します。トリガーは単に真偽を評価する論理ブロックです。リアクションは1つまたは複数のトリガーにリンクでき、実行するアクションを指定します。これらを組み合わせることで、システム内で発生するあらゆる事象に基づいてアクションを実行することができます。    ","version":"次へ","tagName":"h3"},{"title":"トリガーグループ​","type":1,"pageTitle":"オートノミック (Enterprise)","url":"/ja/docs/tools/autonomic#トリガーグループ","content":" トリガーはグループに整理されており、これらのグループは組織化とスケーリングに役立つものです。また、トリガーを独立して同時に評価することができ、重複するトリガーや優先度の高いトリガーに役立ちます。ただし、各トリガーグループはシステムリソースを使用するため、必要に応じてのみ作成する必要があります。    ","version":"次へ","tagName":"h3"},{"title":"トリガー​","type":1,"pageTitle":"オートノミック (Enterprise)","url":"/ja/docs/tools/autonomic#トリガー","content":" トリガーは真偽を評価する論理コンポーネントです。トリガーを作成することは、評価する式を指定するようなものです。トリガー作成ダイアログでは、トリガーを所有するトリガーグループと「左オペランド」を指定します。これはテレメトリ項目または既存のトリガーにすることができます。    「左オペランド (Left Operand)」を選択したら、演算子を選択する必要があります。    最後に、この場合は単純な値である「右オペランド (Right Operand)」を選択します。    トリガーが作成されると、オートノミックに表示され、指定されたロジックによってアクティブ化されるのを待ちます。アクティブなトリガーはリスト内でハイライト表示されます。    トリガーはプラグアイコンをクリックすることで手動で無効化および有効化することもできます。    上記のスクリーンショットでトリガーに関するすべてを追跡するイベントに注目してください。  ","version":"次へ","tagName":"h3"},{"title":"リアクション​","type":1,"pageTitle":"オートノミック (Enterprise)","url":"/ja/docs/tools/autonomic#リアクション","content":" リアクションはトリガーが真と評価されるのを待ち、コマンドの送信やスクリプトの実行などのアクションを実行します。リアクションは対応するトリガーなしでは存在できません。リアクション作成ダイアログでは、トリガーをエッジとして扱うかレベルとして扱うかを指定します。次に、リアクションが反応するトリガーを選択することができます。複数のトリガーを選択すると、いずれかのトリガーがリアクションをトリガーできます（注：トリガーAおよびトリガーBに応答するリアクションの作成は、追加のトリガーを作成することで行います）。  エッジトリガーはトリガーがアクティブに変化する時に発動します。もしすでにトリガーがアクティブな場合発動しません。レベルトリガーはトリガーがアクティブな時に発動します。    トリガーが指定された後、実行するアクションの入力を求めるダイアログが表示されます。コマンドの送信、スクリプトの実行、または単に通知をプッシュすることができます。コマンドとスクリプトはオプションで通知をプッシュすることもできます。この例では、WARN レベルの通知付きスクリプトが指定されています。  スクリプトの起動 スクリプトをいつどのように起動するか、そして完了まで実行されているかどうかに注意してください。不良スクリプトを起動すると、多くの未完了スクリプトがリソースを消費する可能性があります。    最後にスヌーズ設定が指定されます。スヌーズは、リアクションが実行された後、リアクションが再度実行できるようになるまでの秒数です。これは特にレベルトリガーで重要で、トリガーがアクティブなままの場合、リアクションが継続的に実行される可能性があります。    リアクションが作成されると、インターフェースにリストされます。    リアクションが実行されると、「状態（State)」がスヌーズアイコンに変わり、「スヌーズ終了時間 (Snooze Until)」が更新され、リアクションが再度実行できるようになるまで待機していることを示します。   ","version":"次へ","tagName":"h3"},{"title":"テレメトリ","type":0,"sectionRef":"#","url":"/ja/docs/configuration/telemetry","content":"","keywords":"","version":"次へ"},{"title":"テレメトリ定義ファイル​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#テレメトリ定義ファイル","content":" テレメトリ定義ファイルは、COSMOSターゲットから受信および処理できるテレメトリパケットを定義します。テレメトリパケットを定義するために1つの大きなファイルを使用することも、ユーザーの判断で複数のファイルを使用することもできます。テレメトリ定義ファイルはターゲットのcmd_tlmディレクトリに配置され、アルファベット順に処理されます。したがって、既存のテレメトリをオーバーライドまたは拡張するなど、他のテレメトリファイルに依存するテレメトリファイルがある場合は、最後に名前を付ける必要があります。最も簡単な方法は、既存のファイル名に拡張子を追加することです。例えば、すでにtlm.txtがある場合、tlm.txtの定義に依存するテレメトリにはtlm_override.txtを作成できます。ASCII表の構造上、大文字で始まるファイルは小文字で始まるファイルよりも先に処理されることに注意してください。  テレメトリ項目を定義する際、以下のデータ型から選択できます：INT、UINT、FLOAT、STRING、BLOCK。これらはそれぞれ整数、符号なし整数、浮動小数点数、文字列、データのバイナリブロックに対応します。COSMOSでは、STRINGとBLOCKの唯一の違いは、COSMOSがSTRINGタイプを読み取るとき、ヌルバイト（0）に遭遇すると読み取りを停止することです。これはPacket ViewerやTlm Viewerで値を表示する際や、Data Extractorの出力に表示されます。非ASCII文字データはBLOCK項目内に、ASCII文字列はSTRING項目内に保存するよう努めてください。  データの表示 ほとんどのデータ型は、COSMOSスクリプトで print(tlm(&quot;TGT PKT ITEM&quot;)) とするだけで表示できます。ただし、ITEMがBLOCKデータ型でバイナリ（非ASCII）データを含む場合は、これは機能しません。COSMOSにはバイナリデータを表示するための formatted という組み込みメソッドがあります。ITEMがバイナリを含むBLOCKタイプの場合は、puts tlm(&quot;TGT PKT ITEM&quot;).formatted（Ruby）やprint(formatted(tlm(&quot;TGT PKT ITEM&quot;)))（Python）を試してください。これによりバイトが16進数として表示されます。  ","version":"次へ","tagName":"h2"},{"title":"ID項目​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#id項目","content":" すべてのパケットには識別項目が必要で、受信データをパケット構造に一致させることができます。これらの項目はID_ITEMとAPPEND_ID_ITEMを使用して定義します。データがインターフェースから読み取られ、プロトコルによって精製されると、すべてのIDフィールドを一致させることで結果のパケットが識別されます。理想的には、特定のターゲット内のすべてのパケットは、識別に全く同じビットオフセット、ビットサイズ、データ型を使用する必要があります。そうでない場合は、target.txtファイルにTLM_UNIQUE_ID_MODEを設定する必要がありますが、これはすべてのパケット識別でパフォーマンスペナルティが発生します。  ","version":"次へ","tagName":"h3"},{"title":"可変サイズ項目​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#可変サイズ項目","content":" COSMOSはビットサイズが0の可変サイズ項目を指定します。パケットが識別されると、明示的に定義されていない他のすべてのデータは可変サイズ項目に格納されます。これらの項目は通常、ダンプされるバイト数に応じてサイズが変化するメモリダンプを含むパケットに使用されます。パケットごとに可変サイズの項目は1つしか存在できないことに注意してください。  ","version":"次へ","tagName":"h3"},{"title":"派生項目​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#derived-items","content":" COSMOSには、実際にはバイナリデータに存在しないテレメトリ項目である派生項目の概念があります。派生項目は通常、他のテレメトリ項目に基づいて計算されます。COSMOS派生項目は実際の項目と非常に似ていますが、特別なDERIVEDデータ型を使用します。テレメトリ定義での派生項目の例を以下に示します。  ITEM TEMP_AVERAGE 0 0 DERIVED &quot;Average of TEMP1, TEMP2, TEMP3, TEMP4&quot;   ビットオフセットとビットサイズが0で、データ型がDERIVEDであることに注意してください。このため、派生項目はAPPEND_ITEMではなくITEMを使用して宣言する必要があります。派生項目はパケット定義のどこにでも定義できますが、通常は末尾に配置されます。ITEM定義の後には、値を生成するためのREAD_CONVERSIONなどの変換キーワードが続く必要があります。  ","version":"次へ","tagName":"h3"},{"title":"受信時間とパケット時間​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#受信時間とパケット時間","content":" COSMOSは自動的にすべてのパケットに以下のテレメトリ項目を作成します：PACKET_TIMESECONDS、PACKET_TIMEFORMATTED、RECEIVED_COUNT、RECEIVED_TIMEFORMATTED、RECEIVED_TIMESECONDS。  RECEIVED_TIMEはCOSMOSがパケットを受信した時間です。これはターゲットに接続し、生データを受信しているインターフェースによって設定されます。生データからパケットが作成されると、時間が設定されます。  PACKET_TIMEはデフォルトでRECEIVED_TIMEですが、テレメトリ設定ファイルで時間オブジェクトを持つ派生項目として設定できます。これは保存されたテレメトリパケットをサポートし、Telemetry GrapherやData Extractorなどの他のCOSMOSツールでより合理的に処理できるようにします。インターフェースに「stored」フラグを設定すると、現在の値テーブルに影響はありません。  _TIMEFORMATTED項目は日付と時刻をYYYY/MM/DD HH:MM:SS.sss形式で返し、_TIMESECONDSは時間のUnix秒を返します。内部的には、これらはどちらもRuby TimeオブジェクトまたはPython dateオブジェクトとして格納されています。  例​  COSMOSは、Unix epochからの秒数と（オプションで）マイクロ秒に基づいてRuby TimeオブジェクトまたはPython dateオブジェクトを返すUnix時間変換クラスを提供します。注意：これはfloatや文字列ではなく、ネイティブオブジェクトを返します！  Rubyの例：  ITEM PACKET_TIME 0 0 DERIVED &quot;Ruby time based on TIMESEC and TIMEUS&quot; READ_CONVERSION unix_time_conversion.rb TIMESEC TIMEUS   Pythonの例：  ITEM PACKET_TIME 0 0 DERIVED &quot;Python time based on TIMESEC and TIMEUS&quot; READ_CONVERSION openc3/conversions/unix_time_conversion.py TIMESEC TIMEUS   PACKET_TIMEを定義することで、COSMOSがパケットを受信した時間ではなく、内部パケット時間に対してPACKET_TIMESECONDSとPACKET_TIMEFORMATTEDを計算できるようになります。    テレメトリキーワード  ","version":"次へ","tagName":"h3"},{"title":"TELEMETRY​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#telemetry","content":" 新しいテレメトリパケットを定義します  パラメータ\t説明\t必須Target\tこのテレメトリパケットに関連付けられたターゲットの名前\tはい Command\tこのテレメトリパケットの名前。ニーモニックとも呼ばれます。このターゲット内のテレメトリパケットに対して一意である必要があります。理想的には短く明確であるべきです。\tはい Endianness\tこのパケット内のデータがビッグエンディアンかリトルエンディアン形式かを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tはい Description\tこのテレメトリパケットの説明（引用符で囲む必要があります）\tいいえ  使用例：  TELEMETRY INST HEALTH_STATUS BIG_ENDIAN &quot;Instrument health and status&quot;   ","version":"次へ","tagName":"h2"},{"title":"TELEMETRY Modifiers​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#telemetry-modifiers","content":" 以下のキーワードはTELEMETRYキーワードの後に続く必要があります。  ","version":"次へ","tagName":"h2"},{"title":"ITEM​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#item","content":" 現在のテレメトリパケット内のテレメトリ項目を定義します  パラメータ\t説明\t必須Name\tテレメトリ項目の名前。パケット内で一意である必要があります。\tはい Bit Offset\tこの項目の最上位ビットのテレメトリパケットへのビットオフセット。パケットの末尾からのオフセットを示すために負の値を使用できます。派生項目には常にビットオフセット0を使用します。\tはい Bit Size\tこのテレメトリ項目のビットサイズ。ゼロまたは負の値を使用して、文字列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。ビットオフセットが0でビットサイズが0の場合、これは派生パラメータであり、データ型は「DERIVED」に設定する必要があります。\tはい Data Type\tこのテレメトリ項目のデータ型 有効な値: INT, UINT, FLOAT, STRING, BLOCK, DERIVED\tはい Description\tこのテレメトリ項目の説明（引用符で囲む必要があります）\tいいえ Endianness\t項目をビッグエンディアンまたはリトルエンディアン形式で解釈するかどうかを示します。リトルエンディアンビットフィールドのガイドを参照してください。 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tいいえ  使用例：  ITEM PKTID 112 16 UINT &quot;Packet ID&quot; ITEM DATA 0 0 DERIVED &quot;Derived data&quot;   ","version":"次へ","tagName":"h3"},{"title":"ITEM Modifiers​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#item-modifiers","content":" 以下のキーワードはITEMキーワードの後に続く必要があります。  FORMAT_STRING​  printf形式のフォーマットを追加します  パラメータ\t説明\t必須Format\tprintf構文を使用してフォーマットする方法。例えば、「0x%0X」は値を16進数で表示します。\tはい  使用例：  FORMAT_STRING &quot;0x%0X&quot;   UNITS​  表示単位を追加します  パラメータ\t説明\t必須Full Name\t単位タイプのフルネーム（例：摂氏）\tはい Abbreviated\t単位の略語（例：C）\tはい  使用例：  UNITS Celsius C UNITS Kilometers KM   DESCRIPTION​  定義された説明を上書きします  パラメータ\t説明\t必須Value\t新しい説明\tはい  META​  カスタムユーザーメタデータを格納します  メタデータは、カスタムツールがさまざまな目的で使用できるユーザー固有のデータです。一例として、ソースコードヘッダーファイルを生成するために必要な追加情報を保存することができます。  パラメータ\t説明\t必須Meta Name\t保存するメタデータの名前\tはい Meta Values\tこのMeta Nameに保存される1つ以上の値\tいいえ  使用例：  META TEST &quot;This parameter is for test purposes only&quot;   OVERLAP​   (Since 4.4.1) この項目はパケット内の他の項目と重複することが許可されています   項目のビットオフセットが別の項目と重複する場合、OpenC3は警告を発します。このキーワードは明示的に項目が別の項目と重複することを許可し、警告メッセージを抑制します。  KEY​   (Since 5.0.10) パケット内の生の値にアクセスするために使用されるキーを定義します。   キーは多くの場合、JSONPathやXPath文字列です  パラメータ\t説明\t必須Key string\tこの項目にアクセスするためのキー\tはい  使用例：  KEY $.book.title   VARIABLE_BIT_SIZE​   (Since 5.18.0) 項目のビットサイズが別の長さ項目によって定義されていることを示します   パラメータ\t説明\t必須Length Item Name\t関連する長さ項目の名前\tはい Length Bits Per Count\t長さ項目のカウントあたりのビット数。デフォルトは8\tいいえ Length Value Bit Offset\t長さフィールド値に適用するビットオフセット。デフォルトは0\tいいえ  STATE​  現在の項目のキー/値ペアを定義します  キー/値ペアにより、ユーザーフレンドリーな文字列が可能になります。例えば、ON = 1およびOFF = 0の状態を定義することができます。これにより、テレメトリ項目を送信する際に数字の1ではなく単語「ON」を使用でき、明確さが大幅に向上し、ユーザーエラーの可能性が低減します。ANYのキャッチオール値は、すでに状態値として定義されていない他のすべての値に適用されます。  パラメータ\t説明\t必須Key\t文字列状態名\tはい Value\t数値状態値、またはANYですべての他の値に状態を適用\tはい Color\t状態が表示される色 有効な値: GREEN, YELLOW, RED\tいいえ  使用例：  APPEND_ITEM ENABLE 32 UINT &quot;Enable setting&quot; STATE FALSE 0 STATE TRUE 1 STATE ERROR ANY # 他のすべての値をERRORに一致させる APPEND_ITEM STRING 1024 STRING &quot;String&quot; STATE &quot;NOOP&quot; &quot;NOOP&quot; GREEN STATE &quot;ARM LASER&quot; &quot;ARM LASER&quot; YELLOW STATE &quot;FIRE LASER&quot; &quot;FIRE LASER&quot; RED   READ_CONVERSION​  現在のテレメトリ項目に変換を適用します  変換はターゲットのlibフォルダに配置されたカスタムRubyまたはPythonファイルで実装されます。クラスはConversionを継承する必要があります。追加パラメータを取る場合は initialize（Ruby）または __init__（Python）メソッドを実装する必要があり、常に call メソッドを実装する必要があります。変換係数は、テレメトリパケット内の生の値にユーザーに表示される前に適用されます。ユーザーは詳細ダイアログで生の未変換値を見ることができます。  パラメータ\t説明\t必須Class Filename\tRubyまたはPythonクラスを含むファイル名。ファイル名はクラスに合わせて名付ける必要があり、クラスはアンダースコア付きファイル名のCamelCase版である必要があります。例えば、「the_great_conversion.rb」には「class TheGreatConversion」が含まれている必要があります。\tはい Parameter\t変換のための追加パラメータ値。クラスコンストラクタに渡されます。\tいいえ  Rubyの例：  READ_CONVERSION the_great_conversion.rb 1000 Defined in the_great_conversion.rb: require 'openc3/conversions/conversion' module OpenC3 class TheGreatConversion &lt; Conversion def initialize(multiplier) super() @multiplier = multiplier.to_f end def call(value, packet, buffer) return value * @multiplier end end end   Pythonの例：  READ_CONVERSION the_great_conversion.py 1000 Defined in the_great_conversion.py: from openc3.conversions.conversion import Conversion class TheGreatConversion(Conversion): def __init__(self, multiplier): super().__init__() self.multiplier = float(multiplier) def call(self, value, packet, buffer): return value * self.multiplier   POLY_READ_CONVERSION​  現在のテレメトリ項目に多項式変換係数を追加します  変換係数は、テレメトリパケット内の生の値にユーザーに表示される前に適用されます。ユーザーは詳細ダイアログで生の未変換値を見ることができます。  パラメータ\t説明\t必須C0\t係数\tはい Cx\t変換のための追加係数値。任意の次数の多項式変換が使用できるため、「x」の値は多項式の次数によって異なります。高次の多項式は低次の多項式よりも処理に時間がかかりますが、より正確な場合があります。\tいいえ  使用例：  POLY_READ_CONVERSION 10 0.5 0.25   SEG_POLY_READ_CONVERSION​  現在のテレメトリ項目にセグメント化された多項式変換係数を追加します  この変換係数は、テレメトリパケット内の生の値にユーザーに表示される前に適用されます。ユーザーは詳細ダイアログで生の未変換値を見ることができます。  パラメータ\t説明\t必須Lower Bound\tこのセグメント化された多項式が適用される値の範囲の下限を定義します。最小の下限を持つセグメントでは無視されます。\tはい C0\t係数\tはい Cx\t変換のための追加係数値。任意の次数の多項式変換が使用できるため、「x」の値は多項式の次数によって異なります。高次の多項式は低次の多項式よりも処理に時間がかかりますが、より正確な場合があります。\tいいえ  使用例：  SEG_POLY_READ_CONVERSION 0 10 0.5 0.25 # すべての値 &lt; 50 に変換を適用 SEG_POLY_READ_CONVERSION 50 11 0.5 0.275 # すべての値 &gt;= 50 かつ &lt; 100 に変換を適用 SEG_POLY_READ_CONVERSION 100 12 0.5 0.3 # すべての値 &gt;= 100 に変換を適用   GENERIC_READ_CONVERSION_START​  一般的な読み取り変換を開始します  現在のテレメトリ項目に一般的な変換関数を追加します。この変換係数は、テレメトリパケット内の生の値にユーザーに表示される前に適用されます。ユーザーは詳細ダイアログで生の未変換値を見ることができます。変換はRubyまたはPythonコードとして指定され、2つの暗黙的なパラメータを受け取ります。「value」は読み取られる生の値、「packet」はテレメトリパケットクラスへの参照です（注：後方互換性のためにパケットを「myself」として参照することもサポートされています）。コードの最後の行は変換された値を返す必要があります。GENERIC_READ_CONVERSION_ENDキーワードは、変換のためのすべてのコード行が与えられたことを指定します。  警告 一般的な変換は長期的なソリューションとしては良くありません。変換クラスを作成して代わりにREAD_CONVERSIONを使用することを検討してください。READ_CONVERSIONはデバッグが容易で、パフォーマンスが高いです。  パラメータ\t説明\t必須Converted Type\t変換された値の型 有効な値: INT, UINT, FLOAT, STRING, BLOCK\tいいえ Converted Bit Size\t変換された値のビットサイズ\tいいえ  Rubyの例：  APPEND_ITEM ITEM1 32 UINT GENERIC_READ_CONVERSION_START return (value * 1.5).to_i # スケールファクターで値を変換 GENERIC_READ_CONVERSION_END   Pythonの例：  APPEND_ITEM ITEM1 32 UINT GENERIC_READ_CONVERSION_START return int(value * 1.5) # スケールファクターで値を変換 GENERIC_READ_CONVERSION_END   GENERIC_READ_CONVERSION_END​  一般的な読み取り変換を完了します  LIMITS​  テレメトリ項目の制限セットを定義します  制限に違反した場合、項目が制限を超えたことを示すメッセージがCommand and Telemetry Serverに表示されます。他のツールもこの情報を使用して、異なる色のテレメトリ項目や他の有用な情報でディスプレイを更新します。「制限セット」の概念は、異なる環境で異なる制限値を持つことができるように定義されています。例えば、熱真空試験中など、環境が変化した場合に、テレメトリに対するより厳しいまたはより緩い制限を設定したい場合があります。  パラメータ\t説明\t必須Limits Set\t制限セットの名前。固有の制限セットがない場合は、キーワードDEFAULTを使用します。\tはい Persistence\tテレメトリ項目が制限状態を変更する前に、異なる制限範囲内である必要がある連続回数。\tはい Initial State\tこのテレメトリ項目の制限監視が最初に有効か無効かを示します。複数のLIMITS項目がある場合、すべて同じ初期状態であるべきことに注意してください。 有効な値: ENABLED, DISABLED\tはい Red Low Limit\tテレメトリ値がこの値以下の場合、Red Low状態が検出されます\tはい Yellow Low Limit\tテレメトリ値がこの値以下で、Red Low Limitより大きい場合、Yellow Low状態が検出されます\tはい Yellow High Limit\tテレメトリ値がこの値以上で、Red High Limitより小さい場合、Yellow High状態が検出されます\tはい Red High Limit\tテレメトリ値がこの値以上の場合、Red High状態が検出されます\tはい Green Low Limit\tGreen LowとGreen High制限を設定すると、OpenC3で青色表示される「運用制限」が定義されます。これにより、緑の安全制限よりも狭い、望ましい運用範囲を区別できます。テレメトリ値がこの値以上で、Green High Limitより小さい場合、青い運用状態が検出されます。\tいいえ Green High Limit\tGreen LowとGreen High制限を設定すると、OpenC3で青色表示される「運用制限」が定義されます。これにより、緑の安全制限よりも狭い、望ましい運用範囲を区別できます。テレメトリ値がこの値以下で、Green Low Limitより大きい場合、青い運用状態が検出されます。\tいいえ  使用例：  LIMITS DEFAULT 3 ENABLED -80.0 -70.0 60.0 80.0 -20.0 20.0 LIMITS TVAC 3 ENABLED -80.0 -30.0 30.0 80.0   LIMITS_RESPONSE​  現在の項目の制限状態が変化したときに呼び出される応答クラスを定義します  パラメータ\t説明\t必須Response Class Filename\t制限応答を実装するRubyまたはPythonファイルの名前。このファイルはターゲットのlibディレクトリにある必要があります。\tはい Response Specific Options\tクラスコンストラクタに渡される変数長のオプション\tいいえ  Rubyの例：  LIMITS_RESPONSE example_limits_response.rb 10   Pythonの例：  LIMITS_RESPONSE example_limits_response.py 10   ","version":"次へ","tagName":"h3"},{"title":"APPEND_ITEM​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#append_item","content":" 現在のテレメトリパケット内のテレメトリ項目を定義します  パラメータ\t説明\t必須Name\tテレメトリ項目の名前。パケット内で一意である必要があります。\tはい Bit Size\tこのテレメトリ項目のビットサイズ。ゼロまたは負の値を使用して、文字列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。ビットオフセットが0でビットサイズが0の場合、これは派生パラメータであり、データ型は「DERIVED」に設定する必要があります。\tはい Data Type\tこのテレメトリ項目のデータ型 有効な値: INT, UINT, FLOAT, STRING, BLOCK, DERIVED\tはい Description\tこのテレメトリ項目の説明（引用符で囲む必要があります）\tいいえ Endianness\t項目をビッグエンディアンまたはリトルエンディアン形式で解釈するかどうかを示します。リトルエンディアンビットフィールドのガイドを参照してください。 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tいいえ  使用例：  APPEND_ITEM PKTID 16 UINT &quot;Packet ID&quot;   ","version":"次へ","tagName":"h3"},{"title":"ID_ITEM​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#id_item","content":" 現在のテレメトリパケット内のテレメトリ項目を定義します。注意：1つ以上のID_ITEMなしで定義されたパケットは、すべての受信データに一致する「キャッチオール」パケットです。通常、これはUNKNOWNパケットの役割です。  パラメータ\t説明\t必須Name\tテレメトリ項目の名前。パケット内で一意である必要があります。\tはい Bit Offset\tこの項目の最上位ビットのテレメトリパケットへのビットオフセット。パケットの末尾からのオフセットを示すために負の値を使用できます。\tはい Bit Size\tこのテレメトリ項目のビットサイズ。ゼロまたは負の値を使用して、文字列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。\tはい Data Type\tこのテレメトリ項目のデータ型 有効な値: INT, UINT, FLOAT, STRING, BLOCK\tはい ID Value\tこのテレメトリパケットを一意に識別するこのテレメトリ項目の値\tはい Description\tこのテレメトリ項目の説明（引用符で囲む必要があります）\tいいえ Endianness\t項目をビッグエンディアンまたはリトルエンディアン形式で解釈するかどうかを示します。リトルエンディアンビットフィールドのガイドを参照してください。 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tいいえ  使用例：  ID_ITEM PKTID 112 16 UINT 1 &quot;Packet ID which must be 1&quot;   ","version":"次へ","tagName":"h3"},{"title":"APPEND_ID_ITEM​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#append_id_item","content":" 現在のテレメトリパケット内のテレメトリ項目を定義します  パラメータ\t説明\t必須Name\tテレメトリ項目の名前。パケット内で一意である必要があります。\tはい Bit Size\tこのテレメトリ項目のビットサイズ。ゼロまたは負の値を使用して、文字列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。\tはい Data Type\tこのテレメトリ項目のデータ型 有効な値: INT, UINT, FLOAT, STRING, BLOCK\tはい ID Value\tこのテレメトリパケットを一意に識別するこのテレメトリ項目の値\tはい Description\tこのテレメトリ項目の説明（引用符で囲む必要があります）\tいいえ Endianness\t項目をビッグエンディアンまたはリトルエンディアン形式で解釈するかどうかを示します。リトルエンディアンビットフィールドのガイドを参照してください。 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tいいえ  使用例：  APPEND_ID_ITEM PKTID 16 UINT 1 &quot;Packet ID which must be 1&quot;   ","version":"次へ","tagName":"h3"},{"title":"ARRAY_ITEM​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#array_item","content":" 配列である現在のテレメトリパケット内のテレメトリ項目を定義します  パラメータ\t説明\t必須Name\tテレメトリ項目の名前。パケット内で一意である必要があります。\tはい Bit Offset\tこの項目の最上位ビットのテレメトリパケットへのビットオフセット。パケットの末尾からのオフセットを示すために負の値を使用できます。派生項目には常にビットオフセット0を使用します。\tはい Item Bit Size\t各配列項目のビットサイズ\tはい Item Data Type\t各配列項目のデータ型 有効な値: INT, UINT, FLOAT, STRING, BLOCK, DERIVED\tはい Array Bit Size\t配列の合計ビットサイズ。ゼロまたは負の値を使用して、配列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。\tはい Description\t説明（引用符で囲む必要があります）\tいいえ Endianness\tデータをビッグエンディアンまたはリトルエンディアン形式で送信するかどうかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tいいえ  使用例：  ARRAY_ITEM ARRAY 64 32 FLOAT 320 &quot;Array of 10 floats&quot;   ","version":"次へ","tagName":"h3"},{"title":"APPEND_ARRAY_ITEM​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#append_array_item","content":" 配列である現在のテレメトリパケット内のテレメトリ項目を定義します  パラメータ\t説明\t必須Name\tテレメトリ項目の名前。パケット内で一意である必要があります。\tはい Item Bit Size\t各配列項目のビットサイズ\tはい Item Data Type\t各配列項目のデータ型 有効な値: INT, UINT, FLOAT, STRING, BLOCK, DERIVED\tはい Array Bit Size\t配列の合計ビットサイズ。ゼロまたは負の値を使用して、配列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。\tはい Description\t説明（引用符で囲む必要があります）\tいいえ Endianness\tデータをビッグエンディアンまたはリトルエンディアン形式で送信するかどうかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tいいえ  使用例：  APPEND_ARRAY_ITEM ARRAY 32 FLOAT 320 &quot;Array of 10 floats&quot;   ","version":"次へ","tagName":"h3"},{"title":"SELECT_ITEM​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#select_item","content":" 編集のために既存のテレメトリ項目を選択します  パケットを最初に選択するためにSELECT_TELEMETRYと併用する必要があります。通常、生成された値をオーバーライドしたり、複数回使用されるターゲットの特定のインスタンスにのみ影響するテレメトリに特定の変更を加えたりするために使用されます。  パラメータ\t説明\t必須Item\t変更するために選択する項目の名前\tはい  使用例：  SELECT_TELEMETRY INST HEALTH_STATUS SELECT_ITEM TEMP1 # この項目の制限を定義し、既存のものをオーバーライドまたは置換します LIMITS DEFAULT 3 ENABLED -90.0 -80.0 80.0 90.0 -20.0 20.0   ","version":"次へ","tagName":"h3"},{"title":"DELETE_ITEM​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#delete_item","content":"  (Since 4.4.1) パケット定義から既存のテレメトリ項目を削除します   パケット定義から項目を削除しても、その項目のための定義されたスペースは削除されません。したがって、新しい項目を再定義しない限り、データにアクセスできない「穴」がパケットに残ります。SELECT_TELEMETRYを使用し、その後ITEMを使用して新しい項目を定義できます。  パラメータ\t説明\t必須Item\t削除する項目の名前\tはい  使用例：  SELECT_TELEMETRY INST HEALTH_STATUS DELETE_ITEM TEMP4   ","version":"次へ","tagName":"h3"},{"title":"META​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#meta-1","content":" 現在のテレメトリパケットのメタデータを格納します  メタデータは、カスタムツールがさまざまな目的で使用できるユーザー固有のデータです。一例として、ソースコードヘッダーファイルを生成するために必要な追加情報を保存することができます。  パラメータ\t説明\t必須Meta Name\t保存するメタデータの名前\tはい Meta Values\tこのMeta Nameに保存される1つ以上の値\tいいえ  使用例：  META FSW_TYPE &quot;struct tlm_packet&quot;   ","version":"次へ","tagName":"h3"},{"title":"PROCESSOR​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#processor","content":" パケットが受信されるたびにコードを実行するプロセッサクラスを定義します  パラメータ\t説明\t必須Processor Name\tプロセッサの名前\tはい Processor Class Filename\tプロセッサを実装するRubyまたはPythonファイルの名前。このファイルはターゲットのlibディレクトリにある必要があります。\tはい Processor Specific Options\tクラスコンストラクタに渡される変数長のオプション。\tいいえ  Rubyの例：  PROCESSOR TEMP1HIGH watermark_processor.rb TEMP1   Pythonの例：  PROCESSOR TEMP1HIGH watermark_processor.py TEMP1   ","version":"次へ","tagName":"h3"},{"title":"ALLOW_SHORT​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#allow_short","content":" 定義された長さより短いテレメトリパケットを処理します  テレメトリパケットが定義されたサイズよりも小さいデータ部分を持っていても警告なしに受信できるようにします。パケット内の余分なスペースはOpenC3によってゼロで埋められます。  ","version":"次へ","tagName":"h3"},{"title":"HIDDEN​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#hidden","content":" このテレメトリパケットをすべてのOpenC3ツールから非表示にします  このパケットはPacket Viewer、Telemetry Grapher、Handbook Creatorに表示されません。また、スクリプトを書く際にScript Runnerのポップアップヘルパーにもこのテレメトリが表示されなくなります。テレメトリはシステム内に存在し、スクリプトによって受信およびチェックできます。  ","version":"次へ","tagName":"h3"},{"title":"ACCESSOR​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#accessor","content":"  (Since 5.0.10) パケットから生の値を読み書きするために使用されるクラスを定義します   パケットから生の値を読み取るために使用されるクラスを定義します。デフォルトはBinaryAccessorです。詳細についてはアクセサを参照してください。  パラメータ\t説明\t必須Accessor Class Name\tアクセサクラスの名前\tはい  ","version":"次へ","tagName":"h3"},{"title":"TEMPLATE​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#template","content":"  (Since 5.0.10) 文字列バッファからテレメトリ値を取得するために使用されるテンプレート文字列を定義します   パラメータ\t説明\t必須Template\t引用符で囲まれるべきテンプレート文字列\tはい  ","version":"次へ","tagName":"h3"},{"title":"TEMPLATE_FILE​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#template_file","content":"  (Since 5.0.10) 文字列バッファからテレメトリ値を取得するために使用されるテンプレートファイルを定義します   パラメータ\t説明\t必須Template File Path\tテンプレートファイルへの相対パス。ファイル名は一般的にアンダースコアで始まるべきです。\tはい  ","version":"次へ","tagName":"h3"},{"title":"IGNORE_OVERLAP​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#ignore_overlap","content":"  (Since 5.16.0) 重複するパケット項目を無視します   重複するパケット項目は通常、各項目がOVERLAPキーワードを持っていない限り警告を生成します。これはパケット全体で重複を無視します。  ","version":"次へ","tagName":"h3"},{"title":"VIRTUAL​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#virtual","content":"  (Since 5.18.0) このパケットを仮想としてマークし、識別に参加しないようにします   与えられたパケットの項目の構造として使用できるパケット定義に使用されます。  ","version":"次へ","tagName":"h3"},{"title":"SELECT_TELEMETRY​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#select_telemetry","content":" 編集のために既存のテレメトリパケットを選択します  通常、元のテレメトリが定義されている場所とは別の設定ファイルで使用され、既存のテレメトリ定義をオーバーライドまたは追加します。個々の項目を変更するにはSELECT_ITEMと併用する必要があります。  パラメータ\t説明\t必須Target Name\tこのテレメトリパケットに関連付けられたターゲットの名前\tはい Packet Name\t選択するテレメトリパケットの名前\tはい  使用例：  SELECT_TELEMETRY INST HEALTH_STATUS SELECT_ITEM TEMP1 # この項目の制限を定義し、既存のものをオーバーライドまたは置換します LIMITS DEFAULT 3 ENABLED -90.0 -80.0 80.0 90.0 -20.0 20.0   ","version":"次へ","tagName":"h2"},{"title":"LIMITS_GROUP​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#limits_group","content":" 関連する制限項目のグループを定義します  制限グループには、一緒に有効または無効にできるテレメトリ項目が含まれています。例えば特定のサブシステムが電源投入されたときに有効または無効にできるサブシステムとして関連する制限をグループ化するために使用できます。グループを有効にするには、Script Runnerでenable_limits_group(&quot;NAME&quot;)メソッドを呼び出します。グループを無効にするには、Script Runnerでdisable_limits_group(&quot;NAME&quot;)を呼び出します。項目は複数のグループに属することができますが、最後に有効または無効にされたグループが「勝ち」ます。例えば、項目がGROUP1とGROUP2に属していて、最初にGROUP1を有効にし、次にGROUP2を無効にすると、項目は無効になります。その後、再びGROUP1を有効にすると、項目は有効になります。  パラメータ\t説明\t必須Group Name\t制限グループの名前\tはい  ","version":"次へ","tagName":"h2"},{"title":"LIMITS_GROUP_ITEM​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#limits_group_item","content":" 指定されたテレメトリ項目を最後に定義されたLIMITS_GROUPに追加します  制限グループ情報は通常、config/TARGET/cmd_tlmフォルダ内の別の設定ファイル（limits_groups.txt）に保管されます。  パラメータ\t説明\t必須Target Name\tターゲットの名前\tはい Packet Name\tパケットの名前\tはい Item Name\tグループに追加するテレメトリ項目の名前\tはい  使用例：  LIMITS_GROUP SUBSYSTEM LIMITS_GROUP_ITEM INST HEALTH_STATUS TEMP1 LIMITS_GROUP_ITEM INST HEALTH_STATUS TEMP2 LIMITS_GROUP_ITEM INST HEALTH_STATUS TEMP3   ","version":"次へ","tagName":"h2"},{"title":"例ファイル​","type":1,"pageTitle":"テレメトリ","url":"/ja/docs/configuration/telemetry#例ファイル","content":" 例ファイル: TARGET/cmd_tlm/tlm.txt  TELEMETRY TARGET HS BIG_ENDIAN &quot;Health and Status for My Target&quot; ITEM CCSDSVER 0 3 UINT &quot;CCSDS PACKET VERSION NUMBER (SEE CCSDS 133.0-B-1)&quot; ITEM CCSDSTYPE 3 1 UINT &quot;CCSDS PACKET TYPE (COMMAND OR TELEMETRY)&quot; STATE TLM 0 STATE CMD 1 ITEM CCSDSSHF 4 1 UINT &quot;CCSDS SECONDARY HEADER FLAG&quot; STATE FALSE 0 STATE TRUE 1 ID_ITEM CCSDSAPID 5 11 UINT 102 &quot;CCSDS APPLICATION PROCESS ID&quot; ITEM CCSDSSEQFLAGS 16 2 UINT &quot;CCSDS SEQUENCE FLAGS&quot; STATE FIRST 0 STATE CONT 1 STATE LAST 2 STATE NOGROUP 3 ITEM CCSDSSEQCNT 18 14 UINT &quot;CCSDS PACKET SEQUENCE COUNT&quot; ITEM CCSDSLENGTH 32 16 UINT &quot;CCSDS PACKET DATA LENGTH&quot; ITEM CCSDSDAY 48 16 UINT &quot;DAYS SINCE EPOCH (JANUARY 1ST, 1958, MIDNIGHT)&quot; ITEM CCSDSMSOD 64 32 UINT &quot;MILLISECONDS OF DAY (0 - 86399999)&quot; ITEM CCSDSUSOMS 96 16 UINT &quot;MICROSECONDS OF MILLISECOND (0-999)&quot; ITEM ANGLEDEG 112 16 INT &quot;Instrument Angle in Degrees&quot; POLY_READ_CONVERSION 0 57.295 ITEM MODE 128 8 UINT &quot;Instrument Mode&quot; STATE NORMAL 0 GREEN STATE DIAG 1 YELLOW ITEM TIMESECONDS 0 0 DERIVED &quot;DERIVED TIME SINCE EPOCH IN SECONDS&quot; GENERIC_READ_CONVERSION_START FLOAT 32 ((packet.read('ccsdsday') * 86400.0) + (packet.read('ccsdsmsod') / 1000.0) + (packet.read('ccsdsusoms') / 1000000.0) ) GENERIC_READ_CONVERSION_END ITEM TIMEFORMATTED 0 0 DERIVED &quot;DERIVED TIME SINCE EPOCH AS A FORMATTED STRING&quot; GENERIC_READ_CONVERSION_START STRING 216 time = Time.ccsds2mdy(packet.read('ccsdsday'), packet.read('ccsdsmsod'), packet.read('ccsdsusoms')) sprintf('%04u/%02u/%02u %02u:%02u:%02u.%06u', time[0], time[1], time[2], time[3], time[4], time[5], time[6]) GENERIC_READ_CONVERSION_END  ","version":"次へ","tagName":"h2"},{"title":"管理者","type":0,"sectionRef":"#","url":"/ja/docs/tools/admin","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"管理者","url":"/ja/docs/tools/admin#はじめに","content":" 管理者ツールは、ツールリストの上部に専用のボタンがあります。このツールはCOSMOSシステムの管理を担当しており、新しいプラグインのインストール、設定の閲覧、シークレットの保存、設定の変更などが可能です。  ","version":"次へ","tagName":"h2"},{"title":"プラグイン​","type":1,"pageTitle":"管理者","url":"/ja/docs/tools/admin#プラグイン","content":" プラグインタブでは、COSMOSシステムに新しいプラグインをインストールできます。プラグインは、ターゲット、マイクロサービス、インターフェース、プロトコル、テレメトリビューアウィジェット、およびツールをCOSMOSランタイムに追加できます。以下のスクリーンショットは、COSMOS Demoのみがインストールされている場合のプラグインタブを表示しています：    プラグインのGem名がリストされ、含まれるすべてのターゲットが表示されます。右側のボタンを使用して、プラグインのダウンロード、編集、アップグレード、または削除（アンインストール）ができます。プラグインのターゲットが変更された場合、ターゲット名はリンクに変わり、クリックすると変更されたファイルがダウンロードされます。新しいプラグインは、上部のフィールドをクリックしてインストールします。  ","version":"次へ","tagName":"h3"},{"title":"ターゲット​","type":1,"pageTitle":"管理者","url":"/ja/docs/tools/admin#ターゲット","content":" ターゲットタブでは、インストールされているすべてのターゲットと、それらがどのプラグインから来たかを表示します。目のアイコンをクリックすると、ターゲット設定を構成する生のJSONが表示されます。    ","version":"次へ","tagName":"h3"},{"title":"インターフェース​","type":1,"pageTitle":"管理者","url":"/ja/docs/tools/admin#インターフェース","content":" インターフェースタブでは、インストールされているすべてのインターフェースを表示します。目のアイコンをクリックすると、インターフェース設定を構成する生のJSONが表示されます。    ","version":"次へ","tagName":"h3"},{"title":"ルーター​","type":1,"pageTitle":"管理者","url":"/ja/docs/tools/admin#ルーター","content":" ルータータブでは、インストールされているすべてのルーターを表示します。目のアイコンをクリックすると、ルーター設定を構成する生のJSONが表示されます。    ","version":"次へ","tagName":"h3"},{"title":"マイクロサービス​","type":1,"pageTitle":"管理者","url":"/ja/docs/tools/admin#マイクロサービス","content":" マイクロサービスタブでは、インストールされているすべてのマイクロサービス、その更新時間、状態、数を表示します。目のアイコンをクリックすると、マイクロサービス設定を構成する生のJSONが表示されます。    ","version":"次へ","tagName":"h3"},{"title":"パッケージ​","type":1,"pageTitle":"管理者","url":"/ja/docs/tools/admin#パッケージ","content":" パッケージタブでは、システムにインストールされているすべてのRuby gemとPythonパッケージを表示します。COSMOSがRubygemsやPypiから依存関係を取得できないオフライン（エアギャップ）環境にいる場合は、このタブからパッケージをインストールすることもできます。    ","version":"次へ","tagName":"h3"},{"title":"ツール​","type":1,"pageTitle":"管理者","url":"/ja/docs/tools/admin#ツール","content":" ツールタブには、インストールされているすべてのツールがリストされています。左側のグラブハンドルをドラッグアンドドロップして、ナビゲーションバーのツールの順序を変更できます。    追加ボタン (Add) を使用して、既存のツールへのリンクをナビゲーションバーに追加することもできます。ツールアイコンとしては、マテリアルデザインアイコンを使用できます。    ","version":"次へ","tagName":"h3"},{"title":"Redis​","type":1,"pageTitle":"管理者","url":"/ja/docs/tools/admin#redis","content":" Redisタブでは、基盤となるRedisデータベースと直接やり取りでき、データの変更や削除が簡単にできます。これは危険なため、COSMOSの開発者のみが実行すべきです。    ","version":"次へ","tagName":"h3"},{"title":"シークレット​","type":1,"pageTitle":"管理者","url":"/ja/docs/tools/admin#シークレット","content":" シークレットタブでは、SECRETキーワードを使用したインターフェースやマイクロサービスで使用できるシークレットを作成できます。シークレットはシークレット名の設定が必要で、シークレット値を使用して個別の値に設定したり、ファイルセレクターを使用してファイル（証明書ファイルなど）の内容に設定したりできます。次の例では、USERNAMEとPASSWORDは値に設定され、CA_FILEはアップロードされた証明書ファイルを使用して設定されています。    ","version":"次へ","tagName":"h3"},{"title":"設定​","type":1,"pageTitle":"管理者","url":"/ja/docs/tools/admin#設定","content":" 設定タブには、COSMOS全体で使用されるさまざまな設定が含まれています。これには、保存されたツール設定のクリア、アストロクロックの非表示、システムタイムゾーンの変更、上部と下部のバナーの追加、ナビゲーションバーにサブタイトルの作成、各パッケージライブラリのURLの変更などが含まれます。   ","version":"次へ","tagName":"h3"},{"title":"Licenses","type":0,"sectionRef":"#","url":"/ja/docs/meta/licenses","content":"","keywords":"","version":"次へ"},{"title":"AGPLv3​","type":1,"pageTitle":"Licenses","url":"/ja/docs/meta/licenses#agplv3","content":" This is our default open source license and the license that most free users use. The AGPLv3 is a modification of the GPLv3 which is what is known as a copy-left license or a viral license. You can read the whole thing here: OpenC3 AGPLv3  Obviously, the actual license text applies, but here is a short summary:  The AGPL allows users to use the code however they want: For business, personal, etc., as long as they follow the other terms: Users are anyone who could access the web-app. On the public internet, that is the whole world. On a private network, it is anyone with access to that network. The software is provided as-is, no warranty Users must be given access to all the source code and are also allowed to use it however they want under the same terms of the AGPLv3. This includes any modifications made, anything added, and all plugins. For web applications (like COSMOS), a link must be provided to all of the source code. There are some key implications of the above: You cannot keep anything proprietary from your users. They have the rights to take the code (and configuration) and do anything they want with it. You CANNOT impede these rights or you are violating the AGPLv3 and YOU lose the rights to use our software. You must provide a digital link to all source code for your users, including plugins. All plugins must be licensed in an AGPLv3 compatible fashion. We recommend the MIT license because that allows your plugins to be compatible with the AGPLv3 and our commercial license. You can also use a dual license similar to what we do indicating the AGPLv3 or a purchased OpenC3 Commercial license.  The AGPLv3 license is often chosen because it works well for open core products like COSMOS. Competitors cannot take the open source product and license it under different terms. They would be forever locked into the AGPLv3 which is difficult to monetize, because your customers can take any code you provide and publish it on the internet for free use by everyone.  As the copyright holder, OpenC3 is able to license the product and derivatives commercially. No-one else can do this. (OpenC3 is also able to license legacy Ball Aerospace COSMOS code under IP agreement)  ","version":"次へ","tagName":"h2"},{"title":"Evaluation and Education Use Only​","type":1,"pageTitle":"Licenses","url":"/ja/docs/meta/licenses#evaluation-and-education-use-only","content":" This license takes effect as soon as you use any plugin we publish under Evaluation and Education terms. Currently the only plugin we use for this is our CCSDS CFDP plugin: CFDP Plugin  You can read the whole license here:  # OpenC3 Evaluation and Educational License # # Copyright 2023 OpenC3, Inc. # # This work is licensed for evaluation and educational purposes only. # It may NOT be used for formal development, integration and test, operations # or any other commercial purpose without the purchase of a commercial license # from OpenC3, Inc. # # The above copyright notice and this permission notice shall be included in all copies # or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, # INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A # PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT # HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE # SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.   This license is pretty straight forward, but the key is you can't use this code for any real work leading to a product (Formal Development, Integration and Test, or Operations) unless you switch to purchasing a commercial license.  ","version":"次へ","tagName":"h2"},{"title":"Commercial License​","type":1,"pageTitle":"Licenses","url":"/ja/docs/meta/licenses#commercial-license","content":" This license is a signed contract with OpenC3. It allows use of our code for a program under contractual terms where you do not have to follow the AGPLv3.  Generally we license to a specific project with terms that allow for unlimited users, and installs as needed by that project. Any code and plugins that you develop under the commercial license can be kept proprietary.  These licenses are sold as yearly subscriptions, or as a non-expiring perpetual license. We also offer site licenses, and licenses to support unlimited missions on a government framework architecture.  Of course with our commercial license, you also get all the extra functionality of our Enterprise product.  ","version":"次へ","tagName":"h2"},{"title":"Why you should buy a Commercial License​","type":1,"pageTitle":"Licenses","url":"/ja/docs/meta/licenses#why-you-should-buy-a-commercial-license","content":" You want to save years and tens of millions of dollars developing the same functionality yourself. You want all of the Enterprise functionality of COSMOS Enterprise Edition User AccountsRole Based Access ControlLDAP SupportKubernetes SupportCloud Deployment ConfigurationsThe right to use CFDP and other Enterprise Only pluginsGrafana SupportSupport from the COSMOS DevelopersLots more - See our Enterprise page You don't want to follow the AGPLv3 You want to keep the code and plugins you develop proprietaryYou don't want to publish an accessible link to your source code You want to support the continued development and innovation of the COSMOS product  We appreciate all of our commercial customers. You make OpenC3 possible. Thank you.  ","version":"次へ","tagName":"h3"},{"title":"FAQs​","type":1,"pageTitle":"Licenses","url":"/ja/docs/meta/licenses#faqs","content":" I see both Ball Aerospace &amp; Technologies Corp as well as OpenC3, Inc in the copyright headers. What does this mean? OpenC3, Inc has an intellectual property agreement with BAE (formerly Ball Aerospace &amp; Technologies Corp) which gives us the rights to commercialize the original work that we built at Ball Aerospace. Customers only need to purchase a commercial license from OpenC3. What are the limits of the COSMOS Enterprise Edition? How many users can we have? How many times can it be installed? The COSMOS Enterprise Edition license has no user or installation limits. How is the COSMOS Enterprise Edition license enforced? The COSMOS Enterprise Edition license is enforced through contract only without license managers or additional software controls. How is the COSMOS Enterprise Edition license applied? Per company? Per program? COSMOS Enterprise Edition is typically licensed to a named mission or group. We also have site licenses, company licenses, and mission ops center licenses. Please contact us at sales@openc3.com for more information. Do you license to foreign companies? How do you handle ITAR or the EAR? We have several international customers and are not subject to ITAR export controls. We are export controlled under the EAR via ECCN 5D002c1. We have a detailed writeup explaining this justification as well as a commodity classification document from the Department of Commerce. Please contact us at sales@openc3.com for more information. ","version":"次へ","tagName":"h2"},{"title":"Philosophy","type":0,"sectionRef":"#","url":"/ja/docs/meta/philosophy","content":"Philosophy COSMOS is a C3 (Command, Control and Communication) system with the following primary goals: Interface with Anything COSMOS should be able to communicate with anything that provides a computer-to-computer interface, regardless of what the interface is. This means that COSMOS adapts to what other systems are doing and evolves over time. It does not publish an API that hardware must adhere to if it wants to communicate with COSMOS. Log Everything All data that flows into and out of COSMOS is logged. This provides history as well as attribution for what happened when and why. Keeping accurate logs is an essential and critical aspect of COSMOS. Open Architecture and Source Nothing about how COSMOS is implemented is meant to be secret or hidden, even in Enterprise Edition. In all editions, the source code for everything in COSMOS is provided and available for users to inspect or modify as needed. Never worry about an unsolvable problem or having to accept some detail that you don't like. This also opens the world to integrate anything they need into COSMOS without restriction or limitation. Be Modular There are infinite number of things for COSMOS to connect to, but it is impossible to ship COSMOS with all the code it would need to talk to everything. For this reason, COSMOS is designed to be modular in all the places that matter. Use Configuration when Possible, and Code When Logic Is Needed Configuration is great for making COSMOS as usable as possible by non-software engineers. It also shows where common patterns exist. However, configuration is horrible when logic or custom math are needed. Empower Developers COSMOS is meant to be easy enough to be used by everyone, not just C2 software experts.","keywords":"","version":"次へ"},{"title":"XTCE Support","type":0,"sectionRef":"#","url":"/ja/docs/meta/xtce","content":"","keywords":"","version":"次へ"},{"title":"Running COSMOS using an .xtce definition file​","type":1,"pageTitle":"XTCE Support","url":"/ja/docs/meta/xtce#running-cosmos-using-an-xtce-definition-file","content":" A single .xtce file containing the command and telemetry definitions for a target can be used in place of the normal COSMOS command and telemetry definition files. Simply place the target's .xtce file in the target's cmd_tlm folder and COSMOS will use it for the command and telemetry definitions.  ","version":"次へ","tagName":"h2"},{"title":"Converting a .xtce file into a COSMOS configuration​","type":1,"pageTitle":"XTCE Support","url":"/ja/docs/meta/xtce#converting-a-xtce-file-into-a-cosmos-configuration","content":" Use the following command to convert a .xtce file into COSMOS configuration files. The converted configuration files will be placed into a target folder in the given output directory.  openc3.bat cli xtce_converter --import &lt;xtce_filename&gt; --output &lt;output_dir&gt;   ","version":"次へ","tagName":"h2"},{"title":"Converting a COSMOS Configuration to XTCE​","type":1,"pageTitle":"XTCE Support","url":"/ja/docs/meta/xtce#converting-a-cosmos-configuration-to-xtce","content":" Use the following command to convert your openc3 plugin into .xtce files, one per target. The converted .xtce files will be placed into a target folder in the given output directory.  openc3.bat cli xtce_converter --plugin &lt;plugin.gem&gt; --output &lt;output_dir&gt;   ","version":"次へ","tagName":"h2"},{"title":"High-level Overview of Current Support​","type":1,"pageTitle":"XTCE Support","url":"/ja/docs/meta/xtce#high-level-overview-of-current-support","content":" Integer, Float, Enumerated, String, and Binary Parameter/Argument Types are SupportedAll DataEncodings are supportedTelemetry and Commands are SupportedPacket Identification is supportedStates are supportedUnits are supportedPolynomialCalibrators are supportedOnly one SpaceSystem per .xtce filePackets should not have gaps between items  ","version":"次へ","tagName":"h2"},{"title":"Supported Elements and Attributes​","type":1,"pageTitle":"XTCE Support","url":"/ja/docs/meta/xtce#supported-elements-and-attributes","content":" The following elements and associated attributes are currently supported.  SpaceSystemTelemetryMetaDataCommandMetaDataParameterTypeSetEnumerationListParameterSetContainerSetEntryListDefaultCalibratorDefaultAlarmRestrictionCriteriaComparisonListMetaCommandSetDefaultCalibratorArgumentTypeSetArgumentListArgumentAssignmentListEnumeratedParameterTypeEnumeratedArgumentTypeIntegerParameterTypeIntegerArgumentTypeFloatParameterTypeFloatArgumentTypeStringParameterTypeStringArgumentTypeBinaryParameterTypeBinaryArgumentTypeIntegerDataEncodingFloatDataEncodingStringDataEncodingBinaryDataEncoding'SizeInBitsFixedValueUnitSetUnitPolynomialCalibratorTermStaticAlarmRangesWarningRangeCriticalRangeValidRangeEnumerationParameterArgumentParameterPropertiesSequenceContainerBaseContainerLongDescriptionParameterRefEntryArgumentRefEntryBaseMetaCommandComparisonMetaCommandBaseMetaCommandCommandContainerArgumentAssignment  ","version":"次へ","tagName":"h2"},{"title":"Ignored Elements​","type":1,"pageTitle":"XTCE Support","url":"/ja/docs/meta/xtce#ignored-elements","content":" The following elements are simply ignored by COSMOS:  HeaderAliasSetAlias  ","version":"次へ","tagName":"h2"},{"title":"Unsupported Elements​","type":1,"pageTitle":"XTCE Support","url":"/ja/docs/meta/xtce#unsupported-elements","content":" Any elements not listed above are currently unsupported. Near term support for the following elements and features are planned and priority will be determined by user requests.  SplineCalibratorAlternate methods of specifying offsets into containersOutput to the XUSP standardAdditional Data TypesContainer References  If there is a particular element or feature you need supported please submit a ticket on Github. ","version":"次へ","tagName":"h2"},{"title":"プロトコル","type":0,"sectionRef":"#","url":"/ja/docs/configuration/protocols","content":"","keywords":"","version":"次へ"},{"title":"パケット区切りプロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#パケット区切りプロトコル","content":" COSMOSは以下のパケット区切りプロトコルを提供しています：COBS、SLIP、Burst、Fixed、Length、Template（非推奨）、TerminatedおよびPreidentified。これらの各プロトコルの主な目的は、バイトストリームからパケットを分離することです。  COSMOS Enterpriseは以下のパケット区切りプロトコルを提供しています：CCSDS CLTU（BCHエンコード付き）、CCSDS TCTF（ランダマイザー付き）、CCSDS TMTF（ランダマイザー付き）、およびGEMS。  すべてのプロトコルは「Allow Empty Data」と呼ばれる最終パラメータを取ることに注意してください。これは、プロトコルが空の文字列を後続のプロトコルに渡すことを許可するかどうかを示します（:STOPを返す代わりに）。true、false、またはnilが可能で、nilはプロトコルがチェーンの最後のプロトコルでない限りtrueとして解釈されます。プロトコルのエンドユーザーはほとんどの場合、このパラメータを省略します。詳細については、カスタムプロトコルのドキュメントを参照してください。  PROTOCOLキーワードの後の最初のパラメータは、プロトコルの適用方法を示します：READ、WRITE、またはREAD_WRITE。Readは入力パケット（テレメトリ）にプロトコルを適用し、writeは出力パケット（コマンド）に適用します。次のパラメータはプロトコルのファイル名またはクラス名です。その他のパラメータはプロトコル固有のものです。  ","version":"次へ","tagName":"h2"},{"title":"COBSプロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#cobsプロトコル","content":" Consistent Overhead Byte Stuffing（COBS）プロトコルは、パケットの内容に関係なく、効率的で信頼性が高く、明確なパケットフレーミングを実現するデータバイトをエンコードするアルゴリズムです。これにより、受信アプリケーションが不正な形式のパケットから回復することが容易になります。パケットの区切り文字（パケット間の境界を示す特別な値）として機能するゼロバイト値を使用します。このアルゴリズムは、各ゼロデータバイトを非ゼロの値で置き換えるため、パケット内にゼロデータバイトが現れず、パケット境界として誤解釈されることがありません（詳細は https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing を参照）。  ","version":"次へ","tagName":"h3"},{"title":"SLIPプロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#slipプロトコル","content":" Serial Line IP（SLIP）プロトコルは、シリアル回線上でIPパケットをフレーム化する文字シーケンスを定義します。ENDとESCという2つの特殊文字を定義します。ENDは0xC0で、ESCは0xDBです。パケットを送信するために、SLIPホストは単にパケット内のデータの送信を開始します。データバイトがEND文字と同じコードである場合、代わりにESCと0xDCの2バイトシーケンスが送信されます。データバイトがESC文字と同じである場合、代わりにESCと0xDDの2バイトシーケンスが送信されます。パケット内の最後のバイトが送信されると、END文字が送信されます（詳細は https://datatracker.ietf.org/doc/html/rfc1055 を参照）。  パラメータ\t説明\t必須\tデフォルトStart Char\tフレームの先頭に配置する文字\tいいえ\tnil（文字なし） Read Strip Characters\t読み取りからstart_charとend_charを削除する\tいいえ\ttrue Read Enable Escaping\t読み取り時に文字エスケープを有効にするかどうか\tいいえ\ttrue Write Enable Escaping\t書き込み時に文字エスケープを有効にするかどうか\tいいえ\ttrue End Char\tフレームの末尾に配置する文字\tいいえ\t0xC0 Esc Char\tエスケープ文字\tいいえ\t0xDB Escape End Char\tEnd文字をエスケープするための文字\tいいえ\t0xDC Escape Esc Char\tEsc文字をエスケープするための文字\tいいえ\t0xDD  ","version":"次へ","tagName":"h3"},{"title":"バーストプロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#バーストプロトコル","content":" バーストプロトコルは、データをCOSMOSパケットとして返す前に、インターフェースからできるだけ多くのデータを読み取ります（読み取られたデータの各バーストに対してパケットを返します）。このプロトコルは時間で区切られた定期的なデータバーストに依存しているため、非常に堅牢ではありません。ただし、必要に応じて再同期を可能にする同期パターンを利用できます。また、同期パターンを削除するために、受信データからバイトを破棄することもできます。最後に、インターフェースから書き出されるデータに同期パターンを追加することもできます。  パラメータ\t説明\t必須\tデフォルトDiscard Leading Bytes\t読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンから始まるバイトに適用されることに注意してください。\tいいえ\t0（バイトを破棄しない） Sync Pattern\t生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます\tいいえ\tnil（同期パターンなし） Fill Fields\t送信パケットに同期パターンを入力するかどうか\tいいえ\tfalse  ","version":"次へ","tagName":"h3"},{"title":"固定プロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#固定プロトコル","content":" 固定プロトコルは、インターフェースを使用して定義されたすべてのパケットを適切に識別するために必要な、事前に設定された最小量のデータを読み取ります。その後、パケットを識別し、パケットを作成するために必要なだけのデータをインターフェースから読み取り、それを返します。このプロトコルは、インターフェース上のすべてのパケットが固定長であることに依存しています。例えば、インターフェースを使用するすべてのパケットは固定サイズであり、32ビットの同期パターンに続いて16ビットのIDを含む単純なヘッダーが含まれています。固定プロトコルは、最小読み取りサイズが6バイトであるこのケースをエレガントに処理します。固定プロトコルは、バーストプロトコルと同様に、同期パターン、先頭バイトの破棄、同期パターンの入力もサポートしています。  パラメータ\t説明\t必須\tデフォルトMinimum ID Size\tパケットを識別するために必要な最小バイト数。すべてのパケット定義は、この指定されたバイト数内でID_ITEMを宣言する必要があります。\tはい Discard Leading Bytes\t読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンから始まるバイトに適用されることに注意してください。\tいいえ\t0（バイトを破棄しない） Sync Pattern\t生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます。\tいいえ\tnil（同期パターンなし） Telemetry\tデータがテレメトリかどうか\tいいえ\ttrue（falseはコマンドを意味） Fill Fields\t送信パケットに同期パターンを入力するかどうか\tいいえ\tfalse Unknown Raise\t不明なパケットに対して例外を発生させるかどうか\tいいえ\tfalse  ","version":"次へ","tagName":"h3"},{"title":"長さプロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#長さプロトコル","content":" 長さプロトコルは、インターフェースを使用する定義されたパケット内の固定位置にある長さフィールドに依存します。十分なデータを読み取って長さフィールドを取得し、それをデコードし、パケットの残りの長さを読み取ります。例えば、インターフェースを使用するすべてのパケットには、長さフィールドを持つCCSDSヘッダーが含まれています。長さプロトコルは、長さフィールドや、CCSDSが使用する長さオフセットも処理するように設定できます。長さプロトコルは、バーストプロトコルと同様に、同期パターン、先頭バイトの破棄、長さと同期パターンの入力もサポートしています。  パラメータ\t説明\t必須\tデフォルトLength Bit Offset\tパケットの先頭から長さフィールドまでのビットオフセット。このインターフェースを使用するすべてのパケットは、長さフィールドが同じ場所で同じサイズになるような同じ構造を持っている必要があります。この値に同期パターンの長さを考慮することを忘れないでください（存在する場合）。\tいいえ\t0ビット Length Bit Size\t長さフィールドのビットサイズ\tいいえ\t16ビット Length Value Offset\t長さフィールド値に適用するオフセット。長さフィールドの実際の値にこのオフセットを加えると、パケットのすべてのデータ（長さフィールド自体、同期パターンなどを含む）を読み取るために必要な正確なバイト数と等しくなる必要があります。例えば、長さフィールドがパケット長から1を引いた値を示す場合、この値は1になります。この値に同期パターンの長さを考慮することを忘れないでください（存在する場合）。\tいいえ\t0 Bytes per Count\t各長さフィールドの「カウント」あたりのバイト数。これは、長さフィールドの単位がバイト以外の場合（例えば、長さフィールドのカウントがワード単位の場合）に使用されます。\tいいえ\t1バイト Length Endianness\t長さフィールドのエンディアン。「BIG_ENDIAN」または「LITTLE_ENDIAN」のいずれかでなければなりません。\tいいえ\t'BIG_ENDIAN' Discard Leading Bytes\t読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンを含むバイトに適用されることに注意してください。破棄は最後のステップの1つであるため、上記のサイズとオフセットは破棄前のすべてのデータを考慮する必要があります。\tいいえ\t0（バイトを破棄しない） Sync Pattern\t生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます。\tいいえ\tnil（同期パターンなし） Max Length\t長さフィールドで許可される最大値\tいいえ\tnil（最大長なし） Fill Length and Sync Pattern\tこのフラグをtrueに設定すると、送信パケットに長さフィールドと同期パターン（存在する場合）が自動的に入力されます。\tいいえ\tfalse  長さプロトコルの最も混乱する側面は、Length Value Offsetの計算です。これは、よく使用されるCCSDS宇宙パケットプロトコルで特に当てはまります。これを説明する最良の方法は例を使用することです。同期パターン0x1ACFFC1Dが前に付いたCCSDS宇宙パケットがあるとします。これは次のようになります：  同期（4バイト）\tヘッダー（4バイト）\t長さ（2バイト）\tデータ（4バイト）0x1ACFFC1D\t0x0001CADB\t0x0003\t0xDEADBEEF  この場合、パケットの合計長は14バイトです：4 + 4 + 2 + 4 = 14。データが4バイトの場合、CCSDSでは長さフィールドは（データ長 - 1）として計算されるため、長さフィールドは3になります。では、Length Value Offsetをどのように計算すればよいでしょうか？COSMOSはパケット内のすべてのバイト（同期パターンを含む）を読み取るため、合計長は14バイトです。長さフィールドは3なので、Length Value Offset（長さフィールド値に適用するオフセット）は11であるべきです（3 + 11 = 14）。  ","version":"次へ","tagName":"h3"},{"title":"終端プロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#終端プロトコル","content":" 終端プロトコルは、各パケットの末尾にある終端文字を使用してパケットを区切ります。終端文字が見つかるまで継続的にデータを読み取り、その時点でパケットデータを返します。例えば、インターフェースを使用するすべてのパケットの後に0xABCDが続きます。このデータは、保持される各パケットの一部であるか、または終端プロトコルだけが知っていて単に捨てられるものであるかのいずれかです。  パラメータ\t説明\t必須\tデフォルトWrite Termination Characters\tコマンドパケットを書き込んだ後に書き込むデータ。0xABCDなどの16進文字列として指定します。\tはい Read Termination Characters\tテレメトリパケットの終わりを示す文字。0xABCDなどの16進文字列として指定します。\tはい Strip Read Termination\tテレメトリパケットを返す前に読み取り終端文字を削除するかどうか\tいいえ\ttrue Discard Leading Bytes\t読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンを含むバイトに適用されることに注意してください。\tいいえ\t0（バイトを破棄しない） Sync Pattern\t生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます。\tいいえ\tnil（同期パターンなし） Fill Fields\t送信パケットに同期パターンを入力するかどうか\tいいえ\tfalse  ","version":"次へ","tagName":"h3"},{"title":"GEMSプロトコル（Enterprise）​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#gemsプロトコルenterprise","content":" GEMSプロトコルは、地上機器監視サービスプロトコルを実装しています。これは、「|END」を使用してパケットを区切るTerminatedProtocolと一緒に追加されます。GEMSインターフェースは現在Rubyでのみ実装されています。  GEMSプロトコルはパラメータを取りませんが、TerminatedProtocolとCmdResponseProtocolの後にインターフェースに追加する必要があります。  plugin.txt Rubyの例：  INTERFACE GEMS_INT tcpip_client_interface.rb openc3-operator 8080 8080 10.0 nil nil # TerminatedProtocol 0x7C454E44 0x7C454E44 false 0 0x7C47454D53 false ... の意味： # wtc rtc strip discard sync fill # wtc = 書き込み終端文字、gemsプロトコルの終わり：0x7C454E44 == '|END' # rtc = 読み取り終端文字、gemsプロトコルの終わり：0x7C454E44 == '|END' # strip = 読み取り終端を削除（false） # discard = 0バイト # sync pattern = GEMSプロトコルの始まり：0x7C47454D53 == '|GEMS' # fill = 同期パターンを入力するかどうか（cmd/tlm定義でfillを指定するのでfalse） PROTOCOL READ TerminatedProtocol 0x7C454E44 0x7C454E44 false 0 0x7C47454D53 false # CmdResponseProtocol 5.0 0.2 true の意味： # 5秒応答タイムアウト、0.2秒応答ポーリング、 # そしてプロトコルエラーが発生したときに例外を発生させるためのtrue PROTOCOL READ_WRITE CmdResponseProtocol 5.0 0.2 true PROTOCOL READ_WRITE GemsProtocol   完全な例については、COSMOS Enterprise Pluginsのopenc3-cosmos-gems-interfaceを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"CCSDS CLTUプロトコル（Enterprise）​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#ccsds-cltuプロトコルenterprise","content":" CCSDS CLTUプロトコルは、コマンドストリーム用のCLTU（通信リンク転送ユニット）を処理します。これは送信メッセージをBCHエンコーディングでエンコードし、データにヘッダーとフッターを適用します。  パラメータ\t説明\t必須\tデフォルトHeader\tBCHエンコードデータの前のヘッダー\tいいえ\t0xEB90 Footer\tBCHエンコードデータの後のフッター\tいいえ\t0xC5C5C5C5C5C5C579 Fill Byte\tBCHエンコーディングのフィルバイト\tいいえ\t0x55  完全な例については、COSMOS Enterprise Pluginsのopenc3-cosmos-ccsds-protocolsを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"CCSDS TCTFプロトコル（Enterprise）​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#ccsds-tctfプロトコルenterprise","content":" CCSDS TCTFプロトコルは、コマンドストリーム用のテレコマンド転送フレームを処理します。  パラメータ\t説明\t必須\tデフォルトRandomization\t転送フレームをエンコードし、ランダム化するかどうか\tいいえ\ttrue Error Control\tフレームエラー制御フィールドを使用し、16ビットCRCを適用するかどうか\tいいえ\tfalse Bypass\tバイパスビット（0はType-A、1はType-B（フレーム受け入れチェックをバイパス））\tいいえ\t1 SCID\t宇宙機識別子（10ビット）\tいいえ\t0 VCID\t仮想チャネル識別子（6ビット）\tいいえ\t0  完全な例については、COSMOS Enterprise Pluginsのopenc3-cosmos-ccsds-protocolsを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"CCSDS TMTFプロトコル（Enterprise）​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#ccsds-tmtfプロトコルenterprise","content":" CCSDS TMTFプロトコルは、テレメトリストリーム用のテレメトリ転送フレームを処理します。VCID、MC_FRM_CNT、VC_FRM_CNTをextraに追加し、これらはDecomデータに含まれます。  パラメータ\t説明\t必須\tデフォルトSCID\t宇宙機識別子（10ビット）\tはい Frame Length\tフレーム長\tいいえ\t2048 Randomization\t転送フレームがエンコードされ、ランダム化されたかどうか\tいいえ\ttrue Discard Leading Bytes\t読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンを含むバイトに適用されることに注意してください。\tいいえ\t0（バイトを破棄しない） Sync Pattern\t生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます。\tいいえ\t0x1ACFFC1D Fill Fields\t送信パケットに同期パターンを入力するかどうか\tいいえ\ttrue  完全な例については、COSMOS Enterprise Pluginsのopenc3-cosmos-ccsds-protocolsを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"テンプレートプロトコル（非推奨）​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#テンプレートプロトコル非推奨","content":" このプロトコルは、COSMOS生ログにおいて元のSCPIメッセージをキャプチャできないため、現在は非推奨です。代わりにTemplateAccessorとCmdResponseProtocolを使用してください。  テンプレートプロトコルは、SCPI（プログラム可能な機器用標準コマンド）などのテキストベースのコマンドおよび応答タイプのインターフェース用に設計されている点を除いて、終端プロトコルと非常によく似ています。各パケットが行と呼ばれる（通常は各行にテキスト行が含まれるため）ことを除いて、終端プロトコルと同じ方法でパケットを区切ります。送信パケットの場合、パケット内にCMD_TEMPLATEフィールドが存在することが期待されます。このフィールドには、HTMLタグスタイルの括弧&quot;&lt;EXAMPLE&gt;&quot;内で区切られた、埋め込むべき項目を含むテンプレート文字列が含まれています。テンプレートプロトコルはパケット内から名前付き項目を読み取り、CMD_TEMPLATEに入力します。このように入力された文字列は、元々渡されたパケットではなく送信されます。同様に、応答が期待される場合、送信パケットにはRSP_TEMPLATEおよびRSP_PACKETフィールドを含める必要があります。RSP_TEMPLATEは応答文字列からデータを抽出し、対応するRSP_PACKETを構築するために使用されます。使用例については、COSMOSデモ設定内のTEMPLATEターゲットを参照してください。  パラメータ\t説明\t必須\tデフォルトWrite Termination Characters\tコマンドパケットを書き込んだ後に書き込むデータ。0xABCDなどの16進文字列として指定します。\tはい Read Termination Characters\tテレメトリパケットの終わりを示す文字。0xABCDなどの16進文字列として指定します。\tはい Ignore Lines\t無視する応答行の数（完全に削除）\tいいえ\t0行 Initial Read Delay\t接続後の初期遅延時間。この後、インターフェースは空になるまで読み取られ、データは破棄されます。接続ヘッダーと初期プロンプトを破棄するのに役立ちます。\tいいえ\tnil（初期読み取りなし） Response Lines\t期待される応答を構成する行数\tいいえ\t1行 Strip Read Termination\tテレメトリパケットを返す前に読み取り終端文字を削除するかどうか\tいいえ\ttrue Discard Leading Bytes\t読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンを含むバイトに適用されることに注意してください。\tいいえ\t0（バイトを破棄しない） Sync Pattern\t生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます。\tいいえ\tnil（同期パターンなし） Fill Fields\t送信パケットに同期パターンを入力するかどうか\tいいえ\tfalse Response Timeout\t応答がタイムアウトするまでの待機秒数\tいいえ\t5.0 Response Polling Period\t応答のポーリング間の待機秒数\tいいえ\t0.02 Raise Exceptions\tタイムアウトや予期しない応答などのエラーが発生した場合に例外を発生させるかどうか\tいいえ\tfalse  ","version":"次へ","tagName":"h3"},{"title":"事前識別プロトコル（内部）​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#事前識別プロトコル内部","content":" 事前識別プロトコルは、カスタムCOSMOSヘッダーを使用してパケットを区切ります。この内部プロトコルは、ツールが接続してパケットストリーム全体を受信できるようにするために作成されました。また、複数のCOSMOSインスタンスを連結するためにも使用できますが、新しいウェブネイティブ実装ではほとんど必要ありません。  パラメータ\t説明\t必須\tデフォルトSync Pattern\t生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンの後にあるすべてのデータが返されます。同期パターン自体は破棄されます。\tいいえ\tnil（同期パターンなし） Max Length\t長さフィールドで許可される最大値\tいいえ\tnil（最大長なし） Mode\tサポートする事前識別プロトコルのバージョン（2または4）\tいいえ\t4  ","version":"次へ","tagName":"h3"},{"title":"ヘルパープロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#ヘルパープロトコル","content":" COSMOSは以下のヘルパープロトコルを提供しています：CmdResponse、Crc、およびIgnore。これらのプロトコルはインターフェースにヘルパー機能を提供します。  ","version":"次へ","tagName":"h2"},{"title":"CmdResponseプロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#cmdresponseプロトコル","content":" CmdResponseプロトコルは、定義された応答パケットを持つコマンドの応答を待ちます。  パラメータ\t説明\t必須\tデフォルトResponse Timeout\t応答を待つ際にタイムアウトするまでの秒数\tいいえ\t5 Response Polling Period\t応答のポーリング間の待機秒数\tいいえ\t0.02 Raise Exceptions\t予期しない応答や応答タイムアウトなどのプロトコルでエラーが発生した場合に例外を発生させるかどうか\tいいえ\tfalse  パケット定義​  CmdResponseProtocolは、コマンド定義内のRESPONSEキーワードを使用して、指定されたコマンドが送信されたときに期待されるテレメトリパケットを決定します。  COMMAND SCPI_PS GET_STATUS BIG_ENDIAN &quot;Gets status&quot; ACCESSOR TemplateAccessor TEMPLATE &quot;:MEAS:VOLT? (@1:2)&quot; RESPONSE SCPI_PS STATUS   応答パケット（STATUS）は、応答データを含むように定義する必要があります。  TELEMETRY SCPI_PS STATUS BIG_ENDIAN &quot;Status&quot; ACCESSOR TemplateAccessor TEMPLATE &quot;&lt;MEAS_VOLTAGE_1&gt;,&lt;MEAS_VOLTAGE_2&gt;&quot; APPEND_ITEM MEAS_VOLTAGE_1 32 FLOAT &quot;Voltage Reading for Channel 1&quot; UNITS VOLTS V FORMAT_STRING %0.3f APPEND_ITEM MEAS_VOLTAGE_2 32 FLOAT &quot;Voltage Reading for Channel 2&quot; UNITS VOLTS V FORMAT_STRING %0.3f   完全な例については、COSMOS Enterprise Pluginsのopenc3-cosmos-scpi-power-supplyを参照してください。  ","version":"次へ","tagName":"h3"},{"title":"CRCプロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#crcプロトコル","content":" CRCプロトコルは、送信コマンドにCRCを追加し、受信テレメトリパケットのCRCを検証できます。  パラメータ\t説明\t必須\tデフォルトWrite Item Name\t送信パケットの計算済みCRC値で埋めるアイテム（nil = 埋めない）\tいいえ\tnil Strip CRC\t受信パケットからCRCを削除するかどうか\tいいえ\tfalse Bad Strategy\t受信パケットのCRCエラーを処理する方法。ERROR = エラーのみをログに記録、DISCONNECT = インターフェースを切断\tいいえ\t&quot;ERROR&quot; Bit Offset\tデータ内のCRCのビットオフセット。負の値はパケットの末尾からの距離を示します\tいいえ\t-32 Bit Size\tCRCのビットサイズ - 16、32、または64でなければなりません\tいいえ\t32 Endianness\tCRCのエンディアン（BIG_ENDIAN/LITTLE_ENDIAN）\tいいえ\t&quot;BIG_ENDIAN&quot; Poly\tCRCを計算する際に使用する多項式（整数として表現）\tいいえ\tnil（デフォルトの多項式を使用 - 16ビット=0x1021、32ビット=0x04C11DB7、64ビット=0x42F0E1EBA9EA3693） Seed\t計算を開始するシード値\tいいえ\tnil（デフォルトのシードを使用 - 16ビット=0xFFFF、32ビット=0xFFFFFFFF、64ビット=0xFFFFFFFFFFFFFFFF） Xor\tCRC結果を0xFFFFとXOR演算するかどうか\tいいえ\tnil（デフォルト値を使用 - 16ビット=false、32ビット=true、64ビット=true） Reflect\tCRCを計算する前にデータの各バイトのビットを反転するかどうか\tいいえ\tnil（デフォルト値を使用 - 16ビット=false、32ビット=true、64ビット=true）  ","version":"次へ","tagName":"h3"},{"title":"パケット無視プロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#パケット無視プロトコル","content":" パケット無視プロトコルは、COSMOSによって送信された特定のコマンドパケットまたは受信テレメトリパケットを破棄します。  パラメータ\t説明\t必須\tデフォルトTarget Name\t無視するパケットのターゲット名\tはい\tnil Packet Name\t無視するパケットのパケット名\tはい\tnil  ","version":"次へ","tagName":"h3"},{"title":"カスタムプロトコル​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#custom-protocol","content":" カスタムプロトコルの作成は簡単で、COSMOSインターフェースをカスタマイズするためのデフォルトの解決策であるべきです（新しいインターフェースクラスを作成するのではなく）。ただし、カスタムインターフェースを作成することは、ターゲットに対して常に固定されている値にパラメータをデフォルト設定し、必要なプロトコルを含めるのにも役立ちます。基本COSMOSインターフェースは多くのパラメータを取り、エンドユーザーにとって混乱する可能性があります。したがって、これらの値をハードコードし、利用可能なパラメータをホスト名や接続ポートなどに絞り込むためだけにカスタムインターフェースを作成することをお勧めします。  すべてのカスタムプロトコルは、Protocolクラスopenc3/interfaces/protocols/protocol.rb（Ruby）およびopenc3/interfaces/protocols/protocol.py（Python）から派生する必要があります。このクラスは、独自のプロトコルを作成するための9つのメソッドを定義しています。各メソッドの基本クラス実装と、それらのメソッドを独自のプロトコルでどのようにオーバーライドして使用するかについての説明が以下に含まれています。  Ruby プロトコルAPI プロトコルはCOSMOSインターフェースの一部であるため、require 'openc3/script'を使用すべきではありません。代わりに、System、Packet、Bucket、BinaryAccessorなどのCOSMOSライブラリコードを直接使用する必要があります。不明な点がある場合は、既存のCOSMOSのプロトコルクラスを参照してください。  Python プロトコルAPI プロトコルはCOSMOSインターフェースの一部であるため、from openc3.script import *を使用すべきではありません。代わりに、System、Packet、Bucket、BinaryAccessorなどのCOSMOSライブラリコードを直接使用する必要があります。不明な点がある場合は、既存のCOSMOSのプロトコルクラスを参照してください。  プロトコルがどのように機能するかを本当に理解するためには、まず基本インターフェースクラスの読み取りと書き込みのメソッド内のロジックを理解する必要があります。  まず、readメソッドについて説明しましょう。  Rubyのシンボル、Pythonの文字列 以下の説明では、大文字の単語はRubyではシンボル、Pythonでは文字列を表します。したがって、STOPへの参照はRubyでは:STOP、Pythonでは&quot;STOP&quot;を意味します。    readが_毎回_呼び出されるたびに、空の文字列&quot;&quot;が最初に、インターフェースのread_interface()メソッドを使用して新しい生データの読み取りが試みられる_前に_、各読み取りプロトコルのread_data()メソッドに渡されます。これは、複数のパケット分のデータをキャッシュしているプロトコルに対して、インターフェースから新しいデータが読み取られる前にそれらのキャッシュされたパケットを出力するよう指示する信号です。通常、データはキャッシュされず、プロトコルのread_data()メソッドの1つが空の文字列に応答してSTOPを返し、パケットを生成するためにはさらにデータが必要であることを示します。各プロトコルのread_data()メソッドは、次の3つのいずれかを返すことができます：追加のプロトコルに渡されるか、パケットに変換されるデータ、プロトコルを続行するためにインターフェースからさらにデータが必要であることを意味するSTOP、またはインターフェースの切断（およびデフォルトでは再接続を試みる）が必要な何かが起こったことを意味するDISCONNECT。各プロトコルのread_data()メソッドには、最終的にパケットに変換されるデータが渡され、おそらく修正されたデータのセットが返されます。データがすべてのプロトコルのread_data()メソッドを通過すると、インターフェースのconvert_data_to_packet()メソッドを使用してCOSMOSパケットに変換されます。このパケットは同様の方法で各読み取りプロトコルのread_packet()メソッドを通過します。このメソッドは基本的に同じ戻り値の可能性を持っています：パケット（read_data()のデータではなく）、STOP、またはDISCONNECT。パケットがすべてのread_packet()メソッドを通過すると、インターフェースのパケット読み取りカウンターがインクリメントされ、パケットがインターフェースに返されます。    インターフェースのwrite()メソッドは、readと非常に似た働きをします。（デフォルトでは、書き込みプロトコルは読み取りプロトコルの逆順で実行されることに注意してください。これは、読み取り時にはデータの層を取り除き、書き込み時には逆順で層を追加するのが一般的なため理にかなっています。）  まず、パケット書き込みカウンターがインクリメントされます。次に、各書き込みプロトコルは、そのwrite_packet()メソッドが呼び出されることによってパケットを変更する機会が与えられます。このメソッドは、潜在的に修正されたパケット、STOP、またはDISCONNECTのいずれかを返すことができます。書き込みプロトコルがSTOPを返す場合、データはインターフェースに書き込まれず、最終的なパケットを出力する前にさらにパケットが必要であると想定されます。DISCONNECTはインターフェースを切断します。パケットがすべての書き込みプロトコルのwrite_packet()メソッドを通過すると、インターフェースのconvert_packet_to_data()メソッドを使用してバイナリデータに変換されます。次に、各書き込みプロトコルのwrite_data()メソッドが呼び出され、低レベルのデータを変更する機会が与えられます。COSMOSパケットではなくRuby文字列のデータが返される点を除いて、同じ戻りオプションが利用可能です。データがすべてのwrite_data()メソッドを通過すると、write_interface()メソッドを使用してインターフェースに書き込まれます。その後、各プロトコルのpost_write_interface()メソッドが、最終的に変更されたパケットと、インターフェースに実際に書き込まれたデータの両方で呼び出されます。このメソッドは、メッセージを書き出した後の応答を待つなどのフォローアップを可能にします。  ","version":"次へ","tagName":"h2"},{"title":"メソッドの説明​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#メソッドの説明","content":" ","version":"次へ","tagName":"h2"},{"title":"initialize または init​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#initialize-または-init","content":" これはカスタムプロトコルのコンストラクタです。基本プロトコルクラスを初期化するために、常にsuper(allow_empty_data)を呼び出す必要があります。  基本クラスのRuby実装:  # @param allow_empty_data [true/false] 空データでSTOPを返すべきかどうか def initialize(allow_empty_data = false) @interface = nil @allow_empty_data = ConfigParser.handle_true_false(allow_empty_data) reset() end   基本クラスのPython実装:  def __init__(self, allow_empty_data=None): self.interface = None self.allow_empty_data = ConfigParser.handle_true_false_none(allow_empty_data) self.reset()   ご覧のように、すべてのプロトコルは少なくとも2つの項目に関して状態を維持しています。interface変数は、プロトコルが関連付けられているインターフェースクラスのインスタンスを保持しています。これは、インターフェースだけが知っている詳細を内省するために時々必要です。allow_empty_dataは、この文書の後半で説明するread_data(data)メソッドで使用されるフラグです。  ","version":"次へ","tagName":"h3"},{"title":"reset​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#reset","content":" resetメソッドは、インターフェースが接続および/または切断されたときに内部プロトコル状態をリセットするために使用されます。このメソッドは共通のリセットロジックに使用されるべきです。接続と切断の特定のロジックは、次の2つのメソッドで処理されます。  基本クラスのRuby実装:  def reset end   基本クラスのPython実装:  def reset(self): pass   ご覧のように、基本クラスのreset実装は何も行いません。  ","version":"次へ","tagName":"h3"},{"title":"connect_reset​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#connect_reset","content":" connect_resetメソッドは、インターフェースが接続されるたびに内部プロトコル状態をリセットするために使用されます。  基本クラスのRuby実装:  def connect_reset reset() end   基本クラスのPython実装:  def connect_reset(self): self.reset()   基本クラスのconnect_reset実装は、共通のリセットロジックが実行されることを確実にするために、単にresetメソッドを呼び出します。  ","version":"次へ","tagName":"h3"},{"title":"disconnect_reset​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#disconnect_reset","content":" disconnect_resetメソッドは、インターフェースが切断されるたびに内部プロトコル状態をリセットするために使用されます。  基本クラスのRuby実装:  def disconnect_reset reset() end   基本クラスのPython実装:  def disconnect_reset(self): self.reset()   基本クラスのdisconnect_reset実装は、共通のリセットロジックが実行されることを確実にするために、単にresetメソッドを呼び出します。  ","version":"次へ","tagName":"h3"},{"title":"read_data​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#read_data","content":" read_dataメソッドは、インターフェースによって読み取られた生データを分析し、潜在的に変更するために使用されます。分析されるデータの現在の状態として1つのパラメータを取ります。データの文字列、STOP、またはDISCONNECTのいずれかを返すことができます。文字列を返す場合、データが完全なパケットになる準備ができていて、後続のプロトコルによる処理の準備ができていると考えられます。STOPが返された場合、プロトコルは完全なパケットを完成させるためにさらにデータが必要だと考えています。DISCONNECTが返された場合、プロトコルはインターフェースを切断すべき（そして通常は自動的に再接続を試みる）と考えています。  基本クラスのRuby実装:  def read_data(data) if (data.length &lt;= 0) if @allow_empty_data.nil? if @interface and @interface.read_protocols[-1] == self # 自動@allow_empty_dataを持つチェーン内の最後の読み取りインターフェース return :STOP end elsif !@allow_empty_data # @allow_empty_dataがfalseの場合はSTOP return :STOP end end data end   基本クラスのPython実装:  def read_data(self, data, extra=None): if len(data) &lt;= 0: if self.allow_empty_data is None: if self.interface and self.interface.read_protocols[-1] == self: # 自動self.allow_empty_dataを持つチェーン内の最後の読み取りインターフェース return (&quot;STOP&quot;, extra) elif self.allow_empty_data: # self.allow_empty_dataがfalseの場合はSTOP return (&quot;STOP&quot;, extra) return (data, extra)   基本クラスの実装は、与えられたデータを返すこと以外は何もしません。唯一の例外は空の文字列を処理する場合です。allow_empty_dataフラグがfalseである場合、またはnilであり、プロトコルがチェーン内の最後である場合、基本実装はSTOPを返し、インターフェースのread_interface()メソッドを呼び出してさらにデータを取得する時であることを示します。空の文字列は、キャッシュされたパケットを返す機会があることをプロトコルに通知するために使用されます。  ","version":"次へ","tagName":"h3"},{"title":"read_packet​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#read_packet","content":" read_packetメソッドは、インターフェースによって返される前にCOSMOSパケットを分析し、潜在的に変更するために使用されます。分析されるパケットの現在の状態として1つのパラメータを取ります。COSMOSパケット、STOP、またはDISCONNECTのいずれかを返すことができます。COSMOSパケットを返す場合、パケットが有効であり、返されるべきであり、後続のプロトコルによる処理の準備ができていると考えられます。STOPが返された場合、プロトコルはパケットを静かに破棄すべきだと考えています。DISCONNECTが返された場合、プロトコルはインターフェースを切断すべき（そして通常は自動的に再接続を試みる）と考えています。このメソッドは、パケットがリアルタイムテレメトリではなく保存されたテレメトリであるとプロトコルが判断した場合に、パケットにstoredフラグを設定する場所です。  基本クラスのRuby実装:  def read_packet(packet) return packet end   基本クラスのPython実装:  def read_packet(self, packet): return packet   基本クラスは常に与えられたパケットをそのまま返します。  ","version":"次へ","tagName":"h3"},{"title":"write_packet​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#write_packet","content":" write_packetメソッドは、インターフェースによって出力される前にCOSMOSパケットを分析し、潜在的に変更するために使用されます。分析されるパケットの現在の状態として1つのパラメータを取ります。COSMOSパケット、STOP、またはDISCONNECTのいずれかを返すことができます。COSMOSパケットを返す場合、パケットが有効であり、インターフェースに書き出されるべきであり、後続のプロトコルによる処理の準備ができていると考えられます。STOPが返された場合、プロトコルはパケットを静かに破棄すべきだと考えています。DISCONNECTが返された場合、プロトコルはインターフェースを切断すべき（そして通常は自動的に再接続を試みる）と考えています。  基本クラスのRuby実装:  def write_packet(packet) return packet end   基本クラスのPython実装:  def write_packet(self, packet): return packet   基本クラスは常に与えられたパケットをそのまま返します。  ","version":"次へ","tagName":"h3"},{"title":"write_data​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#write_data","content":" write_dataメソッドは、インターフェースによって書き込まれる前にデータを分析し、潜在的に変更するために使用されます。分析および送信されるデータの現在の状態として1つのパラメータを取ります。データの文字列、STOP、またはDISCONNECTのいずれかを返すことができます。データの文字列を返す場合、データが有効であり、インターフェースに書き出されるべきであり、後続のプロトコルによる処理の準備ができていると考えられます。STOPが返された場合、プロトコルはデータを静かに破棄すべきだと考えています。DISCONNECTが返された場合、プロトコルはインターフェースを切断すべき（そして通常は自動的に再接続を試みる）と考えています。  基本クラスのRuby実装:  def write_data(data) return data end   基本クラスのPython実装:  def write_data(self, data, extra=None): return (data, extra)   基本クラスは常に与えられたデータをそのまま返します。  ","version":"次へ","tagName":"h3"},{"title":"post_write_interface​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#post_write_interface","content":" post_write_interfaceメソッドは、データがインターフェースに書き込まれた後に呼び出されます。このメソッドの典型的な使用法は、コマンドに対して常に即時の応答が期待されるコマンド/レスポンスタイプのインターフェースを実装するためのフックを提供することです。write_packet()によるすべての変更後のパケットと、インターフェースに実際に書き込まれたデータという2つのパラメータを取ります。同じパケット/データのペア、STOP、またはDISCONNECTのいずれかを返すことができます。パケット/データのペアを返す場合、それらは他のプロトコルに渡されます。STOPが返された場合、インターフェースのwrite()呼び出しが完了し、それ以上のプロトコルのpost_write_interface()メソッドは呼び出されません。DISCONNECTが返された場合、プロトコルはインターフェースを切断すべき（そして通常は自動的に再接続を試みる）と考えています。戻り値の最初のパラメータ「packet」だけがSTOPまたはDISCONNECTとしてチェックされることに注意してください。  基本クラスのRuby実装:  def post_write_interface(packet, data) return packet, data end   基本クラスのPython実装:  def post_write_interface(self, packet, data, extra=None): return (packet, data, extra)   基本クラスは常に与えられたパケット/データをそのまま返します。  ","version":"次へ","tagName":"h3"},{"title":"protocol_cmd​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#protocol_cmd","content":" protocol_cmdメソッドは、プロトコル自体にコマンドを送信するために使用されます。これは実行時にプロトコルの動作を変更するのに役立ちます。詳細についてはinterface_protocol_cmdを参照してください。  基本クラスのRuby実装:  def protocol_cmd(cmd_name, *cmd_args) # デフォルトでは何もしない - サブクラスによって実装される return false end   基本クラスのPython実装:  def protocol_cmd(self, cmd_name, *cmd_args): # デフォルトでは何もしない - サブクラスによって実装される return False   これはサブクラスによって実装される特別な機能であるため、基本クラスは何も行いません。  ","version":"次へ","tagName":"h3"},{"title":"例​","type":1,"pageTitle":"プロトコル","url":"/ja/docs/configuration/protocols#例","content":" 上記のメソッドの実際の例については、リンクされているRuby ProtocolおよびPython Protocolコードを参照してください。 ","version":"次へ","tagName":"h2"},{"title":"カレンダー (Enterprise)","type":0,"sectionRef":"#","url":"/ja/docs/tools/calendar","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"カレンダー (Enterprise)","url":"/ja/docs/tools/calendar#はじめに","content":" カレンダーは、メタデータ、ノート、タイムライン情報を一つの理解しやすい場所に視覚化します。タイムラインを使用すると、未来の日時に基づいてコマンドやスクリプトを簡単に実行することができます。    ","version":"次へ","tagName":"h2"},{"title":"タイムラインの追加​","type":1,"pageTitle":"カレンダー (Enterprise)","url":"/ja/docs/tools/calendar#タイムラインの追加","content":" COSMOSにタイムラインを追加するのは、作成 (Create) -&gt; タイムライン (Timeline) をクリックして一意の名前を付けるだけで簡単です。タイムラインは組織化の目的や重複するアクティビティ用に作成できます。特定のタイムライン上ではアクティビティを重複させることはできません。ただし、追加の各タイムラインはいくつかのスレッドで構成されているため、必要に応じてのみタイムラインを作成してください。  ","version":"次へ","tagName":"h3"},{"title":"イベントの種類​","type":1,"pageTitle":"カレンダー (Enterprise)","url":"/ja/docs/tools/calendar#イベントの種類","content":" ","version":"次へ","tagName":"h2"},{"title":"メタデータ​","type":1,"pageTitle":"カレンダー (Enterprise)","url":"/ja/docs/tools/calendar#メタデータ","content":" メタデータを使用すると、任意のデータをCOSMOSシステムに記録できます。例えば、オペレーター、環境要因、手順のステップなど、利用可能なターゲットテレメトリに含まれない入力をユーザーに求めることができます。これにより、これらのフィールドに基づいてメタデータを検索し、関連するテレメトリデータを相関させることができます。  作成メニュー (Create) から、またはカレンダー上でメタデータ項目を表示したい特定の時間枠を右クリックすることで、新しいメタデータ項目を作成できます。メタデータエントリには開始時間のみがあり、終了時間はないことに注意してください。    次に、作成したいすべてのメタデータ項目のキー/値ペアを追加します。    ","version":"次へ","tagName":"h3"},{"title":"ノート​","type":1,"pageTitle":"カレンダー (Enterprise)","url":"/ja/docs/tools/calendar#ノート","content":" ノートには開始時間と終了時間の両方が必要です。    次に、カレンダーにノートイベントを作成するためにノートを記録します。    ","version":"次へ","tagName":"h3"},{"title":"アクティビティ​","type":1,"pageTitle":"カレンダー (Enterprise)","url":"/ja/docs/tools/calendar#アクティビティ","content":" タイムラインにスケジュールされるアクティビティは、開始時間と終了時間の両方を必要とします。    アクティビティは、単一のコマンドを実行したり、スクリプトを実行したり、または単に参照やその他の記録管理のためにカレンダー上の空間を「予約」したりすることができます。    カレンダーアクティビティがスケジュールされると、プラス（+）を含む緑色の円で表示されます。正常に完了すると、アイコンはチェックマーク（✓）を含む緑色の円に変わります。予約アクティビティは単に空の緑色の円を持ちます。    カレンダーイベントはファイル (File)-&gt;テーブルの表示(Show Table Display)を通じてリスト形式でも表示でき、過去および未来のイベントの両方をリストするためのページネーションをサポートしています。    ","version":"次へ","tagName":"h3"},{"title":"タイムラインの実装詳細​","type":1,"pageTitle":"カレンダー (Enterprise)","url":"/ja/docs/tools/calendar#タイムラインの実装詳細","content":" ユーザーがタイムラインを作成すると、新しいタイムラインマイクロサービスが起動します。タイムラインマイクロサービスはタイムラインの主要な実行スレッドです。これによりスケジューラマネージャースレッドが開始されます。スケジューラマネージャースレッドには、アクティビティを実行するための複数のスレッドを持つスレッドプールが含まれています。スケジューラマネージャーはスケジュールを評価し、アクティビティの開始時間に基づいてアクティビティをキューに追加します。  メインスレッドはWebソケットでブロックし、タイムラインへの変更要求をリッスンします。これにはアクティビティの追加、削除、更新などが含まれます。これらの変更が現在の時刻から1時間以内であれば、メインスレッドはメモリ内のスケジュールに変更を加えます。Webソケットが更新を受け取ると、アクションルックアップテーブルが使用されます。これらのアクションは「作成」、「更新」、「削除」などです。一部のアクションでは、スケジュールとデータベースが常に同期されるようにするために、データベースからスケジュールを更新する必要があります。  スケジュールスレッドは1秒ごとにタスクを実行できるかどうかを確認します。開始時間が過去15秒以内であれば、スケジュール内の以前にキューに入れられたジョブリストをチェックします。アクティビティがキューに入れられておらず、実行されていない場合、アクティビティはキューに追加されます。これによりアクティビティにイベントが追加されますが、データベースには保存されません。  ワーカーはアクティビティがキューに配置されるまでキューでブロックします。ジョブがキューから取り出されると、タイプを確認してアクティビティを実行します。スレッドはアクティビティの実行を完了としてマークし、データベースレコードを更新して完了します。ワーカーがタスクの実行中にエラーが発生した場合、アクティビティは実行されず、エラーがデータベースに記録されます。   ","version":"次へ","tagName":"h2"},{"title":"コマンドセンダー","type":0,"sectionRef":"#","url":"/ja/docs/tools/cmd-sender","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"コマンドセンダー","url":"/ja/docs/tools/cmd-sender#はじめに","content":" コマンドセンダーは、COSMOSからあらゆるコマンドを送信する機能です。コマンドは、ターゲットとパケットのドロップダウンフィールドを使用して選択され、コマンドパラメータ（ある場合）が入力されます。コマンド履歴が保存され、編集も可能です。コマンド履歴内のコマンドはEnterキーを押すことで再実行できます。関連するテレメトリまたは画面は、コマンド履歴の隣の右下に表示されます。    ","version":"次へ","tagName":"h2"},{"title":"コマンドセンダーのメニュー​","type":1,"pageTitle":"コマンドセンダー","url":"/ja/docs/tools/cmd-sender#コマンドセンダーのメニュー","content":" ","version":"次へ","tagName":"h2"},{"title":"モードメニュー項目​","type":1,"pageTitle":"コマンドセンダー","url":"/ja/docs/tools/cmd-sender#モードメニュー項目","content":"   パラメータ範囲チェックを無視パラメータ状態値を16進数で表示無視されたパラメータを表示すべてのパラメータ変換を無効化  ","version":"次へ","tagName":"h3"},{"title":"コマンドの送信​","type":1,"pageTitle":"コマンドセンダー","url":"/ja/docs/tools/cmd-sender#コマンドの送信","content":" まず「ターゲットを選択 (Select Target)」ドロップダウンからターゲットを選択してコマンドを選択します。ターゲットを変更すると、「パケットを選択 (Select Packet)」オプションが自動的に更新され、そのターゲットからのコマンドのみが表示されます。コマンドにパラメータがある場合、すべてのパラメータを含むテーブルが生成されます。    状態を持つパラメータ（上記の例ではTYPE）をクリックすると、状態を選択するためのドロップダウンが表示されます。状態を選択すると、その隣の値フィールドに値が入力されます。コマンドを送信すると、ステータステキストとコマンド履歴が更新されます。    コマンド履歴を直接編集してパラメータ値を変更できます。その行でEnterキーを押すと、コマンドが実行されます。コマンドが変更された場合、コマンド履歴に新しい行が入力されます。同じ行でEnterキーを数回押すと、ステータステキストが送信されたコマンドの数（次の例では3）で更新されます。    ","version":"次へ","tagName":"h2"},{"title":"危険なコマンド​","type":1,"pageTitle":"コマンドセンダー","url":"/ja/docs/tools/cmd-sender#危険なコマンド","content":" 危険なコマンドを送信すると、コマンドを送信するかどうかをユーザーに確認するプロンプトが表示されます。    コマンドには危険な状態（INST COLLECT with TYPE SPECIAL）もあり、ユーザーにプロンプトが表示されます。この例では、無視されたパラメータを表示する、状態値を16進数で表示する（SPECIAL、0x1を参照）、範囲チェックを無効にする（DURATION 1000）、パラメータ変換を無効にするなど、すべてのメニューオプションをチェックしています。    「はい (Yes)」を選択すると、コマンドが送信され、表示されているすべてのパラメータで履歴が更新されます。スクリプトを作成する際には、明示的に必須とマークされていない限り、すべてのパラメータはオプションであることに注意してください。 ","version":"次へ","tagName":"h3"},{"title":"コマンド履歴 (Enterprise)","type":0,"sectionRef":"#","url":"/ja/docs/tools/command_history","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"コマンド履歴 (Enterprise)","url":"/ja/docs/tools/command_history#はじめに","content":" コマンド履歴は、COSMOSで送信されたすべてのコマンドを確認する機能を提供します。コマンドは実行時間順にリストされ、誰がコマンドを送信したか、そして（検証された場合）それらが成功したかどうかが含まれます。    ","version":"次へ","tagName":"h2"},{"title":"時間の選択​","type":1,"pageTitle":"コマンド履歴 (Enterprise)","url":"/ja/docs/tools/command_history#時間の選択","content":" デフォルトでは、コマンド履歴は過去1時間のコマンドを表示し、送信されたコマンドを継続的にストリーミングします。開始日時と終了日時の選択ツールを使用して、異なる時間範囲を選択できます。  ","version":"次へ","tagName":"h3"},{"title":"コマンドテーブル​","type":1,"pageTitle":"コマンド履歴 (Enterprise)","url":"/ja/docs/tools/command_history#コマンドテーブル","content":" コマンドテーブルは時間でソートされ、ユーザー（またはプロセス）、コマンド、結果、およびオプションの説明がリストされています。  上記のように、ユーザーはシステム内の実際のユーザー（admin、operator）またはバックグラウンドプロセス（DEFAULT__MULTI__INST、DEFAULT__DECOM__INST2）になります。  結果フィールドは、VALIDATORキーワードによって確立されたコマンドバリデータを実行した結果です。コマンドバリデータは、pre_checkとpost_checkの両方のメソッドでコマンドの成功または失敗を検証するために使用されるRubyまたはPythonクラスです。通常、コマンドが失敗すると、上記の例のように説明が与えられます。  詳細については、VALIDATORのドキュメントを読み、またCOSMOS DemoのRubyの例とPythonの例を参照してください。 ","version":"次へ","tagName":"h2"},{"title":"データエクストラクター","type":0,"sectionRef":"#","url":"/ja/docs/tools/data-extractor","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"データエクストラクター","url":"/ja/docs/tools/data-extractor#はじめに","content":" データエクストラクターは、コマンドとテレメトリ項目をカンマまたはタブ区切りのファイルに抽出します。個別の項目または全パケットを任意の期間にわたって処理できます。データエクストラクターには、例えばExcelやMatlabでの後処理のための出力を制御するための多くのオプションもあります。    ","version":"次へ","tagName":"h2"},{"title":"データエクストラクターのメニュー​","type":1,"pageTitle":"データエクストラクター","url":"/ja/docs/tools/data-extractor#データエクストラクターのメニュー","content":" ","version":"次へ","tagName":"h2"},{"title":"ファイルメニュー項目​","type":1,"pageTitle":"データエクストラクター","url":"/ja/docs/tools/data-extractor#ファイルメニュー項目","content":"   保存された設定を開く現在の設定（項目リスト）を保存設定をリセット（デフォルト設定）出力をカンマで区切る出力をタブで区切る  設定を開く​  設定を開くダイアログでは、保存されたすべての設定のリストが表示されます。設定を選択し、OKをクリックしてロードします。設定名の横にあるゴミ箱アイコンをクリックして、既存の設定を削除できます。  設定を保存​  設定を保存ダイアログでも、保存されたすべての設定のリストが表示されます。設定名テキストフィールドをクリックし、新しい設定の名前を入力し、OKをクリックして保存します。設定名の横にあるゴミ箱アイコンをクリックして、既存の設定を削除できます。  ","version":"次へ","tagName":"h3"},{"title":"モードメニュー項目​","type":1,"pageTitle":"データエクストラクター","url":"/ja/docs/tools/data-extractor#モードメニュー項目","content":"   空のセルを前の値で埋めるヘッダーにMatlabコメント（'%'）を追加変更された値のみを出力列ヘッダーとして項目名のみをリストヘッダーとして完全なターゲットパケット項目をリスト  ","version":"次へ","tagName":"h3"},{"title":"出力する項目の選択​","type":1,"pageTitle":"データエクストラクター","url":"/ja/docs/tools/data-extractor#出力する項目の選択","content":" ","version":"次へ","tagName":"h2"},{"title":"開始/終了日時​","type":1,"pageTitle":"データエクストラクター","url":"/ja/docs/tools/data-extractor#開始終了日時","content":" データエクストラクターには、項目を抽出する時間範囲を指定するテキストフィールドが用意されています。開始日と終了日のテキストフィールドをクリックすると、日付選択ダイアログが開きます。日付を手動で入力することもできます。開始時間と終了時間のアイコンをクリックすると、時間選択ダイアログが開きます。時間を手動で入力することもできます。  ","version":"次へ","tagName":"h3"},{"title":"ターゲット/パケット/項目の追加​","type":1,"pageTitle":"データエクストラクター","url":"/ja/docs/tools/data-extractor#ターゲットパケット項目の追加","content":" データエクストラクターには、エクスポートしたい項目を選択するためのターゲット、パケット、項目のドロップダウンが用意されています。ターゲットを選択すると、パケットのドロップダウンはデフォルトで[All]に設定され、ボタンは「ターゲットを追加 (Add Target)」に変わります。これにより、ターゲット内で定義されたすべてのパケットのすべての項目が追加されます。注意：これは非常に多くのテレメトリポイントになる可能性がありますが、追加されたポイントはいずれも削除できます。    パケットを選択すると、項目のドロップダウンはデフォルトで[All]に設定され、ボタンは「パケットを追加 (Add Packet)」に変わります。これにより、指定されたパケットで定義されたすべての項目が追加されます。注意：これは非常に多くのテレメトリポイントになる可能性がありますが、追加されたポイントはいずれも削除できます。    個別の項目を選択すると、ボタンは「項目を追加 (Add Item)」に変わり、説明フィールドはその項目の説明で更新されます。    ","version":"次へ","tagName":"h3"},{"title":"項目の削除​","type":1,"pageTitle":"データエクストラクター","url":"/ja/docs/tools/data-extractor#項目の削除","content":" 項目を追加すると、項目テーブルに項目のリストが表示されます。項目は、項目の横にあるゴミ箱アイコンをクリックして削除できます。ヘッダーのゴミ箱アイコンをクリックすると、すべての項目を削除できます。    ","version":"次へ","tagName":"h3"},{"title":"項目の編集​","type":1,"pageTitle":"データエクストラクター","url":"/ja/docs/tools/data-extractor#項目の編集","content":" 項目は、項目の横にある鉛筆アイコンをクリックして編集できます。ヘッダーの鉛筆アイコンをクリックすると、すべての項目を編集できます。    「すべて編集 (Edit All Items)」をクリックすると、すべての項目を編集ダイアログが表示されます。    これにより、リスト内のすべての項目のデータ型を変更できます。個々の項目の横にある鉛筆をクリックすると、個々の項目を編集するための同様のダイアログが表示されます。    ","version":"次へ","tagName":"h3"},{"title":"項目の処理​","type":1,"pageTitle":"データエクストラクター","url":"/ja/docs/tools/data-extractor#項目の処理","content":" 「処理 (Process)」ボタンをクリックすると、項目リストの処理が開始されます。テーブルの左側に進行状況を示す車輪が表示され、「処理 (Process)」ボタンは「キャンセル (Cancel)」に変わり、処理をキャンセルできるようになります。    処理が完了すると、ブラウザにファイルのダウンロードリンクが表示されます。これはブラウザによって異なることに注意してください。この例はChromeからのものです。   ","version":"次へ","tagName":"h2"},{"title":"スクリーン","type":0,"sectionRef":"#","url":"/ja/docs/configuration/telemetry-screens","content":"","keywords":"","version":"次へ"},{"title":"定義​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#定義","content":" 名前\t定義ウィジェット\tウィジェットは、COSMOS テレメトリ画面上のグラフィック要素です。テキストの表示、データのグラフ化、ボタンの提供、またはその他の表示/ユーザー入力タスクを実行することができます。 スクリーン\tスクリーンは、有用な方法で整理・配置された任意の数のウィジェットを含む単一のウィンドウです。 スクリーン定義ファイル\tスクリーン定義ファイルは、テレメトリビューアにスクリーンの描画方法を指示するASCIIファイルです。画面に表示されるテレメトリポイントとその表示方法を定義するキーワード/パラメータ行のシリーズで構成されています。  ","version":"次へ","tagName":"h2"},{"title":"テレメトリスクリーン定義ファイル​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#テレメトリスクリーン定義ファイル","content":" テレメトリスクリーン定義ファイルは、テレメトリスクリーンの内容を定義します。SCREENキーワードに続いて、テレメトリスクリーンを定義する一連のウィジェットキーワードという一般的な形式を取ります。特定のターゲットに固有のスクリーン定義ファイルは、そのターゲットのscreensディレクトリに格納されます。例：TARGET/screens/version.txt。スクリーン定義ファイルは小文字でなければなりません。  ","version":"次へ","tagName":"h2"},{"title":"新しいウィジェット​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#新しいウィジェット","content":" テレメトリスクリーン定義が解析され、認識されないキーワードに遭遇した場合、widgetname_widget.rbという形式のファイルが存在し、WidgetnameWidgetと呼ばれるクラスが含まれていると仮定されます。この規則のおかげで、テレメトリスクリーン定義フォーマットを変更することなく、新しいウィジェットをシステムに追加することができます。カスタムウィジェットの作成に関する詳細については、カスタムウィジェットガイドをお読みください。  スクリーンキーワード  ","version":"次へ","tagName":"h2"},{"title":"SCREEN​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#screen","content":" テレメトリビューアスクリーンを定義する  SCREENキーワードは、すべてのテレメトリスクリーン定義の最初のキーワードです。スクリーンの名前と、スクリーン全体に影響するパラメータを定義します。  パラメータ\t説明\t必須幅\tピクセル単位の幅、またはAUTOを指定してテレメトリビューアに自動的に画面レイアウトを行わせる\tTrue 高さ\tピクセル単位の高さ、またはAUTOを指定してテレメトリビューアに自動的に画面レイアウトを行わせる\tTrue ポーリング周期\t画面更新間の秒数\tTrue  使用例：  SCREEN AUTO AUTO 1.0 FIXED   ","version":"次へ","tagName":"h2"},{"title":"END​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#end","content":" レイアウトウィジェットの終了を示す  すべてのレイアウトウィジェットは、その停止位置を正しく識別するために、終了キーワードで閉じる必要があります。例えば、VERTICALBOXキーワードは、VERTICALBOXの終了位置を示すためにENDキーワードと一致しなければなりません。  ","version":"次へ","tagName":"h2"},{"title":"STALE_TIME​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#stale_time","content":"  (5.1.0以降) パケット時間が過去のStale Time秒以上である場合、値は古いとマークされる   パラメータ\t説明\t必須value\tRECEIVED_TIMESECONDSが過去のこの値より大きいパケットからのアイテムは古いとマークされます。デフォルトは30秒です。競合状態による誤検出を避けるため、最低でも2秒を推奨します。\tTrue  使用例：  STALE_TIME 5 # データを古いとマークするまでの待機秒数   ","version":"次へ","tagName":"h2"},{"title":"GLOBAL_SETTING​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#global_setting","content":" 特定タイプのすべてのウィジェットにウィジェット設定を適用する  パラメータ\t説明\t必須ウィジェットクラス名\tこの設定が適用されるウィジェットのクラスの名前。例えば、LABELやBUTTONなど。\tTrue 設定名\t詳細はSETTINGを参照してください。\tTrue 設定値\t詳細はSETTINGを参照してください。\tFalse  使用例：  GLOBAL_SETTING LABELVALUELIMITSBAR TEXTCOLOR BLACK   ","version":"次へ","tagName":"h2"},{"title":"GLOBAL_SUBSETTING​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#global_subsetting","content":" 特定のタイプのすべてのウィジェットにウィジェットのサブ設定を適用する  サブ設定は、複数のサブウィジェットで構成されるウィジェットにのみ有効です。例えば、LABELVALUEは、サブウィジェットインデックス0のLABELとサブウィジェットインデックス1のVALUEで構成されています。これにより、特定のサブウィジェットに設定を渡すことができます。LABELVALUELIMITSBARなど、一部のウィジェットは複数のサブウィジェットで構成されています。Labelウィジェットを設定するには、サブウィジェットインデックスとして0を、Valueウィジェットには1を、LimitsBarウィジェットには2を渡します。  パラメータ\t説明\t必須ウィジェットクラス名\tこの設定が適用されるウィジェットのクラスの名前。例えば、LABELVALUEなど。\tTrue サブウィジェットインデックス\t目的のサブウィジェットへのインデックス\tTrue 設定名\t詳細はSETTINGを参照してください。\tTrue 設定値\t詳細はSETTINGを参照してください。\tFalse  使用例：  # labelvaluelimitsbarsのすべてのテキスト色を白に設定 GLOBAL_SUBSETTING LABELVALUELIMITSBAR 0 TEXTCOLOR white   ","version":"次へ","tagName":"h2"},{"title":"SETTING​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#setting","content":" 直前に定義されたウィジェットにウィジェット設定を適用する  設定により、パラメータでは利用できない追加の調整やオプションをウィジェットに 適用することができます。これらの設定はすべて、SETTING、SUBSETTING、GLOBAL_SETTING、 およびGLOBAL_SUBSETTINGキーワードを通じて構成されます。 SETTINGとSUBSETTINGは、直前に定義されたウィジェットにのみ適用されます。 GLOBAL_SETTINGとGLOBAL_SUBSETTINGはすべてのウィジェットに適用されます。  一般的なウィジェット設定はここで定義されています。一部のウィジェットは独自の 固有の設定を定義しており、それらは特定のウィジェットの下にドキュメント化されています。  ","version":"次へ","tagName":"h2"},{"title":"WIDTH​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#width","content":" ウィジェットの幅を設定する  WIDTHはcssユニットをサポートしており、デフォルト（単位なし）はpx（ピクセル）です  パラメータ\t説明\t必須Width\tピクセル単位の幅、または明示的に単位を宣言\tTrue  使用例：  LABEL &quot;THIS IS A TEST&quot; SETTING WIDTH 50 LABEL &quot;THIS IS A TEST&quot; SETTING WIDTH 20em     ","version":"次へ","tagName":"h3"},{"title":"HEIGHT​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#height","content":" ウィジェットの高さを設定する  HEIGHTはcssユニットをサポートしており、デフォルト（単位なし）はpx（ピクセル）です  パラメータ\t説明\t必須Height\tピクセル単位の高さ、または明示的に単位を宣言\tTrue  使用例：  LABEL &quot;THIS IS A TEST&quot; SETTING BACKCOLOR BLUE SETTING HEIGHT 50 LABEL &quot;THIS IS A TEST&quot; SETTING BACKCOLOR GREY SETTING HEIGHT 2em     ","version":"次へ","tagName":"h3"},{"title":"MARGIN​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#margin","content":" ウィジェットのマージンを設定する  MARGINはcssユニットをサポートしており、デフォルト（単位なし）はpx（ピクセル）です  パラメータ\t説明\t必須Size\tピクセル単位のサイズ、または明示的に単位を宣言\tTrue  使用例：  LABEL &quot;THIS IS A TEST&quot; SETTING BACKCOLOR BLUE LABEL &quot;THIS IS A TEST&quot; SETTING BACKCOLOR GREY SETTING MARGIN 10 LABEL &quot;THIS IS A TEST&quot; SETTING BACKCOLOR GREEN     ","version":"次へ","tagName":"h3"},{"title":"PADDING​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#padding","content":" ウィジェットのパディングを設定する  PADDINGはcssユニットをサポートしており、デフォルト（単位なし）はpx（ピクセル）です  パラメータ\t説明\t必須Size\tピクセル単位のサイズ、または明示的に単位を宣言\tTrue  使用例：  LABEL &quot;THIS IS A TEST&quot; SETTING BACKCOLOR BLUE LABEL &quot;THIS IS A TEST&quot; SETTING BACKCOLOR GREY SETTING PADDING 10 LABEL &quot;THIS IS A TEST&quot; SETTING BACKCOLOR GREEN     ","version":"次へ","tagName":"h3"},{"title":"BACKCOLOR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#backcolor","content":" BACKCOLOR設定はウィジェットの背景色を設定します  パラメータ\t説明\t必須色名または赤の値\t色の一般的な名前（例：'black'、'red'など）。または、さらに2つのパラメータが渡された場合、これはRGB値の赤の値です\tTrue 緑の値\tRGB値の緑の値\tFalse 青の値\tRGB値の青の値\tFalse  使用例：  LABEL &quot;THIS IS A TEST&quot; SETTING BACKCOLOR red LABEL &quot;THIS IS A TEST&quot; SETTING BACKCOLOR 155 50 155     ","version":"次へ","tagName":"h3"},{"title":"TEXTCOLOR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#textcolor","content":" TEXTCOLOR設定はウィジェットのテキスト色を設定します  パラメータ\t説明\t必須色名または赤の値\t色の一般的な名前（例：'black'、'red'など）。または、さらに2つのパラメータが渡された場合、これはRGB値の赤の値です\tTrue 緑の値\tRGB値の緑の値\tFalse 青の値\tRGB値の青の値\tFalse  使用例：  LABEL &quot;THIS IS A TEST&quot; SETTING TEXTCOLOR red LABEL &quot;THIS IS A TEST&quot; SETTING TEXTCOLOR 155 50 155     ","version":"次へ","tagName":"h3"},{"title":"BORDERCOLOR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#bordercolor","content":" BORDERCOLOR設定はレイアウトウィジェットの枠線の色を設定します  パラメータ\t説明\t必須色名または赤の値\t色の一般的な名前（例：'black'、'red'など）。または、さらに2つのパラメータが渡された場合、これはRGB値の赤の値です\tTrue 緑の値\tRGB値の緑の値\tFalse 青の値\tRGB値の青の値\tFalse  使用例：  HORIZONTAL LABEL &quot;Label 1&quot; END SETTING BORDERCOLOR red VERTICAL LABEL &quot;Label 2&quot; END SETTING BORDERCOLOR 155 50 155     ","version":"次へ","tagName":"h3"},{"title":"RAW​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#raw","content":" 生のCSSスタイルシートのキーと値を適用する  パラメータ\t説明\t必須Key\tfont-size、max-widthなどのCSSキー\tTrue Value\tCSS値\tTrue  使用例：  LABEL &quot;Label 1&quot; SETTING RAW font-size 30px     ","version":"次へ","tagName":"h3"},{"title":"SUBSETTING​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#subsetting","content":" 直前に定義されたウィジェットにウィジェットのサブ設定を適用する  サブ設定は、複数のサブウィジェットで構成されるウィジェットにのみ有効です。例えば、LABELVALUEは、サブウィジェットインデックス0のLABELとサブウィジェットインデックス1のVALUEで構成されています。これにより、特定のサブウィジェットに設定を渡すことができます。LABELVALUELIMITSBARなど、一部のウィジェットは複数のサブウィジェットで構成されています。Labelウィジェットを設定するには、サブウィジェットインデックスとして0を、Valueウィジェットには1を、LimitsBarウィジェットには2を渡します。  パラメータ\t説明\t必須サブウィジェットインデックス\t目的のサブウィジェットへのインデックス、または'ALL'を指定してこの複合ウィジェットのすべてのサブウィジェットに設定を適用します。\tTrue 設定名\t詳細はSETTINGを参照してください。\tTrue 設定値\t詳細はSETTINGを参照してください。\tFalse  使用例：  VERTICALBOX LABELVALUE INST HEALTH_STATUS TEMP1 SUBSETTING 0 TEXTCOLOR blue # ラベルのテキストを青に変更 LABELVALUELIMITSBAR INST HEALTH_STATUS TEMP1 SUBSETTING 0 TEXTCOLOR green # ラベルのテキストを緑に変更 END     ","version":"次へ","tagName":"h2"},{"title":"NAMED_WIDGET​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#named_widget","content":" ウィジェットに名前を付けて、getNamedWidgetメソッドを通じてアクセスできるようにする  テレメトリ画面の一部にプログラムでアクセスするには、ウィジェットに名前を付ける必要があります。これは、他のウィジェットから値を読み取るボタンを持つ画面を作成する際に便利です。  警告 getNamedWidgetはウィジェット自体を返すため、そのウィジェット固有のメソッドを使用して操作する必要があります  パラメータ\t説明\t必須ウィジェット名\t次のウィジェットインスタンスに適用される一意の名前。名前は画面ごとに一意でなければなりません。\tTrue ウィジェットタイプ\tウィジェットの説明に記載されているウィジェットタイプのいずれか\tTrue ウィジェットパラメータ\t指定されたウィジェットタイプの固有パラメータ\tTrue  使用例：  NAMED_WIDGET DURATION TEXTFIELD BUTTON &quot;Push&quot; &quot;screen.getNamedWidget('DURATION').text()&quot;     ","version":"次へ","tagName":"h2"},{"title":"レイアウトウィジェット​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#レイアウトウィジェット","content":"   レイアウトウィジェットは、他のウィジェットを画面上に配置するために使用されます。例えば、HORIZONTALレイアウトウィジェットは、それがカプセル化するウィジェットを画面上に水平に配置します。  ","version":"次へ","tagName":"h2"},{"title":"VERTICAL​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#vertical","content":" カプセル化したウィジェットを垂直に配置する  画面はデフォルトで垂直レイアウトになっているため、レイアウトウィジェットが指定されていない場合、すべてのウィジェットは自動的にVERTICALレイアウトウィジェット内に配置されます。VERTICALウィジェットは、その内容に合わせてサイズが調整されます。  パラメータ\t説明\t必須マージン\tウィジェット間のマージン（デフォルト = 0px）\tFalse  使用例：  VERTICAL 5px LABEL &quot;TEST&quot; LABEL &quot;SCREEN&quot; END     ","version":"次へ","tagName":"h3"},{"title":"VERTICALBOX​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#verticalbox","content":" カプセル化したウィジェットを薄い境界線の中に垂直に配置する  VERTICALBOXウィジェットは、その内容に合わせて垂直方向にサイズ調整し、画面に合わせて水平方向にサイズ調整します  パラメータ\t説明\t必須タイトル\tボックスにラベルを付けるために境界内に配置するテキスト\tFalse マージン\tウィジェット間のマージン（デフォルト = 0px）\tFalse  使用例：  VERTICALBOX Info SUBSETTING 1 RAW border &quot;1px dashed green&quot; LABEL &quot;TEST&quot; LABEL &quot;SCREEN&quot; END     ","version":"次へ","tagName":"h3"},{"title":"HORIZONTAL​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#horizontal","content":" カプセル化したウィジェットを水平に配置する  HORIZONTALウィジェットは、その内容に合わせてサイズ調整します  パラメータ\t説明\t必須マージン\tウィジェット間のマージン（デフォルト = 0px）\tFalse  使用例：  HORIZONTAL 100 LABEL &quot;TEST&quot; LABEL &quot;SCREEN&quot; END     ","version":"次へ","tagName":"h3"},{"title":"HORIZONTALBOX​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#horizontalbox","content":" カプセル化したウィジェットを薄い境界線の中に水平に配置する  HORIZONTALBOXウィジェットは、その内容に合わせてサイズ調整します  パラメータ\t説明\t必須タイトル\tボックスにラベルを付けるために境界内に配置するテキスト\tFalse マージン\tウィジェット間のマージン（デフォルト = 0px）\tFalse  使用例：  HORIZONTALBOX Info 10 SUBSETTING 0 RAW text-align CENTER SUBSETTING 1 RAW border &quot;1px solid blue&quot; LABEL &quot;TEST&quot; LABEL &quot;SCREEN&quot; END     ","version":"次へ","tagName":"h3"},{"title":"MATRIXBYCOLUMNS​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#matrixbycolumns","content":" ウィジェットをテーブルのようなマトリックスに配置する  MATRIXBYCOLUMNSウィジェットは、その内容に合わせてサイズ調整します  パラメータ\t説明\t必須列\t作成する列の数\tTrue マージン\tウィジェット間のマージン（デフォルト = 0px）\tFalse  使用例：  MATRIXBYCOLUMNS 3 10 LABEL &quot;COL 1&quot; LABEL &quot;COL 2&quot; LABEL &quot;COL 3&quot; LABEL &quot;100&quot; LABEL &quot;200&quot; LABEL &quot;300&quot; END     ","version":"次へ","tagName":"h3"},{"title":"SCROLLWINDOW​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#scrollwindow","content":" 内部のウィジェットをスクロール可能なエリアに配置する  SCROLLWINDOWウィジェットは、それが含まれる画面に合わせてサイズ調整します  パラメータ\t説明\t必須高さ\tスクロールウィンドウの最大高さ（ピクセル単位、デフォルト = 200）\tFalse マージン\tウィジェット間のマージン（デフォルト = 0px）\tFalse  使用例：  SCROLLWINDOW 100 10 VERTICAL LABEL &quot;100&quot; LABEL &quot;200&quot; LABEL &quot;300&quot; LABEL &quot;400&quot; LABEL &quot;500&quot; LABEL &quot;600&quot; LABEL &quot;700&quot; LABEL &quot;800&quot; LABEL &quot;900&quot; END END     ","version":"次へ","tagName":"h3"},{"title":"TABBOOK​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#tabbook","content":" TABITEMウィジェットを配置するためのタブ付きエリアを作成する  ","version":"次へ","tagName":"h3"},{"title":"TABITEM​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#tabitem","content":" ウィジェットを配置するためのVERTICALレイアウトタブを作成する  パラメータ\t説明\t必須タブテキスト\tタブに表示するテキスト\tTrue  使用例：  TABBOOK TABITEM &quot;Tab 1&quot; LABEL &quot;100&quot; LABEL &quot;200&quot; END TABITEM &quot;Tab 2&quot; LABEL &quot;300&quot; LABEL &quot;400&quot; END END     ","version":"次へ","tagName":"h3"},{"title":"IFRAME​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#iframe","content":" OpenC3内のIframe内で外部ツールを開く  パラメータ\t説明\t必須URL\tiframe内に表示するページのパス\tTrue 幅\tウィジェットの幅\tFalse 高さ\tウィジェットの高さ\tFalse  使用例：  IFRAME https://openc3.com 900 450     ","version":"次へ","tagName":"h3"},{"title":"装飾ウィジェット​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#装飾ウィジェット","content":"   装飾ウィジェットは、画面の外観を向上させるために使用されます。これらは入力に応答せず、出力もテレメトリによって変化しません。  ","version":"次へ","tagName":"h2"},{"title":"LABEL​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#label","content":" 画面上にテキストを表示する  一般に、ラベルウィジェットにはテレメトリニーモニックが含まれ、テレメトリVALUEウィジェットの隣に配置されます。  パラメータ\t説明\t必須テキスト\tラベルに表示するテキスト\tTrue  使用例：  LABEL &quot;注意：これは警告のみです&quot;     ","version":"次へ","tagName":"h3"},{"title":"HORIZONTALLINE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#horizontalline","content":"  (5.5.1以降) 区切り線として使える水平線を画面上に表示する   使用例：  LABEL Over HORIZONTALLINE LABEL Under     ","version":"次へ","tagName":"h3"},{"title":"TITLE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#title","content":" 画面上に大きな中央揃えのタイトルを表示する  パラメータ\t説明\t必須テキスト\t表示するテキスト\tTrue  使用例：  TITLE &quot;タイトル&quot; HORIZONTALLINE LABEL &quot;ラベル&quot;     ","version":"次へ","tagName":"h3"},{"title":"SPACER​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#spacer","content":" ウィジェット間に固定サイズのスペーサーを配置する  パラメータ\t説明\t必須幅\tスペーサーの幅（ピクセル単位）\tTrue 高さ\tスペーサーの高さ（ピクセル単位）\tTrue  使用例：  VERTICAL 3 LABEL &quot;スペーサー下部&quot; SPACER 0 100 LABEL &quot;スペーサー上部&quot; END     ","version":"次へ","tagName":"h3"},{"title":"テレメトリウィジェット​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#テレメトリウィジェット","content":"   テレメトリウィジェットは、テレメトリ値を表示するために使用されます。これらのウィジェットの最初のパラメータはテレメトリニーモニックです。テレメトリ項目の種類と目的に応じて、画面設計者は最も有用な形式で値を表示するために、幅広いウィジェットから選択することができます。  ","version":"次へ","tagName":"h2"},{"title":"ARRAY​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#array","content":" 行に整理され、スペースで区切られた配列データを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 幅\tウィジェットの幅（デフォルト = 200）\tFalse 高さ\tウィジェットの高さ（デフォルト = 100）\tFalse フォーマット文字列\t各配列アイテムに適用されるフォーマット文字列（デフォルト = nil）\tFalse 行あたりのアイテム数\t1行あたりの配列アイテム数（デフォルト = 4）\tFalse 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse  使用例：  ARRAY INST HEALTH_STATUS ARY 250 80 &quot;0x%x&quot; 6 FORMATTED ARRAY INST HEALTH_STATUS ARY2 200 100 nil 4 WITH_UNITS     ","version":"次へ","tagName":"h3"},{"title":"ARRAYPLOT​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#arrayplot","content":" 配列の値をプロットする  アイテムは単純な配列またはx値とy値の2D配列（例：[[x1, x2, x3], [y1, y2, y3]]）のいずれかです。X_AXIS設定が指定されていない場合、X軸は0から始まり1ずつ増加します。X_AXIS設定が使用されている場合、2D配列のx値は無視されます。  使用例：  ARRAYPLOT SETTING TITLE &quot;配列データ&quot; SETTING ITEM INST HEALTH_STATUS ARY SETTING ITEM INST HEALTH_STATUS ARY2 SETTING SIZE 600 400 SETTING X_AXIS 10 10     以下の設定はARRAYPLOTに適用されます。これらはSETTINGキーワードを使用して適用されます。  TITLE​  プロットのタイトル  パラメータ\t説明\t必須タイトル\tプロットのタイトル\tTrue  X_AXIS​  プロットのx軸パラメータを定義する  パラメータ\t説明\t必須開始値\tx軸の開始値\tTrue ステップ値\tx軸のステップ値\tTrue  ITEM​  グラフにテレメトリアイテムを追加する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED\tFalse 縮小\t縮小データを表示するかどうか。デフォルトはDECOM。 有効な値: DECOM, REDUCED_MINUTE, REDUCED_HOUR, REDUCED_DAY\tFalse 縮小タイプ\t表示する縮小データのタイプ。縮小がDECOMでない場合にのみ適用されます。 有効な値: MIN, MAX, AVG, STDDEV\tFalse  STARTTIME​   (5.5.1以降) 指定された時間からグラフ履歴を開始する   パラメータ\t説明\t必須開始時間\t'YYYY/MM/DD HH:MM:SS'形式の開始時間\tTrue  HISTORY​   (5.5.1以降) データの初期履歴を表示する   パラメータ\t説明\t必須値\t値(d,h,m,s)。例えば1d、2h、30m、15s\tTrue  SECONDSGRAPHED​  グラフに指定された秒数を表示する  パラメータ\t説明\t必須時間\t表示する秒数\tTrue  POINTSSAVED​  グラフメモリに秒数を保存する  パラメータ\t説明\t必須時間\t保存する秒数\tTrue  POINTSGRAPHED​  グラフに表示するポイント数  パラメータ\t説明\t必須時間\tグラフ化するポイント数\tTrue  SIZE​  グラフのサイズ  パラメータ\t説明\t必須幅\tピクセル単位の幅\tTrue 高さ\tピクセル単位の高さ\tTrue  ","version":"次へ","tagName":"h3"},{"title":"BLOCK​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#block","content":" 行に整理され、スペースで区切られたBLOCKデータを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 幅\tウィジェットの幅（デフォルト = 200）\tFalse 高さ\tウィジェットの高さ（デフォルト = 100）\tFalse フォーマット文字列\t各配列アイテムに適用されるフォーマット文字列（デフォルト = nil）\tFalse ワードあたりのバイト数\t1ワードあたりのバイト数（デフォルト = 4）\tFalse 行あたりのワード数\t1行あたりのワード数（デフォルト = 4）\tFalse アドレスフォーマット\t各行の先頭に印刷されるアドレスのフォーマット（デフォルト = nil、アドレスを印刷しないことを意味します）\tFalse 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse  使用例：  BLOCK INST IMAGE IMAGE 620 200 &quot;%02X&quot; 4 4 &quot;0x%08X:&quot;     ","version":"次へ","tagName":"h3"},{"title":"FORMATVALUE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#formatvalue","content":" フォーマットされた値を持つボックスを表示する  データは、テレメトリ定義ファイルで指定されたフォーマット文字列ではなく、指定された文字列によってフォーマットされます。値が停滞している間、ボックスの白い部分は灰色に暗くなり、値が変更されるたびに白く明るくなります。さらに、値はアイテムの制限状態に基づいて色付けされます（例えば、制限を超えている場合は赤色）。  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue フォーマット文字列\tテレメトリ項目に適用するPrintf形式のフォーマット文字列\tFalse 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 文字数\t値ボックスの幅とする文字数（デフォルト = 12）\tFalse  使用例：  FORMATVALUE INST LATEST TIMESEC %012u CONVERTED 20 FORMATVALUE INST LATEST TEMP1 %.2f CONVERTED 20     ","version":"次へ","tagName":"h3"},{"title":"LABELLED​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#labelled","content":" LABELの後にLEDを表示する  詳細についてはLEDウィジェットを参照してください  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 幅\tLED円の幅（デフォルト = 15）\tFalse 高さ\tLED円の高さ（デフォルト = 15）\tFalse 揃え方\tラベルとLEDを一緒に揃える方法。デフォルトの「SPLIT」はラベルを左に、LEDを右に揃え、追加のスペースをその間に配置します。「CENTER」はラベルとLEDを一緒に押し、追加のスペースは左右に配置します。「LEFT」または「RIGHT」はそれぞれの側に押し、スペースは反対側に配置します。 有効な値: SPLIT, CENTER, LEFT, RIGHT\tFalse  使用例：  LABELLED INST PARAMS VALUE1 SETTING LED_COLOR GOOD GREEN SETTING LED_COLOR BAD RED     以下の設定はLABELLEDに適用されます。これらはSETTINGキーワードを使用して適用されます。  LED_COLOR​  状態または値を色にマッピングする  パラメータ\t説明\t必須値\t状態または値。ANYは宣言されていない任意の値または状態に一致するために使用されます。\tTrue LED色\tLEDの色\tTrue  ","version":"次へ","tagName":"h3"},{"title":"LABELPROGRESSBAR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#labelprogressbar","content":" アイテム名の後にPROGRESSBARが続くLABELを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue スケールファクター\tプログレスバーに表示する前にテレメトリ項目に掛ける値。最終値は0から100の範囲内であるべきです。デフォルトは1.0です。\tFalse 幅\tプログレスバーの幅（デフォルト = 80ピクセル）\tFalse 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse  使用例：  LABELPROGRESSBAR INST ADCS POSPROGRESS 2 200 RAW LABELPROGRESSBAR INST ADCS POSPROGRESS     ","version":"次へ","tagName":"h3"},{"title":"LABELVALUE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#labelvalue","content":" アイテム名の後にVALUEが続くLABELを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 文字数\t値ボックスの幅とする文字数（デフォルト = 12）\tFalse  使用例：  LABELVALUE INST LATEST TIMESEC CONVERTED 18 LABELVALUE INST LATEST COLLECT_TYPE     ","version":"次へ","tagName":"h3"},{"title":"LABELVALUEDESC​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#labelvaluedesc","content":" アイテムの説明の後にVALUEが続くLABELを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 説明\tラベルに表示する説明（デフォルトはテレメトリ項目に関連付けられた説明テキストを表示）\tFalse 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 文字数\t値ボックスの幅とする文字数（デフォルト = 12）\tFalse  使用例：  LABELVALUEDESC INST HEALTH_STATUS TEMP1 &quot;温度番号1&quot; RAW 18 LABELVALUEDESC INST HEALTH_STATUS COLLECT_TYPE     ","version":"次へ","tagName":"h3"},{"title":"LABELVALUELIMITSBAR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#labelvaluelimitsbar","content":" アイテム名の後にVALUEとLIMITSBARウィジェットが続くLABELを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 文字数\t値ボックスの幅とする文字数（デフォルト = 12）\tFalse  ","version":"次へ","tagName":"h3"},{"title":"LABELVALUELIMITSCOLUMN​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#labelvaluelimitscolumn","content":" アイテム名の後にVALUEとLIMITSCOLUMNウィジェットが続くLABELを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 文字数\t値ボックスの幅とする文字数（デフォルト = 12）\tFalse  使用例：  LABELVALUELIMITSCOLUMN INST HEALTH_STATUS TEMP1 CONVERTED 18 LABELVALUELIMITSCOLUMN INST HEALTH_STATUS TEMP1     ","version":"次へ","tagName":"h3"},{"title":"LABELVALUERANGEBAR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#labelvaluerangebar","content":" アイテム名の後にVALUEとRANGEBARウィジェットが続くLABELを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 最小値\tレンジバーに表示する最小値.\tTrue 最大値\tレンジバーに表示する最大値.\tTrue 値タイプ\t表示する値のタイプ. デフォルトは CONVERTED. 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 文字数\t値ボックスの幅とする文字数 (デフォルト = 12)\tFalse 幅\tレンジバーの幅 (デフォルト = 160)\tFalse 高さ\tレンジバーの高さ (デフォルト = 25)\tFalse  使用例:  LABELVALUERANGEBAR INST HEALTH_STATUS TEMP1 0 100000 RAW 18 200 40 LABELVALUERANGEBAR INST HEALTH_STATUS TEMP1 -120 120     ","version":"次へ","tagName":"h3"},{"title":"LED​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#led","content":" テレメトリ値に基づいて色が変わるLEDを表示する  デフォルトでは、TRUEは緑色、FALSEは赤色、その他の値はすべて黒色です。LED_COLOR設定を使用して追加の値を追加できます。例えば、LED INST PARAMS VALUE3 RAWの後に、SETTING LED_COLOR 0 GREEN、SETTING LED_COLOR 1 RED、およびSETTING LED_COLOR ANY ORANGEを続けることができます。項目の制限色を示す円を表示するウィジェットについては、LIMITSCOLORを参照してください。  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 幅\tLED円の幅（デフォルト = 15）\tFalse 高さ\tLED円の高さ（デフォルト = 15）\tFalse  使用例：  LED INST PARAMS VALUE5 RAW 25 20 # 楕円 SETTING LED_COLOR 0 GREEN SETTING LED_COLOR 1 RED SETTING LED_COLOR ANY YELLOW     以下の設定はLEDに適用されます。これらはSETTINGキーワードを使用して適用されます。  LED_COLOR​  状態または値を色にマッピングする  パラメータ\t説明\t必須値\t状態または値。ANYは宣言されていない任意の値または状態に一致するために使用されます。\tTrue LED色\tLEDの色\tTrue  ","version":"次へ","tagName":"h3"},{"title":"LIMITSBAR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#limitsbar","content":" アイテムの現在の値を色付けされた制限内に水平に表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 幅\tレンジバーの幅（デフォルト = 160）\tFalse 高さ\tレンジバーの高さ（デフォルト = 25）\tFalse  Example Usage:  LIMITSBAR INST HEALTH_STATUS TEMP1 CONVERTED 200 50 LIMITSBAR INST HEALTH_STATUS TEMP1     ","version":"次へ","tagName":"h3"},{"title":"LIMITSCOLUMN​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#limitscolumn","content":" アイテムの現在の値を色付けされた制限内に垂直に表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 幅\tレンジバーの幅（デフォルト = 160）\tFalse 高さ\tレンジバーの高さ（デフォルト = 25）\tFalse  使用例:  LIMITSCOLUMN INST HEALTH_STATUS TEMP1 CONVERTED 50 200 LIMITSCOLUMN INST HEALTH_STATUS TEMP1     ","version":"次へ","tagName":"h3"},{"title":"LIMITSCOLOR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#limitscolor","content":" アイテムの制限色を示す円を表示する。テレメトリ値に基づいて任意の色に変化する円を表示するウィジェットについては、LEDを参照してください。  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 半径\t円の半径（デフォルトは10）\tFalse アイテム名表示\t完全なアイテム名を表示（例：TGT PKT ITEM）(true)、アイテム名なし（nil または none）、またはアイテム名のみ（false）。デフォルトはfalse。\tFalse  使用例:  HORIZONTAL LIMITSCOLOR INST HEALTH_STATUS TEMP1 CONVERTED 10 NIL # ラベルなし LABEL '1st Temp' END LIMITSCOLOR INST HEALTH_STATUS TEMP2 # デフォルトはアイテム名のみのラベル LIMITSCOLOR INST HEALTH_STATUS TEMP3 CONVERTED 20 TRUE # 完全なTGT/PKT/ITEMラベル     ","version":"次へ","tagName":"h3"},{"title":"VALUELIMITSBAR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#valuelimitsbar","content":" アイテムの値に続いてLIMITSBARを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 文字数\t値ボックスの幅（文字数）（デフォルト = 12）\tFalse  使用例:  VALUELIMITSBAR INST HEALTH_STATUS TEMP1 CONVERTED 18 VALUELIMITSBAR INST HEALTH_STATUS TEMP1     ","version":"次へ","tagName":"h3"},{"title":"VALUELIMITSCOLUMN​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#valuelimitscolumn","content":" アイテムの値に続いてLIMITSCOLUMNを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 文字数\t値ボックスの幅（文字数）（デフォルト = 8）\tFalse  使用例:  VALUELIMITSCOLUMN INST HEALTH_STATUS TEMP1 CONVERTED 18 VALUELIMITSCOLUMN INST HEALTH_STATUS TEMP1     ","version":"次へ","tagName":"h3"},{"title":"VALUERANGEBAR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#valuerangebar","content":" アイテムの値に続いてRANGEBARを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 最小値\tレンジバーに表示する最小値。\tTrue 最大値\tレンジバーに表示する最大値。\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 文字数\t値ボックスの幅（文字数）（デフォルト = 12）\tFalse 幅\tレンジバーの幅（デフォルト = 160）\tFalse 高さ\tレンジバーの高さ（デフォルト = 25）\tFalse  使用例:  VALUERANGEBAR INST HEALTH_STATUS TEMP1 0 100000 RAW 18 200 40 VALUERANGEBAR INST HEALTH_STATUS TEMP1 -120 120     ","version":"次へ","tagName":"h3"},{"title":"LINEGRAPH​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#linegraph","content":" テレメトリアイテムの折れ線グラフを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED\tFalse 減少データ\t減少データを表示するかどうか。デフォルトはDECOM。 有効な値: DECOM, REDUCED_MINUTE, REDUCED_HOUR, REDUCED_DAY\tFalse 減少データタイプ\t表示する減少データのタイプ。ReducedがDECOMでない場合にのみ適用されます。 有効な値: MIN, MAX, AVG, STDDEV\tFalse  使用例:  LINEGRAPH INST HEALTH_STATUS TEMP1 SETTING ITEM INST ADCS Q1 # グラフに追加アイテムを追加     以下の設定はLINEGRAPHに適用されます。これらはSETTINGキーワードを使用して適用されます。  ITEM​  グラフにテレメトリアイテムを追加する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED\tFalse 減少データ\t減少データを表示するかどうか。デフォルトはDECOM。 有効な値: DECOM, REDUCED_MINUTE, REDUCED_HOUR, REDUCED_DAY\tFalse 減少データタイプ\t表示する減少データのタイプ。ReducedがDECOMでない場合にのみ適用されます。 有効な値: MIN, MAX, AVG, STDDEV\tFalse  STARTTIME​   (5.5.1以降) 指定された時間からグラフ履歴を開始する   パラメータ\t説明\t必須開始時間\t'YYYY/MM/DD HH:MM:SS'形式の開始時間\tTrue  HISTORY​   (5.5.1以降) データの初期履歴を表示する   パラメータ\t説明\t必須値\t値(d,h,m,s)。例えば1d、2h、30m、15s\tTrue  SECONDSGRAPHED​  グラフに指定された秒数を表示する  パラメータ\t説明\t必須時間\t表示する秒数\tTrue  POINTSSAVED​  グラフメモリに秒数を保存する  パラメータ\t説明\t必須時間\t保存する秒数\tTrue  POINTSGRAPHED​  グラフに表示するポイント数  パラメータ\t説明\t必須時間\tグラフ化するポイント数\tTrue  SIZE​  グラフのサイズ  パラメータ\t説明\t必須幅\tピクセル単位の幅\tTrue 高さ\tピクセル単位の高さ\tTrue  ","version":"次へ","tagName":"h3"},{"title":"SPARKLINE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#sparkline","content":" テレメトリアイテムのスパークライングラフ（カーソル、スケール、凡例なし）を表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED\tFalse 減少データ\t減少データを表示するかどうか。デフォルトはDECOM。 有効な値: DECOM, REDUCED_MINUTE, REDUCED_HOUR, REDUCED_DAY\tFalse 減少データタイプ\t表示する減少データのタイプ。ReducedがDECOMでない場合にのみ適用されます。 有効な値: MIN, MAX, AVG, STDDEV\tFalse  使用例:  SPARKLINE INST HEALTH_STATUS TEMP1 SETTING SIZE 400 50 SETTING HISTORY 30s # グラフに30秒のデータを追加     以下の設定はSPARKLINEに適用されます。これらはSETTINGキーワードを使用して適用されます。  ITEM​  グラフにテレメトリアイテムを追加する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED\tFalse 減少データ\t減少データを表示するかどうか。デフォルトはDECOM。 有効な値: DECOM, REDUCED_MINUTE, REDUCED_HOUR, REDUCED_DAY\tFalse 減少データタイプ\t表示する減少データのタイプ。ReducedがDECOMでない場合にのみ適用されます。 有効な値: MIN, MAX, AVG, STDDEV\tFalse  STARTTIME​   (5.5.1以降) 指定された時間からグラフ履歴を開始する   パラメータ\t説明\t必須開始時間\t'YYYY/MM/DD HH:MM:SS'形式の開始時間\tTrue  HISTORY​   (5.5.1以降) データの初期履歴を表示する   パラメータ\t説明\t必須値\t値(d,h,m,s)。例えば1d、2h、30m、15s\tTrue  SECONDSGRAPHED​  グラフに指定された秒数を表示する  パラメータ\t説明\t必須時間\t表示する秒数\tTrue  POINTSSAVED​  グラフメモリに秒数を保存する  パラメータ\t説明\t必須時間\t保存する秒数\tTrue  POINTSGRAPHED​  グラフに表示するポイント数  パラメータ\t説明\t必須時間\tグラフ化するポイント数\tTrue  SIZE​  グラフのサイズ  パラメータ\t説明\t必須幅\tピクセル単位の幅\tTrue 高さ\tピクセル単位の高さ\tTrue  ","version":"次へ","tagName":"h3"},{"title":"LABELSPARKLINE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#labelsparkline","content":" アイテム名のLABELに続いてSPARKLINEを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED\tFalse 減少データ\t減少データを表示するかどうか。デフォルトはDECOM。 有効な値: DECOM, REDUCED_MINUTE, REDUCED_HOUR, REDUCED_DAY\tFalse 減少データタイプ\t表示する減少データのタイプ。ReducedがDECOMでない場合にのみ適用されます。 有効な値: MIN, MAX, AVG, STDDEV\tFalse  使用例:  LABELSPARKLINE INST HEALTH_STATUS TEMP1 SETTING HISTORY 5m # グラフに5分のデータを追加     以下の設定はLABELSPARKLINEに適用されます。これらはSETTINGキーワードを使用して適用されます。  ITEM​  グラフにテレメトリアイテムを追加するh  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue Value type\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED\tFalse 減少データ\t減少データを表示するかどうか。デフォルトはDECOM。 有効な値: DECOM, REDUCED_MINUTE, REDUCED_HOUR, REDUCED_DAY\tFalse 減少データタイプ\t表示する減少データのタイプ。ReducedがDECOMでない場合にのみ適用されます。 有効な値: MIN, MAX, AVG, STDDEV\tFalse  STARTTIME​   (5.5.1以降) 指定された時間からグラフ履歴を開始する   パラメータ\t説明\t必須開始時間\t'YYYY/MM/DD HH:MM:SS'形式の開始時間\tTrue  HISTORY​   (5.5.1以降) データの初期履歴を表示する   パラメータ\t説明\t必須値\t値(d,h,m,s)。例えば1d、2h、30m、15s\tTrue  SECONDSGRAPHED​  グラフに指定された秒数を表示する  パラメータ\t説明\t必須時間\t表示する秒数\tTrue  POINTSSAVED​  グラフメモリに秒数を保存する  パラメータ\t説明\t必須時間\t保存する秒数\tTrue  POINTSGRAPHED​  グラフに表示するポイント数  パラメータ\t説明\t必須時間\tグラフ化するポイント数\tTrue  SIZE​  グラフのサイズ  パラメータ\t説明\t必須幅\tピクセル単位の幅\tTrue 高さ\tピクセル単位の高さ\tTrue  ","version":"次へ","tagName":"h3"},{"title":"IMAGEVIEWER​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#imageviewer","content":" TLMパケットからbase64画像を表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tCONVERTED値を取得するアイテム名。追加処理（base64エンコーディング）が必要な場合は、DERIVEDアイテムの使用を検討してください。\tTrue フォーマット\tbase64データの画像フォーマット（例：jpg、pngなど）\tTrue  使用例:  IMAGEVIEWER INST IMAGE IMAGE jpg     ","version":"次へ","tagName":"h3"},{"title":"PROGRESSBAR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#progressbar","content":" パーセンテージの表示に便利なプログレスバーを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue スケールファクター\tプログレスバーに表示する前にテレメトリアイテムに掛ける値。最終値は0から100の範囲である必要があります。デフォルトは1.0です。\tFalse 幅\tプログレスバーの幅（デフォルト = 100ピクセル）\tFalse 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse  使用例:  PROGRESSBAR INST ADCS POSPROGRESS 0.5 200 PROGRESSBAR INST ADCS POSPROGRESS     ","version":"次へ","tagName":"h3"},{"title":"RANGEBAR​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#rangebar","content":" アイテムの値を表示するカスタムレンジバーを表示する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 最小値\tレンジバーに表示する最小値。\tTrue 最大値\tレンジバーに表示する最大値。\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 幅\tレンジバーの幅（デフォルト = 100）\tFalse 高さ\tレンジバーの高さ（デフォルト = 25）\tFalse  使用例:  RANGEBAR INST HEALTH_STATUS TEMP1 0 100000 RAW 200 50 RANGEBAR INST HEALTH_STATUS TEMP1 -100 100     ","version":"次へ","tagName":"h3"},{"title":"ROLLUP​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#rollup","content":"  (Since 5.17.1) ロールアップテレメトリに基づいて色が変化する通知アイコンを表示する   パラメータ\t説明\t必須アイコン名\t表示するastro UXアイコン。有効な選択肢はhttps://github.com/RocketCommunicationsInc/astro-components/blob/master/static/json/rux-icons.jsonから取得した'astro'アイコンです。\tTrue アイコンラベル\tアイコンラベルに適用するテキスト\tFalse アイコンサブラベル\tアイコンサブラベルに適用するテキスト\tFalse  使用例:  ROLLUP satellite-transmit &quot;SAT 1&quot; &quot;Details&quot; # クリック時に開くスクリーン SETTING SCREEN INST HS # ロールアップステータスのテレメトリアイテム SETTING TLM INST HEALTH_STATUS TEMP1 SETTING TLM INST HEALTH_STATUS TEMP2 ROLLUP antenna &quot;GND 2&quot; &quot;Location&quot; # クリック時に開くスクリーン SETTING SCREEN INST HS # ロールアップステータスのテレメトリアイテム SETTING TLM INST HEALTH_STATUS TEMP3 SETTING TLM INST HEALTH_STATUS TEMP4     ","version":"次へ","tagName":"h3"},{"title":"SIGNAL​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#signal","content":"  (Since 5.17.2) テレメトリ値に基づいて変化するセルラー信号アイコンを表示する   パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED\tFalse  使用例:  SIGNAL INST HEALTH_STATUS TEMP1 # クリック時に開くスクリーン SETTING SCREEN INST HS # 1バー、2バー、3バーアイコンを設定するときに比較する値 # デフォルトは30、60、90（0から100の範囲） # 値 &lt; -50 の場合、バーは表示されません # 値 &gt;= -50 かつ &lt; 0 の場合、1バー表示 # 値 &gt;= 0 かつ &lt; 50 の場合、2バー表示 # 値 &gt;= 50 の場合、5バー表示 SETTING RANGE -50 0 50     ","version":"次へ","tagName":"h3"},{"title":"TEXTBOX​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#textbox","content":" 複数行のテキスト用の大きなボックスを提供する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 幅\tテキストボックスの幅（ピクセル単位）（デフォルト = 200）\tFalse 高さ\tテキストボックスの高さ（ピクセル単位）（デフォルト = 200）\tFalse  使用例:  TEXTBOX INST HEALTH_STATUS PACKET_TIMEFORMATTED 150 70     ","version":"次へ","tagName":"h3"},{"title":"VALUE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#value","content":" テレメトリアイテムの値を持つボックスを表示する  ボックスの白い部分は値が変化しない間はグレーに暗くなり、値が変わるたびに白く明るくなります。さらに、値はアイテムの制限状態に基づいて色付けされます（例えば、制限を超えている場合は赤色）。  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse 文字数\t値ボックスの幅（文字数）（デフォルト = 12）\tFalse  使用例:  VALUE INST HEALTH_STATUS TEMP1 CONVERTED 18 VALUE INST HEALTH_STATUS TEMP1     ","version":"次へ","tagName":"h3"},{"title":"インタラクティブウィジェット​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#インタラクティブウィジェット","content":"   インタラクティブウィジェットはユーザーからの入力を収集するために使用されます。何らかのグラフィカルな表現を出力するだけの他のすべてのウィジェットとは異なり、インタラクティブウィジェットはキーボードまたはマウスからの入力を許可します。  ","version":"次へ","tagName":"h2"},{"title":"BUTTON​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#button","content":" クリック可能な長方形のボタンを表示する  クリックすると、ボタンは割り当てられたJavaScriptコードを実行します。ボタンは コマンドの送信や他のタスクの実行に使用できます。ボタンに 他のウィジェットからの値を使用させたい場合は、それらを名前付きウィジェットとして定義し、screen.getNamedWidget(&quot;WIDGET_NAME&quot;).text()メソッドを使用して値を読み取ります。 CHECKBUTTONの例を参照してください。  ボタンコードはかなり複雑になることがあるので、文字列連結を使用して 読みやすくすることを忘れないでください。+を使用すると、文字列連結中に 改行が自動的に挿入されます。\\を使用する場合は、行を 単一のセミコロン;で区切る必要があります。COSMOSは二重セミコロン;;を使用して、行が 別々に評価されるべきであることを示します。すべてのOpenC3コマンド（api.cmdを使用）は;;で区切る必要があることに注意してください。  api.cmd()を使用してボタンでコマンドを送信できます。cmd()構文は 標準のCOSMOSスクリプト構文と全く同じです。また、JavaScript Promisesを使用して 画面でテレメトリをリクエストして使用することもできます。  api.tlm('INST PARAMS VALUE3', 'RAW').then(dur =&gt; api.cmd('INST COLLECT with TYPE NORMAL, DURATION '+dur))&quot;  api.tlm()関数はPromiseを返し、then()で解決され、 その時点で受け取ったテレメトリ値でコマンドを送信します。  runScript()メソッドを使用してBUTTONからスクリプトを起動できます。runScript()は3つのパラメータを取ります： スクリプト名、Script Runnerのフォアグラウンドでスクリプトを開くかどうか（デフォルト = true）、 環境変数のハッシュです。例：runScript('INST/procedures/script.rb', false, {'VAR': 'VALUE'})  パラメータ\t説明\t必須ボタンテキスト\tボタンに表示されるテキスト\tTrue ボタンコード\tボタンが押されたときに実行されるJavaScriptコード\tTrue  使用例:  BUTTON 'Start Collect' 'api.cmd(&quot;INST COLLECT with TYPE NORMAL, DURATION 5&quot;)' BUTTON 'Run Checks' 'runScript(&quot;INST/procedures/checks.rb&quot;)' # バックグラウンドチェックボックスと環境変数を使用したより複雑な例 NAMED_WIDGET SCRIPTNAME COMBOBOX collect.rb checks.rb NAMED_WIDGET BG CHECKBUTTON 'Background' BUTTON 'Run Script' &quot;var script=screen.getNamedWidget('SCRIPTNAME').text();&quot; \\ # スクリプトでENV['TYPE']として使用される環境変数を設定 &quot;var env = {}; env['TYPE'] = 'TEST';&quot; \\ &quot;runScript('INST/procedures/'+script, !screen.getNamedWidget('BG').checked(), env)&quot;     ","version":"次へ","tagName":"h3"},{"title":"CHECKBUTTON​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#checkbutton","content":" チェックボックスを表示する  これは単独では使用が限られており、主にNAMED_WIDGETと組み合わせて使用されることに注意してください。  パラメータ\t説明\t必須チェックボックステキスト\tチェックボックスの横に表示されるテキスト\tTrue チェック済み\tチェックボックスの初期状態がチェックされているかどうか（デフォルト = false）。チェックボックスをチェックしない場合は値を与えないでください。\tFalse  使用例:  NAMED_WIDGET UNCHECKED CHECKBUTTON 'Default Unchecked' NAMED_WIDGET CHECK CHECKBUTTON 'Ignore Hazardous Checks' CHECKED BUTTON 'Send' 'screen.getNamedWidget(&quot;CHECK&quot;).checked() ? ' \\ 'api.cmd_no_hazardous_check(&quot;INST CLEAR&quot;) : api.cmd(&quot;INST CLEAR&quot;)' # プログラムでチェックボックスをチェックまたはチェック解除できます BUTTON 'Check' 'screen.getNamedWidget(&quot;CHECK&quot;).value = true' BUTTON 'Uncheck' 'screen.getNamedWidget(&quot;CHECK&quot;).value = false'     ","version":"次へ","tagName":"h3"},{"title":"COMBOBOX​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#combobox","content":" テキストアイテムのドロップダウンリストを表示する  これは単独では使用が限られており、主にNAMED_WIDGETと組み合わせて使用されることに注意してください。  パラメータ\t説明\t必須オプションテキスト1\t選択ドロップダウンに表示するテキスト\tTrue オプションテキストn\t選択ドロップダウンに表示するテキスト\tFalse  使用例:  BUTTON 'Start Collect' 'var type = screen.getNamedWidget(&quot;COLLECT_TYPE&quot;).text();' + 'api.cmd(&quot;INST COLLECT with TYPE &quot;+type+&quot;, DURATION 10.0&quot;)' NAMED_WIDGET COLLECT_TYPE COMBOBOX NORMAL SPECIAL     ","version":"次へ","tagName":"h3"},{"title":"DATE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#date","content":" 日付ピッカーを表示する  これは単独では使用が限られており、主にNAMED_WIDGETと組み合わせて使用されることに注意してください。  パラメータ\t説明\t必須日付ラベル\tデータ選択にラベル付けするテキスト（デフォルトは'Date'）\tFalse  使用例:  BUTTON 'Alert Date' 'var date = screen.getNamedWidget(&quot;DATE&quot;).text();' + 'alert(&quot;Date:&quot;+date)' NAMED_WIDGET DATE DATE     ","version":"次へ","tagName":"h3"},{"title":"RADIOGROUP​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#radiogroup","content":" RADIOBUTTONのグループを作成する  RADIOBUTTONは選択ロジックを有効にするためにグループの一部である必要があります  パラメータ\t説明\t必須初期選択ボタン\t初期化時にラジオボタンを選択します（0ベース）\tFalse  ","version":"次へ","tagName":"h3"},{"title":"RADIOBUTTON​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#radiobutton","content":" ラジオボタンとテキストを表示する  これは単独では使用が限られており、主にNAMED_WIDGETと組み合わせて使用されます。単一のRADIOBUTTONの一般的な選択を有効にするには、RADIOGROUPに含まれている必要があります。  パラメータ\t説明\t必須テキスト\tラジオボタンの隣に表示するテキスト\tTrue  使用例:  NAMED_WIDGET GROUP RADIOGROUP 1 # 初期状態で'Clear'を選択、0ベースインデックス RADIOBUTTON 'Abort' RADIOBUTTON 'Clear' END BUTTON 'Send' &quot;screen.getNamedWidget('GROUP').selected() === 0 ? &quot; + &quot;api.cmd('INST ABORT') : api.cmd('INST CLEAR')&quot;     ","version":"次へ","tagName":"h3"},{"title":"TEXTFIELD​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#textfield","content":" ユーザーがテキストを入力できる長方形のボックスを表示する  パラメータ\t説明\t必須文字数\tテキストフィールドの幅（文字数）（デフォルト = 12）\tFalse テキスト\tテキストフィールドに入れるデフォルトテキスト（デフォルトは空白）\tFalse  使用例:  NAMED_WIDGET DURATION TEXTFIELD 12 &quot;10.0&quot; BUTTON 'Start Collect' 'var dur = screen.getNamedWidget(&quot;DURATION&quot;).text();' + 'api.cmd(&quot;INST COLLECT with TYPE NORMAL, DURATION &quot;+dur+&quot;&quot;)'     ","version":"次へ","tagName":"h3"},{"title":"TIME​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#time","content":" 時間ピッカーを表示する  これは単独では使用が限られており、主にNAMED_WIDGETと組み合わせて使用されます。  パラメータ\t説明\t必須時間ラベル\t時間選択にラベル付けするテキスト（デフォルトは'Time'）\tFalse  使用例:  BUTTON 'Alert Time' 'var time = screen.getNamedWidget(&quot;TIME&quot;).text();' + 'alert(&quot;Time:&quot;+time)' NAMED_WIDGET TIME TIME     ","version":"次へ","tagName":"h3"},{"title":"キャンバスウィジェット​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#キャンバスウィジェット","content":"   キャンバスウィジェットは、テレメトリ画面にカスタム表示を描画するために使用されます。キャンバス座標フレームは(0,0)をキャンバスの左上隅に配置します。  ","version":"次へ","tagName":"h2"},{"title":"CANVAS​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#canvas","content":" 他のキャンバスウィジェットのためのレイアウトウィジェット  すべてのキャンバスウィジェットはCANVASウィジェット内に含まれている必要があります。  警告 キャンバス座標フレームは(0,0)をキャンバスの左上隅に配置します。  パラメータ\t説明\t必須幅\tキャンバスの幅\tTrue 高さ\tキャンバスの高さ\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CANVASLABEL​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#canvaslabel","content":" キャンバスにテキストを描画する  パラメータ\t説明\t必須X位置\tキャンバス上のテキストの左上隅のX位置\tTrue Y位置\tキャンバス上のテキストの左上隅のY位置\tTrue テキスト\tキャンバスに描画するテキスト\tTrue フォントサイズ\tテキストのフォントサイズ（デフォルト = 12）\tFalse 色\tテキストの色\tFalse  使用例:  CANVAS 100 100 CANVASLABEL 5 34 &quot;Label1&quot; 24 red CANVASLABEL 5 70 &quot;Label2&quot; 18 blue END     ","version":"次へ","tagName":"h3"},{"title":"CANVASLABELVALUE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#canvaslabelvalue","content":" テレメトリアイテムのテキスト値をオプションのフレーム内にキャンバス上に描画する  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue X位置\tキャンバス上のテキストの左上隅のX位置\tTrue Y位置\tキャンバス上のテキストの左上隅のY位置\tTrue フォントサイズ\tテキストのフォントサイズ（デフォルト = 12）\tFalse 色\tテキストの色\tFalse 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED。 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse  使用例:  CANVAS 200 100 CANVASLABELVALUE INST HEALTH_STATUS TEMP1 5 34 12 red CANVASLABELVALUE INST HEALTH_STATUS TEMP2 5 70 10 blue WITH_UNITS END     ","version":"次へ","tagName":"h3"},{"title":"CANVASIMAGE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#canvasimage","content":" キャンバスに画像を表示する  パラメータ\t説明\t必須画像ファイル名\t画像ファイルの名前。ファイルはプラグインのtargets/TARGET/publicディレクトリに存在する必要があります。\tTrue X位置\tキャンバス上の画像の左上隅のX位置\tTrue Y位置\tキャンバス上の画像の左上隅のY位置\tTrue  使用例:  CANVAS 250 430 CANVASIMAGE &quot;satellite.png&quot; 10 10 200 200 SETTING SCREEN INST HS CANVASIMAGE &quot;https://images.pexels.com/photos/256152/pexels-photo-256152.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=640&amp;w=426&quot; 0 250 250 150 END     以下の設定はCANVASIMAGEに適用されます。これらはSETTINGキーワードを使用して適用されます。  SCREEN​  クリック時に別のスクリーンを開く  パラメータ\t説明\t必須ターゲット名\tターゲットの名前\tTrue スクリーン名\tスクリーンの名前\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CANVASIMAGEVALUE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#canvasimagevalue","content":" テレメトリ値によって変化する画像をキャンバスに表示する  さまざまなSETTING値を使用して、テレメトリに基づいて表示する画像を指定します。例えば、SETTING IMAGE CONNECTED &quot;ground_on.png&quot; 400 100。完全な例についてはDEMOを参照してください。  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 値タイプ\t表示する値のタイプ 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tTrue デフォルト画像ファイル名\t表示するデフォルト画像。ファイルはtargets/TARGET/publicディレクトリに存在する必要があります。\tTrue X位置\tキャンバス上の画像の左上隅のX位置\tTrue Y位置\tキャンバス上の画像の左上隅のY位置\tTrue 画像の幅\t画像の幅（デフォルトは100%）\tFalse 画像の高さ\t画像の高さ（デフォルトは100%）\tFalse  使用例:  CANVAS 230 230 CANVASIMAGEVALUE INST HEALTH_STATUS GROUND1STATUS CONVERTED &quot;ground_error.png&quot; 10 10 180 180 SETTING IMAGE CONNECTED &quot;ground_on.png&quot; 10 10 SETTING IMAGE UNAVAILABLE &quot;ground_off.png&quot; 10 10 SETTING SCREEN INST HS END     以下の設定はCANVASIMAGEVALUEに適用されます。これらはSETTINGキーワードを使用して適用されます。  IMAGE​  状態または値に画像をマッピングする  パラメータ\t説明\t必須値\t状態または値\tTrue 画像ファイル名\t表示する画像。ファイルはtargets/TARGET/publicディレクトリに存在する必要があります。\tTrue X位置\tキャンバス上の画像の左上隅のX位置\tTrue Y位置\tキャンバス上の画像の左上隅のY位置\tTrue  SCREEN​  クリック時に別のスクリーンを開く  パラメータ\t説明\t必須ターゲット名\tターゲットの名前\tTrue スクリーン名\tスクリーンの名前\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CANVASLINE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#canvasline","content":" キャンバスに線を描画する  パラメータ\t説明\t必須開始X位置\tキャンバス上の線の開始位置のX座標\tTrue 開始Y位置\tキャンバス上の線の開始位置のY座標\tTrue 終了X位置\tキャンバス上の線の終了位置のX座標\tTrue 終了Y位置\tキャンバス上の線の終了位置のY座標\tTrue 色\t線の色\tFalse 幅\t線の幅（ピクセル単位）（デフォルト = 1）\tFalse  使用例:  CANVAS 100 50 CANVASLINE 5 5 95 5 CANVASLINE 5 5 5 45 green 2 CANVASLINE 95 5 95 45 blue 3 END     ","version":"次へ","tagName":"h3"},{"title":"CANVASLINEVALUE​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#canvaslinevalue","content":" 色が変化する線をキャンバスに描画する  線は関連するテレメトリアイテムの値に基づいて2つの色のいずれかで表現されます  パラメータ\t説明\t必須ターゲット名\tターゲット名\tTrue パケット名\tパケット名\tTrue アイテム名\tアイテム名\tTrue 開始X位置\tキャンバス上の線の開始位置のX座標\tTrue 開始Y位置\tキャンバス上の線の開始位置のY座標\tTrue 終了X位置\tキャンバス上の線の終了位置のX座標\tTrue 終了Y位置\tキャンバス上の線の終了位置のY座標\tTrue 幅\t線の幅（ピクセル単位）（デフォルト = 3）\tFalse 値タイプ\t表示する値のタイプ。デフォルトはCONVERTED 有効な値: RAW, CONVERTED, FORMATTED, WITH_UNITS\tFalse  使用例:  CANVAS 120 50 CANVASLABELVALUE INST HEALTH_STATUS GROUND1STATUS 0 12 12 black CANVASLINEVALUE INST HEALTH_STATUS GROUND1STATUS 5 25 115 25 5 RAW SETTING VALUE_EQ 1 GREEN SETTING VALUE_EQ 0 RED CANVASLINEVALUE INST HEALTH_STATUS GROUND1STATUS 5 45 115 45 SETTING VALUE_EQ CONNECTED GREEN SETTING VALUE_EQ UNAVAILABLE RED END     以下の設定はCANVASLINEVALUEに適用されます。これらはSETTINGキーワードを使用して適用されます。  VALUE_EQ​   (Since 5.5.1) 値を色にマッピングする   パラメータ\t説明\t必須値\t状態または値\tTrue 色\t線の色\tTrue  ","version":"次へ","tagName":"h3"},{"title":"CANVASDOT​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#canvasdot","content":" キャンバスに点を描画する  パラメータ\t説明\t必須X位置\t点のX位置\tTrue Y位置\t点のY位置\tTrue 色\t点の色\tTrue 半径\t点の半径（ピクセル単位）\tTrue  使用例:  CANVAS 50 50 CANVASDOT 10 15 BLUE 5 END     ","version":"次へ","tagName":"h3"},{"title":"例ファイル​","type":1,"pageTitle":"スクリーン","url":"/ja/docs/configuration/telemetry-screens#例ファイル","content":" 例ファイル: TARGET/myscreen.txt  SCREEN AUTO AUTO 0.5 VERTICAL TITLE &quot;&lt;%= target_name %&gt; Commanding Examples&quot; LABELVALUE INST HEALTH_STATUS COLLECTS LABELVALUE INST HEALTH_STATUS COLLECT_TYPE LABELVALUE INST HEALTH_STATUS DURATION VERTICALBOX &quot;Send Collect Command:&quot; HORIZONTAL LABEL &quot;Type: &quot; NAMED_WIDGET COLLECT_TYPE COMBOBOX NORMAL SPECIAL END HORIZONTAL LABEL &quot; Duration: &quot; NAMED_WIDGET DURATION TEXTFIELD 12 &quot;10.0&quot; END BUTTON 'Start Collect' &quot;api.cmd('INST COLLECT with TYPE '+screen.getNamedWidget('COLLECT_TYPE').text()+', DURATION '+screen.getNamedWidget('DURATION').text())&quot; END SETTING BACKCOLOR 163 185 163 VERTICALBOX &quot;パラメータ-less Commands:&quot; NAMED_WIDGET GROUP RADIOGROUP 1 # Select 'Clear' initially, 0-based index RADIOBUTTON 'Abort' RADIOBUTTON 'Clear' END NAMED_WIDGET CHECK CHECKBUTTON 'Ignore Hazardous Checks' # No option is by default UNCHECKED BUTTON 'Send' &quot;screen.getNamedWidget('GROUP').selected() === 0 ? api.cmd('INST ABORT') : (screen.getNamedWidget('CHECK').checked() ? api.cmd_no_hazardous_check('INST CLEAR') : api.cmd('INST CLEAR'))&quot; END SETTING BACKCOLOR 163 185 163 END  ","version":"次へ","tagName":"h2"},{"title":"テーブルマネージャー","type":0,"sectionRef":"#","url":"/ja/docs/tools/table-manager","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"テーブルマネージャー","url":"/ja/docs/tools/table-manager#はじめに","content":" テーブルマネージャーはバイナリファイルエディタです。COSMOSのコマンドパケット定義に似たバイナリファイル定義を取り、バイナリファイル内のフィールドを編集するためのGUIです。    ","version":"次へ","tagName":"h2"},{"title":"ファイルメニュー項目​","type":1,"pageTitle":"テーブルマネージャー","url":"/ja/docs/tools/table-manager#ファイルメニュー項目","content":"   定義に基づいた新しいバイナリを作成既存のバイナリを開く現在のバイナリを保存現在のバイナリの名前を変更現在のバイナリを削除  ","version":"次へ","tagName":"h3"},{"title":"ファイルダウンロード​","type":1,"pageTitle":"テーブルマネージャー","url":"/ja/docs/tools/table-manager#ファイルダウンロード","content":" ファイルダウンロードの横にある3つのボタンは、バイナリファイル、定義ファイル、およびレポートファイルをダウンロードします。バイナリはテーブルで定義された生のビットです。定義はこれらの生のビットの構造定義です。レポートファイルはテーブルマネージャーが生成したCSVで、バイナリ内のすべてのテーブル値を表示します。  ","version":"次へ","tagName":"h2"},{"title":"アップロード/ダウンロード​","type":1,"pageTitle":"テーブルマネージャー","url":"/ja/docs/tools/table-manager#アップロードダウンロード","content":" テーブルマネージャーには、バイナリファイルをターゲットにアップロードしたり、ファイルをテーブルマネージャーにダウンロードしたりするためにCOSMOSスクリプトを直接呼び出す機能があります。ターゲットのproceduresディレクトリにupload.rbというファイルが見つかると、アップロードボタン (Upload) がアクティブになります。ターゲットのproceduresディレクトリにdownload.rbというファイルが見つかると、ダウンロードボタン (Download) がアクティブになります。B/Gボタンはアップロード/ダウンロードスクリプトをバックグラウンドで実行するかどうかを示します。このボックスのチェックを外すと、新しいスクリプトランナーウィンドウがスクリプトの行ごとの実行を表示します。  ","version":"次へ","tagName":"h2"},{"title":"upload.rb​","type":1,"pageTitle":"テーブルマネージャー","url":"/ja/docs/tools/table-manager#uploadrb","content":" COSMOSデモは次のupload.rbスクリプトを作成します。ENV['TBL_FILENAME']がテーブルファイルの名前に設定され、スクリプトはget_target_fileを使用してファイルにアクセスすることに注意してください。この時点で、ファイルをターゲットにアップロードするロジックはターゲットによって定義されたコマンドに固有ですが、例としてスクリプトが提供されています。  # TBL_FILENAMEはテーブルファイルの名前に設定されます puts &quot;file:#{ENV['TBL_FILENAME']}&quot; # ファイルを開く file = get_target_file(ENV['TBL_FILENAME']) buffer = file.read # puts buffer.formatted # テーブルをアップロードするためのカスタムコマンドロジックを実装 # bufferはバイトのRuby文字列であることに注意 # おそらく次のようにしたいでしょう： # buf_size = 512 # アップロードコマンドのバッファサイズ # i = 0 # while i &lt; buffer.length # # バッファの一部を送信 # # 注意：三つのドットは開始インデックス、終了インデックスを含まない範囲を意味します # # 二つのドットは開始インデックス、終了インデックスを含む範囲を意味します # cmd(&quot;TGT&quot;, &quot;UPLOAD&quot;, &quot;DATA&quot; =&gt; buffer[i...(i + buf_size)]) # i += buf_size # end file.delete   ","version":"次へ","tagName":"h3"},{"title":"download.rb​","type":1,"pageTitle":"テーブルマネージャー","url":"/ja/docs/tools/table-manager#downloadrb","content":" COSMOSデモは次のdownload.rbスクリプトを作成します。ENV['TBL_FILENAME']が上書きするテーブルファイルの名前に設定され、スクリプトはput_target_fileを使用してファイルにアクセスすることに注意してください。この時点で、ターゲットからファイルをダウンロードするロジックはターゲットによって定義されたコマンドに固有ですが、例としてスクリプトが提供されています。  # TBL_FILENAMEは上書きするテーブルファイルの名前に設定されます puts &quot;file:#{ENV['TBL_FILENAME']}&quot; # ファイルをダウンロード # テーブルをダウンロードするためのカスタムコマンドロジックを実装 # おそらく次のようにしたいでしょう： buffer = '' # i = 1 # num_segments = 5 # TBL_FILENAMEに基づいて計算 # table_id = 1 # TBL_FILENAMEに基づいて計算 # while i &lt; num_segments # # テーブルバッファの一部をリクエスト # cmd(&quot;TGT DUMP with TABLE_ID #{table_id}, SEGMENT #{i}&quot;) # buffer += tlm(&quot;TGT DUMP_PKT DATA&quot;) # i += 1 # end put_target_file(ENV['TBL_FILENAME'], buffer)  ","version":"次へ","tagName":"h3"},{"title":"テレメトリグラファー","type":0,"sectionRef":"#","url":"/ja/docs/tools/tlm-grapher","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"テレメトリグラファー","url":"/ja/docs/tools/tlm-grapher#はじめに","content":" テレメトリグラファーは、グラフごとに1つ以上のテレメトリポイントを表示できるグラフ作成アプリケーションです。画面ごとに複数のグラフをサポートし、サイズ変更や並べ替えが可能です。異なる状況に対応するために、複数の設定を保存して復元することができます。    ","version":"次へ","tagName":"h2"},{"title":"テレメトリグラファーのメニュー​","type":1,"pageTitle":"テレメトリグラファー","url":"/ja/docs/tools/tlm-grapher#テレメトリグラファーのメニュー","content":" ","version":"次へ","tagName":"h2"},{"title":"ファイルメニュー項目​","type":1,"pageTitle":"テレメトリグラファー","url":"/ja/docs/tools/tlm-grapher#ファイルメニュー項目","content":"   保存された設定（グラフと項目）を開く現在の設定を保存設定をリセット（デフォルト設定）  設定を開く​  設定を開くダイアログでは、保存されたすべての設定のリストが表示されます。設定を選択し、OKをクリックしてロードします。設定名の横にあるゴミ箱アイコンをクリックして、既存の設定を削除できます。  設定を保存​  設定を保存ダイアログでも、保存されたすべての設定のリストが表示されます。設定名テキストフィールドをクリックし、新しい設定の名前を入力し、OKをクリックして保存します。設定名の横にあるゴミ箱アイコンをクリックして、既存の設定を削除できます。  ","version":"次へ","tagName":"h3"},{"title":"グラフメニュー項目​","type":1,"pageTitle":"テレメトリグラファー","url":"/ja/docs/tools/tlm-grapher#グラフメニュー項目","content":"   新しいグラフを追加グラフの開始/再開グラフの一時停止グラフの停止グラファー設定の編集  グラファー設定を編集すると、テレメトリグラファーツールのすべてのグラフに影響する設定を変更するダイアログが表示されます。グラフ表示秒数を変更すると、グラフポイントを表示する可視ウィンドウが変更されます。表示するポイント数を計算する際には、グラフ表示秒数とグラフ表示ポイント数の小さい方が使用されます。保存ポイント数を変更すると、値が高すぎる場合、ブラウザウィンドウのパフォーマンスに影響します。デフォルトの1,000,000ポイントは、1Hzのデータポイントで11.5日以上保存できます。  グラフのタイトルバーの鉛筆アイコンをクリックして個々のグラフを編集すると、グラフ編集ダイアログが表示されます。    開始日と開始時間を編集すると、指定された時間から始まるようにデータが再クエリされます。この操作は、過去のデータをリクエストする距離によって数秒かかる場合があります。同様に、終了日と終了時間を指定すると、データリクエストが指定された時間に制限されます。終了日/終了時間フィールドを空のままにすると、テレメトリグラファーは到着したアイテムをリアルタイムでグラフ化し続けます。  Y軸最小値とY軸最大値を変更すると、単にグラフのスケールが設定されます。Y軸最小値とY軸最大値を削除すると、グラフは値が到着するたびに自動的にスケーリングされます。最小値を0、最大値を100に設定した次のグラフを最初のグラフ画像（自動スケール）と比較してください。    ","version":"次へ","tagName":"h3"},{"title":"項目の選択​","type":1,"pageTitle":"テレメトリグラファー","url":"/ja/docs/tools/tlm-grapher#項目の選択","content":" ターゲットの選択ドロップダウンからターゲットを選択すると、選択したパケットドロップダウンで利用可能なパケットが自動的に更新され、それによって選択した項目ドロップダウンで利用可能な項目が更新されます。項目を追加をクリックすると、項目がグラフに追加され、すぐにグラフ化が開始されます。    時間が経過すると、メイングラフが埋まってスクロールし始め、下部の概要グラフには全履歴が表示されます。    新しい項目を選択してグラフに追加すると、最初の項目の開始時点までの履歴がグラフに自動的に入力されます。これにより、項目を徐々にグラフに追加しても、完全な履歴を維持することができます。    ","version":"次へ","tagName":"h2"},{"title":"グラフウィンドウの管理​","type":1,"pageTitle":"テレメトリグラファー","url":"/ja/docs/tools/tlm-grapher#グラフウィンドウの管理","content":" すべてのグラフは、タイトルバーをクリックして移動することで、ブラウザウィンドウ内を移動できます。他のグラフはスペースを埋めるために効率良く移動します。これにより、作成順に関係なく、グラフを並べ替えることができます。  各グラフには、右上隅にウィンドウボタンのセットがあります。最初のボタンは、グラフを水平方向と垂直方向の両方で縮小または拡大し、同じブラウザタブ内に4つのグラフを表示できるようにします。半分の高さのグラフでは概要グラフが表示されなくなることに注意してください。    2番目のボタンは、グラフを水平方向に縮小または拡大し、ブラウザウィンドウの幅の半分または全幅になります。これにより、2つの全幅グラフを上下に配置できます。    ３番目のボタンは、グラフを垂直方向に縮小または拡大し、ブラウザウィンドウの高さの半分または全高になります。これにより、2つの全高グラフを並べて表示できます。    線ボタンはグラフを最小化して効果的に隠します。これにより、既存のグラフを失うことなく、単一のグラフに集中できます。    最後のXボタンはグラフを閉じます。 ","version":"次へ","tagName":"h2"},{"title":"データビューア","type":0,"sectionRef":"#","url":"/ja/docs/tools/data-viewer","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"データビューア","url":"/ja/docs/tools/data-viewer#はじめに","content":" データビューアを使用すると、過去およびリアルタイムの両方でパケットデータまたは個別の項目データを表示できます。    ","version":"次へ","tagName":"h2"},{"title":"データビューアのメニュー​","type":1,"pageTitle":"データビューア","url":"/ja/docs/tools/data-viewer#データビューアのメニュー","content":" ","version":"次へ","tagName":"h2"},{"title":"ファイルメニュー項目​","type":1,"pageTitle":"データビューア","url":"/ja/docs/tools/data-viewer#ファイルメニュー項目","content":"   保存された設定を開く現在の設定を保存設定をリセット（デフォルト設定）  設定を開く​  設定を開くダイアログでは、保存されたすべての設定のリストが表示されます。設定を選択し、OKをクリックしてロードします。設定名の横にあるゴミ箱アイコンをクリックして、既存の設定を削除できます。  設定を保存​  設定を保存ダイアログでも、保存されたすべての設定のリストが表示されます。設定名テキストフィールドをクリックし、新しい設定の名前を入力し、OKをクリックして保存します。設定名の横にあるゴミ箱アイコンをクリックして、既存の設定を削除できます。  ","version":"次へ","tagName":"h3"},{"title":"コンポーネントの追加​","type":1,"pageTitle":"データビューア","url":"/ja/docs/tools/data-viewer#コンポーネントの追加","content":" データビューアはコンポーネントにデータを表示します。インターフェースに新しいコンポーネントを追加するには、プラスアイコンをクリックします。これによりコンポーネント追加ダイアログが表示されます。まず、データを視覚化するために使用したいコンポーネントを選択します。次に、コンポーネントを入力するパケットを追加します。最後に「作成 (Create)」をクリックして、データビューアコンポーネントの視覚化を確認します。    COSMOS Raw/Decomコンポーネントの設定を調整するには、歯車アイコンをクリックして表示設定ダイアログを表示します。さまざまな視覚化のオン/オフを切り替えたり、表示されるパケット数や履歴を増やしたりできます。   ","version":"次へ","tagName":"h3"},{"title":"ハンドブック","type":0,"sectionRef":"#","url":"/ja/docs/tools/handbooks","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"ハンドブック","url":"/ja/docs/tools/handbooks#はじめに","content":" ハンドブックは、COSMOSコマンドとテレメトリの定義を整形されたウェブページにフォーマットし、PDFにエクスポートすることができます。    表示したいターゲットとページに表示する列数を選択できます。その後、ブラウザを使用してページを印刷できます。ほとんどのブラウザには、印刷する代わりにPDFとして保存する機能があり、結果のページをPDFとして保存できます。 ","version":"次へ","tagName":"h2"},{"title":"モニタリング","type":0,"sectionRef":"#","url":"/ja/docs/guides/monitoring","content":"","keywords":"","version":"次へ"},{"title":"モニタリングと可観測性​","type":1,"pageTitle":"モニタリング","url":"/ja/docs/guides/monitoring#モニタリングと可観測性","content":" 例示のみ FluentdによるモニタリングはOpenC3によって公式にサポートされておらず、ここに記載されているドキュメントはその実行方法の例に過ぎません。  COSMOSをコンテナベースのサービスに移行するにあたり、COSMOSの内部をより良く監視する方法が必要でした。そこで、COSMOSを監視するために使用できる外部サービスに関する情報をいくつか紹介します。分散システムのモニタリングについてさらに詳しく知りたい場合はこちらをご覧ください。  ","version":"次へ","tagName":"h3"},{"title":"Fluent/Fluentd​","type":1,"pageTitle":"モニタリング","url":"/ja/docs/guides/monitoring#fluentfluentd","content":" Fluentdはオープンソースのデータコレクターであり、データ収集と消費を統一して、データのより良い使用と理解を可能にします。  in_docker.conf  &lt;source&gt; @type forward port 24224 bind 0.0.0.0 &lt;/source&gt; &lt;match *.metric&gt; @type copy &lt;store&gt; @type elasticsearch host openc3-elasticsearch port 9200 logstash_format true logstash_prefix metric logstash_dateformat %Y%m%d include_tag_key true type_name access_log tag_key @log_name flush_interval 1s &lt;/store&gt; &lt;store&gt; @type stdout &lt;/store&gt; &lt;/match&gt; &lt;match *__openc3.log&gt; @type copy &lt;store&gt; @type elasticsearch host openc3-elasticsearch port 9200 logstash_format true logstash_prefix openc3 logstash_dateformat %Y%m%d include_tag_key true type_name access_log tag_key @log_name flush_interval 1s &lt;/store&gt; &lt;store&gt; @type stdout &lt;/store&gt; &lt;/match&gt; &lt;match *.**&gt; @type copy &lt;store&gt; @type elasticsearch host openc3-elasticsearch port 9200 logstash_format true logstash_prefix fluentd logstash_dateformat %Y%m%d include_tag_key true type_name access_log tag_key @log_name flush_interval 1s &lt;/store&gt; &lt;store&gt; @type stdout &lt;/store&gt; &lt;/match&gt;   Dockerfile  注意：FROM行でアーキテクチャ固有のビルドを使用する必要があります。例、MacBookである場合：FROM arm64v8/fluentd:v1.18-1  FROM fluent/fluentd:v1.18-1 COPY ./in_docker.conf /fluentd/etc/fluent.conf USER root RUN gem install fluent-plugin-elasticsearch --no-document --version 5.4.3 \\ &amp;&amp; gem install fluent-plugin-prometheus --no-document --version 2.2.0 USER fluent   ","version":"次へ","tagName":"h3"},{"title":"OpenDistro​","type":1,"pageTitle":"モニタリング","url":"/ja/docs/guides/monitoring#opendistro","content":" Open Distro for Elasticsearchは、強力で使いやすいイベントモニタリングおよびアラートシステムを提供し、データを監視して自動的に関係者に通知を送信できるようにします。直感的なKibanaインターフェースと強力なAPIにより、アラートの設定と管理が容易です。  Docker  これをテストした際、opendistroにログを取り込む方法によっては、セキュリティを無効にする必要があることがわかりました。以下はDockerfileの例です。  Dockerfile  FROM amazon/opendistro-for-elasticsearch:1.12.0 RUN /usr/share/elasticsearch/bin/elasticsearch-plugin remove opendistro_security   ","version":"次へ","tagName":"h3"},{"title":"Prometheus​","type":1,"pageTitle":"モニタリング","url":"/ja/docs/guides/monitoring#prometheus","content":" Prometheusは、計測されたジョブからメトリクスを直接、または短命なジョブのための中間プッシュゲートウェイを介して収集します。収集したすべてのサンプルをローカルに保存し、このデータに対してルールを実行して、既存のデータから新しい時系列データを集計して記録したり、アラートを生成したりします。収集されたデータの視覚化には、Grafanaやその他のAPIコンシューマーを使用できます。  prometheus.yaml  global: scrape_interval: 15s evaluation_interval: 15s rule_files: # - &quot;first.rules&quot; # - &quot;second.rules&quot; scrape_configs: - job_name: prometheus static_configs: - targets: [&quot;localhost:9090&quot;] - job_name: openc3-internal-metrics metrics_path: &quot;/openc3-api/internal/metrics&quot; static_configs: - targets: [&quot;openc3-cmd-tlm-api:2901&quot;] - job_name: openc3-cmd-tlm-api metrics_path: &quot;/openc3-api/metrics&quot; static_configs: - targets: [&quot;openc3-cmd-tlm-api:2901&quot;] - job_name: openc3-script-runner-api metrics_path: &quot;/script-api/metrics&quot; static_configs: - targets: [&quot;openc3-script-runner-api:2902&quot;] - job_name: minio-job metrics_path: /minio/v2/metrics/cluster scheme: http static_configs: - targets: ['openc3-minio:9000']   Dockerfile  FROM prom/prometheus:v3.2.1 ADD prometheus.yaml /etc/prometheus/   ","version":"次へ","tagName":"h3"},{"title":"Grafana​","type":1,"pageTitle":"モニタリング","url":"/ja/docs/guides/monitoring#grafana","content":" Grafanaは、マルチプラットフォームのオープンソース分析および対話型可視化Webアプリケーションです。サポートされているデータソースに接続すると、Web用のチャート、グラフ、アラートを提供します。  datasource.yaml  apiVersion: 1 datasources: - name: Prometheus type: prometheus # アクセスモード - proxy (UIのサーバー) または direct (UIのブラウザ) access: proxy url: http://openc3-prometheus:9090   Dockerfile  FROM grafana/grafana COPY datasource.yaml /etc/grafana/provisioning/datasources/  ","version":"次へ","tagName":"h3"},{"title":"パケットビューア","type":0,"sectionRef":"#","url":"/ja/docs/tools/packet-viewer","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"パケットビューア","url":"/ja/docs/tools/packet-viewer#はじめに","content":" パケットビューアは、定義されたすべてのターゲット、パケット、項目の現在の値を表示するために設定を必要としないライブテレメトリビューアです。制限値を持つ項目は、現在の状態に応じて色付け（青、緑、黄、または赤）されて表示されます。項目を右クリックすると詳細情報を取得できます。    ","version":"次へ","tagName":"h2"},{"title":"パケットビューアのメニュー​","type":1,"pageTitle":"パケットビューア","url":"/ja/docs/tools/packet-viewer#パケットビューアのメニュー","content":" ","version":"次へ","tagName":"h2"},{"title":"ファイルメニュー項目​","type":1,"pageTitle":"パケットビューア","url":"/ja/docs/tools/packet-viewer#ファイルメニュー項目","content":"   更新間隔と古い間隔を変更保存された設定を開く現在の設定（表示設定）を保存設定をリセット（デフォルト設定）  ","version":"次へ","tagName":"h3"},{"title":"表示メニュー項目​","type":1,"pageTitle":"パケットビューア","url":"/ja/docs/tools/packet-viewer#表示メニュー項目","content":"   無視された項目を表示派生項目を最後に表示単位付きで整形された項目を表示整形された項目を表示変換された項目を表示生の項目を表示  ","version":"次へ","tagName":"h3"},{"title":"パケットの選択​","type":1,"pageTitle":"パケットビューア","url":"/ja/docs/tools/packet-viewer#パケットの選択","content":" パケットビューアを最初に開くと、アルファベット順で最初のターゲットとパケットが開きます。ドロップダウンメニューをクリックして、項目テーブルを新しいパケットに更新します。項目のリストをフィルタリングするには、検索ボックスに入力できます。  ","version":"次へ","tagName":"h2"},{"title":"詳細​","type":1,"pageTitle":"パケットビューア","url":"/ja/docs/tools/packet-viewer#詳細","content":" 項目を右クリックして詳細を選択すると、詳細ダイアログが開きます。    このダイアログは、テレメトリ項目に定義されているすべてのものをリストします。 ","version":"次へ","tagName":"h3"},{"title":"スクリプトランナー","type":0,"sectionRef":"#","url":"/ja/docs/tools/script-runner","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"スクリプトランナー","url":"/ja/docs/tools/script-runner#はじめに","content":" スクリプトランナーは、COSMOSスクリプトのエディタであると同時にスクリプトを実行します。スクリプトファイルはCOSMOSターゲット内に保存され、スクリプトランナーはこれらのファイルを開く、保存する、ダウンロードする、削除する機能を提供します。スクリプトのスイートが開かれると、スクリプトランナーは個々のスクリプト、スクリプトのグループ、またはスイート全体を実行するための追加オプションを提供します。    ","version":"次へ","tagName":"h2"},{"title":"スクリプトランナーのメニュー​","type":1,"pageTitle":"スクリプトランナー","url":"/ja/docs/tools/script-runner#スクリプトランナーのメニュー","content":" ","version":"次へ","tagName":"h2"},{"title":"ファイルメニュー項目​","type":1,"pageTitle":"スクリプトランナー","url":"/ja/docs/tools/script-runner#ファイルメニュー項目","content":"   エディタとファイル名をクリアRubyまたはPythonで新しいテストスイートを作成開くファイルを選択するダイアログを開く最近使用したファイルを開く現在開いているファイルをディスクに保存現在のファイルの名前を変更現在のファイルをブラウザにダウンロード現在のファイルを削除（永久に！）   ファイルを開く​  ファイルを開くダイアログには、インストールされたターゲットのツリービューが表示されます。フォルダを手動で開いて、必要なファイルを参照できます。また、上部の検索ボックスを使用し、ファイル名の一部を入力して結果をフィルタリングすることもできます。    名前を付けて保存​  ファイルを初めて保存する場合、または名前を付けて保存を使用する場合、ファイル名を付けて保存ダイアログが表示されます。これはファイルを開くダイアログと同様に、インストールされたターゲットのツリービューを表示します。フォルダ名をクリックしてフォルダを選択し、ファイル名フィールドにファイル名を入力してから、OKをクリックする必要があります。既存のファイルを上書きする前に確認メッセージが表示されます。  ","version":"次へ","tagName":"h3"},{"title":"スクリプトメニュー項目​","type":1,"pageTitle":"スクリプトランナー","url":"/ja/docs/tools/script-runner#スクリプトメニュー項目","content":"   開始および終了したスクリプトを表示環境変数を表示メタデータを表示オーバーライドされたテレメトリ値を表示構文チェックを実行スクリプトニーモニックチェックを実行計測されたスクリプトを表示スクリプトコールスタックを表示デバッグプロンプトを表示実際のインターフェースから切断すべてのスクリプトブレークポイントを削除  実行ステータスポップアップには、現在実行中のスクリプトが一覧表示されます。これにより、他のユーザーは実行中のスクリプトに接続し、現在実行中のスクリプトに沿って追跡できます。また、以前に実行されたスクリプトも一覧表示されるため、スクリプトログをダウンロードできます。    ","version":"次へ","tagName":"h3"},{"title":"スクリプトの実行​","type":1,"pageTitle":"スクリプトランナー","url":"/ja/docs/tools/script-runner#スクリプトの実行","content":" 通常のスクリプトを実行するには、単にスクリプトを開いて開始ボタン(Start)をクリックするだけです。デフォルトでは、スクリプトを開くとファイル名が更新され、エディタにスクリプトがロードされます。    開始をクリックすると、スクリプトはサーバーで起動され、スクリプトの状態は「接続中 (Connecting)」になります。    その時点で、現在実行中の行は緑色でマークされます。エラーが発生すると、行は赤色に変わり、一時停止ボタン (Pause)は「再試行 (Retry)」に変わり、行を再試行できるようになります。    これにより、テレメトリの変更に依存するチェックは、テレメトリが背景でリアルタイムに更新されているため、潜在的に再試行できます。また、「進む (Go)」をクリックしてエラーを通過するか、「停止 (Stop)」をクリックしてスクリプトの実行を終了することもできます。  ","version":"次へ","tagName":"h2"},{"title":"スクリプトの右クリック​","type":1,"pageTitle":"スクリプトランナー","url":"/ja/docs/tools/script-runner#スクリプトの右クリック","content":" スクリプトを右クリックすると、いくつかのオプションが表示されます：    「選択部分を実行 (Execute selection)」は、選択したコード部分を新しいスクリプトランナータブにコピーし、現在のスクリプトとは独立して実行します。これはコードの選択部分を実行するのに便利ですが、選択されていない他の変数への参照には注意してください。COSMOSは未定義の変数を参照できません！  「ここから実行 (Run from here)」は、カーソルの現在位置からすべてを新しいスクリプトランナータブにコピーし、現在のスクリプトとは独立して実行します。これは前半のコードの実行を避けるのに便利ですが、選択されていない他の変数への参照には注意してください。COSMOSは未定義の変数を参照できません！  「すべてのブレークポイントをクリア (Clear local breakpoints)」では、エディタの行番号をクリックして設定したブレークポイントをすばやくクリアできます。  ","version":"次へ","tagName":"h3"},{"title":"スクリプトスイートの実行​","type":1,"pageTitle":"スクリプトランナー","url":"/ja/docs/tools/script-runner#running-script-suites","content":" スクリプトがスイートとして構成されている場合、スクリプトランナーは自動的にファイルを解析して、スイート、グループ、およびスクリプトのドロップダウンメニューを入力します。    新しいスイートを生成するには、ファイル (File) -&gt; 新規スイート (New Suite) を使用し、RubyまたはPythonを選択してその言語でスイートを作成します。  ","version":"次へ","tagName":"h2"},{"title":"グループ​","type":1,"pageTitle":"スクリプトランナー","url":"/ja/docs/tools/script-runner#グループ","content":" グループクラスには、テストまたは操作を実行するために使用されるメソッドが含まれています。グループクラス内で実装される「script」、「op」、または「test」で始まるメソッドは、実行するスクリプトとして自動的に含まれます。例えば、上の画像では、「script_power_on」がスクリプトドロップダウンメニューにあることに気づくでしょう。別の簡単なRubyの例：  require 'openc3/script/suite.rb' class ExampleGroup &lt; OpenC3::Group def setup puts &quot;setup&quot; end def script_1 puts &quot;script 1&quot; end def teardown puts &quot;teardown&quot; end end   同等のPythonの例：  from openc3.script.suite import Suite, Group class ExampleGroup(Group): def setup(self): print(&quot;setup&quot;) def script_1(self): print(&quot;script 1&quot;) def teardown(self): print(&quot;teardown&quot;)   setupとteardownメソッドは特別なメソッドで、グループドロップダウンメニューの横にあるセットアップとティアダウンボタンを有効にします。これらのボタンをクリックすると、関連するメソッドが実行されます。  ","version":"次へ","tagName":"h3"},{"title":"スイート​","type":1,"pageTitle":"スクリプトランナー","url":"/ja/docs/tools/script-runner#スイート","content":" グループはSuiteから継承するクラスを作成し、add_groupメソッドを呼び出すことでスイートに追加されます。例えばRubyでは：  class MySuite &lt; OpenC3::Suite def initialize add_group('ExampleGroup') end def setup puts &quot;Suite setup&quot; end def teardown puts &quot;Suite teardown&quot; end end   Pythonでは：  from openc3.script.suite import Suite, Group class MySuite(Suite): def __init__(self): self.add_group(ExampleGroup) def setup(self): print(&quot;Suite setup&quot;) def teardown(self): print(&quot;Suite teardown&quot;)   ここでも、スイートドロップダウンメニューの横にあるセットアップとティアダウンボタンを有効にするsetupとteardownメソッドがあります。  同じファイル内に複数のスイートとグループを作成でき、それらは解析されてドロップダウンメニューに追加されます。スイートレベルで開始をクリックすると、すべてのグループと各グループ内のすべてのスクリプトを実行します。同様に、グループレベルで開始をクリックすると、グループ内のすべてのスクリプトを実行します。スクリプトの横にある開始をクリックすると、単一のスクリプトのみを実行します。  ","version":"次へ","tagName":"h3"},{"title":"スクリプトスイートオプション​","type":1,"pageTitle":"スクリプトランナー","url":"/ja/docs/tools/script-runner#スクリプトスイートオプション","content":" スクリプトスイートを開くと、実行中のスクリプトにオプションを提供する6つのチェックボックスが作成されます。    エラーで一時停止​  エラーが発生した場合にスクリプトを一時停止します。これはデフォルトで、通常のスクリプトの実行方法と同じです。このボックスのチェックを外すと、ユーザーの介入なしにエラーを通過してスクリプトを続行することができます。エラーに遭遇した際にユーザーが「進む」をクリックするのと似ています。  エラー後も続行​  エラーが発生した場合もスクリプトを続行します。これはデフォルトで、通常のスクリプトの実行方法と同じです。このボックスのチェックを外すと、最初に発生したエラーの後にスクリプトが終了し、スイート/グループ内の他のスクリプトが実行されます。  エラー後に中止​  エラーに遭遇すると実行全体を中止します。スイートのグループの最初のスクリプトでエラーが発生すると、スイート全体の実行が停止します。注：エラー後も続行が設定されている場合、現在のスクリプトは続行して完了することが許可されます。  マニュアル​  Rubyでは、$manualというグローバル変数をtrueに設定します。Pythonでは、RunningScript.manualをTrueに設定します。このボックスを設定すると、スクリプトの作者はオペレータが手動ステップを実行するかどうかを判断できます。スクリプト内でこの変数を使用するかどうかはスクリプト作者次第です。  ループ​  ユーザーが開始したものを継続的にループします。ユーザーがグループの横にある開始をクリックすると、グループ全体がループされます。これは、時々だけ発生するトリッキーなタイミングエラーをキャッチしてデバッグするのに便利です。  エラーでループを中断​  エラーが発生した場合にループを中断します。ループオプションが設定されている場合にのみ使用可能です。  ","version":"次へ","tagName":"h3"},{"title":"スクリプトのデバッグ​","type":1,"pageTitle":"スクリプトランナー","url":"/ja/docs/tools/script-runner#debugging-scripts","content":" デバッグプロンプトを有効にすると、スクリプトとログメッセージの間に追加の行が表示されます。ローカル変数を入力すると、ログメッセージに出力されます。また、var = 10と入力してローカル変数を設定することもできます。    ステップボタンを使用すると、スクリプトを1行ずつ進めることができます。「進む」をクリックすると通常の実行が続行されます。 ","version":"次へ","tagName":"h2"},{"title":"スクリプト作成ガイド","type":0,"sectionRef":"#","url":"/ja/docs/guides/script-writing","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#はじめに","content":" このガイドは、COSMOSが提供するスクリプト機能を使用するためのベストプラクティスを提供することを目的としています。スクリプトは、運用やテストのための一連の活動を自動化するために使用されます。このドキュメントの目的は、シンプルで理解しやすく、保守可能で正確なスクリプトを作成することです。COSMOSスクリプトランナーの使用に関する主要な詳細についてもガイダンスを提供します。  ","version":"次へ","tagName":"h2"},{"title":"概念​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#概念","content":" COSMOSはスクリプト作成にRubyとPythonの両方をサポートしています。RubyとPythonは非常に似たスクリプト言語であり、このガイドのほとんどは両方に直接適用されます。例を使用する場合は、RubyとPythonの両方の例が示されています。  ","version":"次へ","tagName":"h2"},{"title":"COSMOSでのRuby対Python​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#cosmosでのruby対python","content":" COSMOSスクリプトを書く際のRubyとPythonの間には多くの類似点といくつかの主要な違いがあります。  行の長さに80文字の制限はありません。行の長さは好きなだけ長くできますが、スクリプトの印刷レビューが難しくなるため、あまり長くしないように注意してください。インデントの空白： Ruby: 重要ではありません。Rubyはendキーワードを使用して、2スペースを標準としたインデントされたコードブロックを決定します。Python: 重要です。Pythonはインデントを使用して、4スペースを標準としたコードブロックを決定します。 変数は事前に宣言する必要がなく、後で再割り当てできます。つまり、RubyとPythonは動的型付けです。変数の補間： Ruby: 変数値は&quot;#{variable}&quot;構文を使用して文字列に配置できます。Python: 変数値はf&quot;{variable}&quot;構文を使用してf-stringに配置できます。 ブロックやループ内で宣言された変数は、すでに宣言されていない限り、そのブロックの外側には存在しません。  両言語はスクリプト作成者に多くの力を提供します。しかし、大きな力には大きな責任が伴います。スクリプトを書くときは、あなた自身や他の誰かが後でそれを理解する必要があることを忘れないでください。したがって、次のスタイルガイドラインを使用してください：  インデントには一貫したスペースを使用し、タブを使用しないでください定数はすべて大文字でアンダースコア付き SPEED_OF_LIGHT = 299792458 # meters per s 変数名とメソッド名は小文字でアンダースコア付き last_name = &quot;Smith&quot;perform_setup_operation() クラス名（使用する場合）はキャメルケースで、それらを含むファイルは小文字とアンダースコアで一致する必要があります class DataUploader # in 'data_uploader.rb'class CcsdsUtility: # in 'ccsds_utility.py' 無意味なコメントを追加せず、代わりに意図を説明してください    以下は良いRubyスタイルの例です：  load 'TARGET/lib/upload_utility.rb' # 実行を表示したくないライブラリ load_utility 'TARGET/lib/helper_utility.rb' # 実行を表示したいライブラリ # 定数を宣言 OUR_TARGETS = ['INST','INST2'] # 渡されたターゲット名の収集カウンターをクリア def clear_collects(target) cmd(&quot;#{target} CLEAR&quot;) wait_check(&quot;#{target} HEALTH_STATUS COLLECTS == 0&quot;, 5) end ###################################### # 開始 ###################################### helper = HelperUtility.new helper.setup # すべてのターゲットで収集を実行 OUR_TARGETS.each do |target| collects = tlm(&quot;#{target} HEALTH_STATUS COLLECTS&quot;) cmd(&quot;#{target} COLLECT with TYPE SPECIAL&quot;) wait_check(&quot;#{target} HEALTH_STATUS COLLECTS == #{collects + 1}&quot;, 5) end clear_collects('INST') clear_collects('INST2')   以下は良いPythonスタイルの例です：  from openc3.script import * import TARGET.lib.upload_utility # 実行を表示したくないライブラリ load_utility('TARGET/lib/helper_utility.rb') # 実行を表示したいライブラリ # 定数を宣言 OUR_TARGETS = ['INST','INST2'] # 渡されたターゲット名の収集カウンターをクリア def clear_collects(target): cmd(f&quot;{target} CLEAR&quot;) wait_check(f&quot;{target} HEALTH_STATUS COLLECTS == 0&quot;, 5) ###################################### # 開始 ###################################### helper = HelperUtility() helper.setup() # すべてのターゲットで収集を実行 for target in OUR_TARGETS: collects = tlm(f&quot;{target} HEALTH_STATUS COLLECTS&quot;) cmd(f&quot;{target} COLLECT with TYPE SPECIAL&quot;) wait_check(f&quot;{target} HEALTH_STATUS COLLECTS == {collects + 1}&quot;, 5) clear_collects('INST') clear_collects('INST2')   両方の例はCOSMOSスクリプティングのいくつかの機能を示しています。'load'または'import'と'load_utility'の違いに注目してください。最初のものは実行時にScript Runnerで表示されない追加スクリプトを読み込むためのものです。これは画像分析や長時間実行するループコードなど、出力だけが欲しい場合に良い場所です。'load_utility'は何が起こっているかをユーザーに示すために、コードを1行ずつ視覚的に実行します。  次に定数を宣言し、OUR_TARGETSに文字列の配列を格納します。定数はすべて大文字でアンダースコア付きであることに注意してください。  次にclear_collectsという1つのローカルメソッドを宣言します。各メソッドの先頭には、それが何をするのか、およびそれが受け取るパラメータを説明するコメントを提供してください。  次に'helper_utility'が作成されます。クラス名と読み込んだファイル名の類似性に注意してください。  collect例では、以前に作成した文字列配列を反復処理し、コマンドやテレメトリをチェックする際に変数を使用する方法を示しています。Rubyのポンド括弧#{}記法とPythonのf文字列f&quot;&quot;記法は、変数が保持しているものを文字列に入れます。括弧内で追加のコードを実行することもできます。例えば、収集回数の増加をチェックするときのようにです。  最後に、ターゲット名を渡して各ターゲットに対して'clear_collects'メソッドを呼び出します。  ","version":"次へ","tagName":"h3"},{"title":"スクリプティングの哲学​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#スクリプティングの哲学","content":" ","version":"次へ","tagName":"h2"},{"title":"基本的なスクリプト例​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#基本的なスクリプト例","content":" ほとんどのCOSMOSスクリプトは、システム/サブシステムにコマンドを送信し、そのコマンドが期待通りに機能したことを確認するという単純なパターンに分解できます。このパターンは通常、以下のようにcmd()の後にwait_check()を使用して実装されます：  cmd(&quot;INST COLLECT with TYPE NORMAL, TEMP 10.0&quot;) wait_check(&quot;INST HEALTH_STATUS TYPE == 'NORMAL'&quot;, 5)   または同様に、コマンドの前にサンプリングされるカウンターを使用します。  Ruby:  count = tlm(&quot;INST HEALTH_STATUS COLLECTS&quot;) cmd(&quot;INST COLLECT with TYPE NORMAL, TEMP 10.0&quot;) wait_check(&quot;INST HEALTH_STATUS COLLECTS &gt;= #{count + 1}&quot;, 5)   Python:  count = tlm(&quot;INST HEALTH_STATUS COLLECTS&quot;) cmd(&quot;INST COLLECT with TYPE NORMAL, TEMP 10.0&quot;) wait_check(f&quot;INST HEALTH_STATUS COLLECTS &gt;= {count + 1}&quot;, 5)   作成するCOSMOSスクリプトの90%は、コマンドが期待通りに機能したことを確認するために各コマンドの後に複数の項目をチェックする必要がある場合を除いて、上記のような単純なパターンであるべきです。  ","version":"次へ","tagName":"h3"},{"title":"KISS（Keep It Simple Stupid）​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#kisskeep-it-simple-stupid","content":" RubyとPythonは非常に強力な言語であり、同じことを達成するための多くの方法があります。それを考慮すると、常に自分や他の人にとって最も理解しやすい方法を選択してください。複雑な1行コードや難解な正規表現を作成することも可能ですが、複雑な1行コードを展開し、正規表現を分解して文書化することで、後で自分自身に感謝することになるでしょう。  ","version":"次へ","tagName":"h3"},{"title":"DRY（Don't Repeat Yourself）​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#drydont-repeat-yourself","content":" 任意のコマンドと制御システム用に書かれたスクリプトでの広範な問題は、同じコードブロックが複数回繰り返されることです。極端な場合、これは保守やレビューが不可能な10万行以上のスクリプトにつながることがあります。  繰り返しが現れる一般的な方法は2つあります：サブシステムの電源を入れるなどの一般的なアクションを実行するための正確なコードブロック、およびチェックされる助記語の名前またはチェックされる値のみが異なるコードブロックです。どちらもメソッド（または関数）を使用して繰り返しを削除することで解決されます。  例えば、サブシステムの電源を入れて正しいテレメトリを確保するスクリプトは次のようになります：  Ruby:  def power_on_subsystem # 100行のcmd()、wait_check()など end   Python:  def power_on_subsystem(): # 100行のcmd()、wait_check()など   理想的には、上記のメソッドは他のスクリプトでも使用できるように別のファイルに保存されるべきです。それが真に1つのスクリプトでしか役に立たない場合は、ファイルの先頭に置くことができます。更新されたスクリプトは次のようになります：  power_on_subsystem() # 150行のサブシステム操作（例） # cmd(...) # wait_check(...) #... power_off_subystem() # 関連のないアクティビティ power_on_subsystem() # など   唯一の変更が助記語またはチェックされる値であるコードブロックは、引数を持つメソッドで置き換えることができます。  Ruby:  def test_minimum_temp(enable_cmd_name, enable_tlm, temp_tlm, expected_temp) cmd(&quot;TARGET #{enable_cmd_name} with ENABLE TRUE&quot;) wait_check(&quot;TARGET #{enable_tlm} == 'TRUE'&quot;, 5) wait_check(&quot;TARGET #{temp_tlm} &gt;= #{expected_temp}&quot;, 50) end   Python:  def test_minimum_temp(enable_cmd_name, enable_tlm, temp_tlm, expected_temp): cmd(f&quot;TARGET {enable_cmd_name} with ENABLE TRUE&quot;) wait_check(f&quot;TARGET {enable_tlm} == 'TRUE'&quot;, 5) wait_check(f&quot;TARGET {temp_tlm} &gt;= {expected_temp}&quot;, 50)   ","version":"次へ","tagName":"h3"},{"title":"コメントを適切に使用する​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#コメントを適切に使用する","content":" あなたが行っていることが不明確な場合や、一連の行に高レベルの目的がある場合は、コメントを使用してください。コメント内に数字やその他の詳細を入れないようにしてください。それらは基礎となるコードと同期が取れなくなる可能性があります。RubyとPythonのコメントは#ポンド記号で始まり、行のどこにでも配置できます。  # このラインはアボートコマンドを送信します - 悪いコメント、不要 cmd(&quot;INST ABORT&quot;) # キャリブレーションターゲットを見るためにジンバルを回転させる - 良いコメント cmd(&quot;INST ROTATE with ANGLE 180.0&quot;) # 180度回転 - 悪いコメント   ","version":"次へ","tagName":"h3"},{"title":"スクリプトランナー​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#スクリプトランナー","content":" COSMOSはスクリプト（プロシージャとも呼ばれる）を実行するための2つのユニークな方法を提供します。スクリプトランナーはスクリプト実行環境とスクリプトエディタの両方を提供します。スクリプトエディタには、COSMOSメソッドとコマンド/テレメトリ項目名の両方のコード補完が含まれています。これはスクリプトを開発してテストするための優れた環境でもあります。スクリプトランナーは、長いスタイルのプロシージャを持つ従来のスクリプティングモデルに慣れているユーザーと、その場でスクリプトを編集できるようにしたいユーザーのためのフレームワークを提供します。  スイートファイル（'suite'という名前）を開くと、スクリプトランナーはより正式ですが、より強力なスクリプト実行環境を提供します。スイートファイルはスクリプトをスイート、グループ、およびスクリプト（個々のメソッド）に分割します。スイートは最高レベルの概念であり、通常、熱真空試験などの大規模な手順や、軌道上チェックアウトの実行などの大規模な運用シナリオをカバーします。グループは、特定のメカニズムに関するすべてのスクリプトなど、関連するスクリプトのセットをキャプチャします。グループはサブシステムに関連するスクリプトのコレクションや、RF検査などの特定の一連のテストである場合があります。スクリプトは合格または不合格のいずれかになる個々のアクティビティをキャプチャします。スクリプトランナーでは、スイート全体、1つ以上のグループ、または1つ以上のスクリプトを簡単に実行できます。また、タイミング、合格/不合格のカウントなどを含むレポートを自動的に生成します。  仕事に適した環境は個々のユーザー次第であり、多くのプログラムは両方のスクリプト形式を使用して目標を達成します。  ","version":"次へ","tagName":"h3"},{"title":"ループ vs アンロールされたループ​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#ループ-vs-アンロールされたループ","content":" ループは、同じコードを何度も書き直す必要なく、同じ操作を複数回実行できる強力な構造です（DRYの概念を参照）。ただし、失敗した時点でCOSMOSスクリプトを再開するのが難しいか不可能になる場合があります。何かが失敗する可能性が低い場合、ループは優れた選択肢です。スクリプトがテレメトリポイントのリストでループを実行している場合、ループ本体をメソッドにしてから、発生するはずだったループの各繰り返しに対してそのメソッドを直接呼び出すことでループを「アンロール」する方が良い選択かもしれません。  Ruby:  10.times do |temperature_number| check_temperature(temperature_number + 1) end   Python:  for temperature_number in range(1, 11): check_temperature(temperature_number)   上記のスクリプトが温度番号3の後に停止した場合、温度番号4でループを再開する方法はありません。ループカウントが少ない場合の良い解決策は、ループをアンロールすることです。  check_temperature(1) check_temperature(2) check_temperature(3) check_temperature(4) check_temperature(5) check_temperature(6) check_temperature(7) check_temperature(8) check_temperature(9) check_temperature(10)   上記のアンロールされたバージョンでは、COSMOSの「選択した行からスクリプトを開始」機能を使用して、任意の点でスクリプトを再開できます。  ","version":"次へ","tagName":"h3"},{"title":"スクリプトの構成​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#スクリプトの構成","content":" すべてのスクリプトはプラグインの一部である必要があります。SCRIPTSやPROCEDURESなどの単純なプラグインを作成して、スクリプトを保存するためのlibとproceduresディレクトリのみを含めることができます。COSMOSが定義されたcmd/tlmを持たないプラグインを検出すると、テレメトリ処理用のマイクロサービスを起動しません。  ","version":"次へ","tagName":"h2"},{"title":"スクリプトをプラグインに整理する​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#スクリプトをプラグインに整理する","content":" スクリプトが多くのメソッドを持つ大きなものになるにつれて、それらをプラグイン内の複数のファイルに分割することが理にかなっています。以下はプラグインのスクリプト/プロシージャの推奨される構成です。  フォルダ\t説明targets/TARGET_NAME/lib\t再利用可能なターゲット固有のメソッドを含むスクリプトファイルをここに配置 targets/TARGET_NAME/procedures\t1つの特定のターゲットを中心とした単純なプロシージャをここに配置  メインプロシージャでは、通常、load_utilityを使用してインストルメンテーションで他のファイルを取り込みます。  # Ruby: load_utility('TARGET/lib/my_other_script.rb') # Python: load_utility('TARGET/procedures/my_other_script.py')   ","version":"次へ","tagName":"h3"},{"title":"スクリプトをメソッドに整理する​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#スクリプトをメソッドに整理する","content":" 各アクティビティを異なるメソッドに入れてください。スクリプトをメソッドに入れると、整理が簡単になり、全体的なスクリプトが何をするかについての優れた高レベルの概要が得られます（メソッドに適切な名前を付ける場合）。曖昧で短いメソッド名にはボーナスポイントはありません。メソッド名は長く明確にしてください。  Ruby:  def test_1_heater_zone_control puts &quot;Verifies requirements 304, 306, and 310&quot; # テストコードをここに end def script_1_heater_zone_control puts &quot;Verifies requirements 304, 306, and 310&quot; # テストコードをここに end   Python:  def test_1_heater_zone_control(): print(&quot;Verifies requirements 304, 306, and 310&quot;) # テストコードをここに def script_1_heater_zone_control(): print(&quot;Verifies requirements 304, 306, and 310&quot;) # テストコードをここに   ","version":"次へ","tagName":"h3"},{"title":"クラス vs 非スコープメソッドの使用​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#クラス-vs-非スコープメソッドの使用","content":" オブジェクト指向プログラミングのクラスを使用すると、関連するメソッドのセットと関連する状態を整理できます。最も重要な側面は、メソッドが何らかの共有状態で動作することです。例えば、ジンバルを動かすコードがあり、メソッド間で移動または手順の数を追跡する必要がある場合、これはクラスを使用するのに最適な場所です。スクリプト内で複数回発生する処理をコピー＆ペーストせずに実行するためのヘルパーメソッドが必要な場合は、おそらくクラスに入れる必要はありません。  注：COSMOSの規則では、TARGET名に基づいて名付けられたTARGET/lib/target.[rb/py]ファイルがあり、Targetと呼ばれるクラスが含まれています。この議論はTARGET/proceduresディレクトリのスクリプトを指しています。  Ruby:  class Gimbal attr_accessor :gimbal_steps def initialize() @gimbal_steps = 0 end def move(steps_to_move) # ジンバルを動かす @gimbal_steps += steps_to_move end def home_gimbal # ジンバルをホームポジションに @gimbal_steps = 0 end end def perform_common_math(x, y) x + y end gimbal = Gimbal.new gimbal.home_gimbal gimbal.move(100) gimbal.move(200) puts &quot;Moved gimbal #{gimbal.gimbal_steps}&quot; result = perform_common_math(gimbal.gimbal_steps, 10) puts &quot;Math:#{result}&quot;   Python:  class Gimbal: def __init__(self): self.gimbal_steps = 0 def move(self, steps_to_move): # ジンバルを動かす self.gimbal_steps += steps_to_move def home_gimbal(self): # ジンバルをホームポジションに self.gimbal_steps = 0 def perform_common_math(x, y): return x + y gimbal = Gimbal() gimbal.home_gimbal() gimbal.move(100) gimbal.move(200) print(f&quot;Moved gimbal {gimbal.gimbal_steps}&quot;) result = perform_common_math(gimbal.gimbal_steps, 10) print(f&quot;Math:{result}&quot;)   ","version":"次へ","tagName":"h3"},{"title":"インストルメント化された行と非インストルメント化された行（requireとload）​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#インストルメント化された行と非インストルメント化された行requireとload","content":" COSMOSスクリプトは通常「インストルメント化」されています。これは、各行に主に現在実行中の行をハイライトし、wait_checkのような何かが失敗した場合に例外をキャッチするコードが裏側で追加されていることを意味します。スクリプトで他のファイルのコードを使用する必要がある場合、そのコードを取り込むためにいくつかの方法があります。一部の手法はインストルメント化されたコードを取り込み、他の手法は非インストルメント化されたコードを取り込みます。両方を使用する理由があります。  load_utility（および非推奨のrequire_utility）は、他のファイルからインストルメント化されたコードを取り込みます。COSMOSが他のファイルのコードを実行するとき、Script Runnerは他のファイルに移動し、実行時に各行をハイライト表示します。これは他のファイルを取り込むためのデフォルトの方法であるべきです。何かが失敗した場合に継続することができ、オペレーターによりよい可視性を提供するためです。  しかし、時には他のファイルからのコード実行を表示したくない場合もあります。外部で開発されたライブラリは一般的にインストルメント化されることを好まず、大きなループを含むコードや行のハイライト表示時に時間がかかるコードは、インストルメント化されていないメソッドに含めるとはるかに高速になります。Rubyは非インストルメント化されたコードを取り込むための2つの方法を提供しています。1つ目は「load」キーワードです。loadは別のファイルからコードを取り込み、ファイルが更新された場合は次のload呼び出し時にその変更を取り込みます。「require」はloadに似ていますが、別のファイルからコードを一度だけ取り込むように最適化されています。したがって、requireを使用してからrequireするファイルを変更する場合、ファイルを再度requireして変更を取り込むためにはScript Runnerを再起動する必要があります。一般的に、COSMOSスクリプティングではrequireよりもloadが推奨されます。loadの1つの注意点は、拡張子を含む完全なファイル名が必要なのに対し、requireキーワードはそれを必要としないことです。  Pythonでは、ライブラリはimport構文を使用して含まれます。importを使用してインポートされたコードはインストルメント化されません。load_utilityを使用してインポートされたコードのみがインストルメント化されます。  最後に、COSMOSスクリプティングには、インストルメント化されたスクリプトの途中でインストルメント化を無効にするための特別な構文があり、それはdisable_instrumentationメソッドです。これにより、インストルメント化された状態で実行すると遅すぎる大きなループやその他のアクティビティのインストルメント化を無効にすることができます。  Ruby:  temp = 0 disable_instrumentation do # ここでは例外を投げる可能性のあるものが何もないことを確認してください！ 5000000.times do temp += 1 end end puts temp   Python:  temp = 0 with disable_instrumentation(): # ここでは例外を投げる可能性のあるものが何もないことを確認してください！ for x in range(0,5000000): temp += 1 print(temp)   非インストルメント化されたコードを実行する際 コードが例外を発生させたり、チェックが失敗したりしないことを確認してください。非インストルメント化されたコードから例外が発生した場合、スクリプト全体が停止します。  ","version":"次へ","tagName":"h3"},{"title":"デバッグと監査​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#デバッグと監査","content":" ","version":"次へ","tagName":"h2"},{"title":"組み込みデバッグ機能​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#組み込みデバッグ機能","content":" Script Runnerには、スクリプトが特定の動作をしている理由を判断するのに役立つ組み込みのデバッグ機能があります。特に重要なのは、スクリプト変数を検査して設定する能力です。  デバッグ機能を使用するには、まずスクリプトメニューから「Toggle Debug」オプションを選択します。これにより、ツールの下部に小さなDebug:プロンプトが追加されます。このプロンプトに入力されたコードは、Enterが押されると実行されます。実行中のスクリプトの変数を検査するには、スクリプトを一時停止してから、変数名を入力して変数の値をデバッグプロンプトに表示します。  variable_name   変数は単に等号を使用して設定することもできます。  variable_name = 5   必要に応じて、デバッグプロンプトから通常のコマンディングメソッドを使用してコマンドを挿入することもできます。これらのコマンドはScript Runnerメッセージログに記録されます。これは、CmdSender（コマンドはCmdTlmServerメッセージログにのみ記録される）のような別のCOSMOSツールを使用するよりも有利かもしれません。  cmd(&quot;INST COLLECT with TYPE NORMAL&quot;)   デバッグプロンプトはコマンド履歴を保持し、上下の矢印を使用して履歴をスクロールできることに注意してください。  ","version":"次へ","tagName":"h3"},{"title":"ブレークポイント​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#ブレークポイント","content":" Script Runnerで行番号（左側のガター）をクリックしてブレークポイントを追加できます。スクリプトはブレークポイントに到達すると自動的に一時停止します。ブレークポイントで停止したら、Debug行を使用して変数を評価できます。  ","version":"次へ","tagName":"h3"},{"title":"切断モードの使用​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#切断モードの使用","content":" 切断モードは、実際のハードウェアがループに入っていない環境でスクリプトをテストできるScript Runnerの機能です。切断モードはスクリプト -&gt; Toggle Disconnectを選択して開始します。選択すると、ユーザーは切断するターゲットを選択するよう求められます。デフォルトでは、すべてのターゲットが切断され、実際のハードウェアなしでスクリプトをテストできます。オプションで、ターゲットのサブセットのみを選択することができ、これは部分的に統合された環境でスクリプトを試すのに役立ちます。  切断モードでは、切断されたターゲットへのコマンドは常に成功します。さらに、切断されたターゲットのテレメトリのすべてのチェックはすぐに成功します。これにより、ハードウェアの動作や適切な機能を心配することなく、論理エラーやその他のスクリプト固有のエラーについてプロシージャを素早く実行できます。  ","version":"次へ","tagName":"h3"},{"title":"スクリプトの監査​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#スクリプトの監査","content":" Script Runnerには、実行前後にスクリプトを監査するためのいくつかのツールが含まれています。  Ruby構文チェック​  Ruby構文チェックツールはスクリプトメニューにあります。このツールは-cフラグを付けたruby実行可能ファイルを使用して、スクリプトの構文チェックを実行します。構文エラーが見つかった場合、Rubyインタープリタが提示する正確なメッセージがユーザーに表示されます。これらは暗号のように見えることがありますが、最も一般的な問題は、引用符で囲まれた文字列を閉じていない、「end」キーワードを忘れている、またはブロックを使用しているが前の「do」キーワードを忘れているなどです。  ","version":"次へ","tagName":"h3"},{"title":"一般的なシナリオ​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#一般的なシナリオ","content":" ","version":"次へ","tagName":"h2"},{"title":"ユーザー入力のベストプラクティス​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#ユーザー入力のベストプラクティス","content":" COSMOSはスクリプトで手動ユーザー入力を収集するためのいくつかの異なるメソッドを提供しています。任意の値を許可するユーザー入力メソッド（ask()やask_string()など）を使用する場合は、先に進む前にスクリプトで与えられた値を検証することが非常に重要です。テキスト入力を求める場合は、大文字小文字の可能性に対処し、無効な入力でユーザーに再度プロンプトを表示するか安全なパスを取ることを確実にすることが特に重要です。  Ruby:  answer = ask_string(&quot;続行しますか (y/n)?&quot;) if answer != 'y' and answer != 'Y' raise &quot;ユーザーが入力: #{answer}&quot; end temp = 0.0 while temp &lt; 10.0 or temp &gt; 50.0 temp = ask(&quot;10.0から50.0の間の希望温度を入力してください&quot;) end   Python:  answer = ask_string(&quot;続行しますか (y/n)?&quot;) if answer != 'y' and answer != 'Y': raise RuntimeError(f&quot;ユーザーが入力: {answer}&quot;) temp = 0.0 while temp &lt; 10.0 or temp &gt; 50.0: temp = ask(&quot;10.0から50.0の間の希望温度を入力してください&quot;)   可能な場合は、常にユーザーに制約された選択肢のリストを持つ他のユーザー入力メソッド（message_box、vertical_message_box、combo_box）を使用してください。  これらのすべてのユーザー入力メソッドは、ユーザーに「キャンセル (Cancel)」オプションを提供することに注意してください。キャンセルがクリックされると、スクリプトは一時停止しますが、ユーザー入力行に留まります。「Go」を押して続行すると、ユーザーは値を入力するよう再度求められます。  ","version":"次へ","tagName":"h3"},{"title":"条件付きで手動ユーザー入力ステップを要求する​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#条件付きで手動ユーザー入力ステップを要求する","content":" 可能な場合、ユーザー入力を求めることなく実行できるようにスクリプトを書くことは有用な設計パターンです。これにより、スクリプトがより簡単にテストでき、ユーザー入力の選択や値に対して文書化されたデフォルト値が提供されます。このパターンを実装するには、ask()、prompt()、無限wait()ステートメントなどのすべての手動ステップを、RubyではRuby $manual、Pythonでは RunningScript.manual の値をチェックするif文でラップする必要があります。変数が設定されている場合は手動ステップを実行し、そうでない場合はデフォルト値を使用します。  Ruby例:  if $manual temp = ask(&quot;温度を入力してください&quot;) else temp = 20.0 end if !$manual puts &quot;自動モードでは無限待機をスキップします&quot; else wait end   Python例:  if RunningScript.manual: temp = ask(&quot;温度を入力してください&quot;) else: temp = 20.0 if not RunningScript.manual: print(&quot;自動モードでは無限待機をスキップします&quot;) else: wait()   スイートを実行する場合、ツールの上部に「手動 (Manual)」というチェックボックスがあり、この$manual変数に直接影響します。  ","version":"次へ","tagName":"h3"},{"title":"レポートに追加情報を出力する​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#レポートに追加情報を出力する","content":" COSMOSスクリプトランナーは、スクリプトスイートで動作する際に、各スクリプトのPASS/FAILED/SKIPPEDの状態を示すレポートを自動的に生成します。以下の例のように、このレポートに任意のテキストを挿入することもできます。あるいは、シンプルにprintを使用してScript Runnerメッセージログにテキストを出力することもできます。  Ruby:  class MyGroup &lt; OpenC3::Group def script_1 # 以下のテキストはレポートに配置されます OpenC3::Group.puts &quot;要件304、306、310を検証します&quot; # このputs行はsr_messagesログファイルに表示されます puts &quot;script_1完了&quot; end end   Python:  from openc3.script.suite import Group class MyGroup(Group): def script_1(): # 以下のテキストはレポートに配置されます Group.print(&quot;要件304、306、310を検証します&quot;) # このputs行はsr_messagesログファイルに表示されます print(&quot;script_1完了&quot;)   ","version":"次へ","tagName":"h3"},{"title":"複数のパケットからテレメトリポイントの最新値を取得する​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#複数のパケットからテレメトリポイントの最新値を取得する","content":" 一部のシステムには、すべてのパケットに同じ名前の高レートデータポイントが含まれています。COSMOSは、LATESTという特別なパケット名を使用して、複数のパケットに含まれるテレメトリポイントの最新値を取得することをサポートしています。ターゲットINSTにPACKET1とPACKET2の2つのパケットがあるとします。両方のパケットにはTEMPというテレメトリポイントがあります。  # 最も最近受信したPACKET1からTEMPの値を取得 value = tlm(&quot;INST PACKET1 TEMP&quot;) # 最も最近受信したPACKET2からTEMPの値を取得 value = tlm(&quot;INST PACKET2 TEMP&quot;) # 最も最近受信したPACKET1またはPACKET2からTEMPの値を取得 value = tlm(&quot;INST LATEST TEMP&quot;)   ","version":"次へ","tagName":"h3"},{"title":"テレメトリポイントのすべてのサンプルをチェックする​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#テレメトリポイントのすべてのサンプルをチェックする","content":" COSMOSスクリプトを書く際、テレメトリポイントの最新の値をチェックすることで通常は仕事が完了します。tlm()、tlm_raw()などのメソッドはすべて、テレメトリポイントの最新の値を取得します。テレメトリポイントのすべてのサンプルに対して分析を実行する必要がある場合もあります。これはCOSMOSパケットサブスクリプションシステムを使用して行うことができます。パケットサブスクリプションシステムでは、1つまたは複数のパケットを選択し、それらをすべてキューから受信することができます。その後、各パケットから関心のある特定のテレメトリポイントを選び出すことができます。  Ruby:  id = subscribe_packets([['INST', 'HEALTH_STATUS'], ['INST', 'ADCS']]) wait 1.5 id, packets = get_packets(id) packets.each do |packet| puts &quot;#{packet['PACKET_TIMESECONDS']}: #{packet['target_name']} #{packet['packet_name']}&quot; end # しばらく待ってから、最後に返されたIDを再利用 id, packets = get_packets(id)   Python:  id = subscribe_packets([['INST', 'HEALTH_STATUS'], ['INST', 'ADCS']]) wait(1.5) id, packets = get_packets(id) for packet in packets: print(f&quot;{packet['PACKET_TIMESECONDS']}: {packet['target_name']} {packet['packet_name']}&quot;) # しばらく待ってから、最後に返されたIDを再利用 id, packets = get_packets(id)   ","version":"次へ","tagName":"h3"},{"title":"ニーモニックで変数を使用する​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#ニーモニックで変数を使用する","content":" コマンドとテレメトリのニーモニックはCOSMOSスクリプトの単なる文字列なので、一部のコンテキストでは変数を利用して再利用可能なコードを作成できます。例えば、メソッドはターゲット名を入力として受け取り、ターゲットの複数のインスタンスをサポートできます。番号付きテレメトリポイントのセットの値を渡すこともできます。  Ruby:  def example(target_name, temp_number) cmd(&quot;#{target_name} COLLECT with TYPE NORMAL&quot;) wait_check(&quot;#{target_name} TEMP#{temp_number} &gt; 50.0&quot;) end   Python:  def example(target_name, temp_number): cmd(f&quot;{target_name} COLLECT with TYPE NORMAL&quot;) wait_check(f&quot;{target_name} TEMP{temp_number} &gt; 50.0&quot;)   これは、番号付けされたテレメトリポイントのセットをループ処理する場合にも役立ちますが、ループ vs アンロールされたループセクションで説明したループのデメリットに注意してください。  ","version":"次へ","tagName":"h3"},{"title":"カスタムwait_check_expressionの使用​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#カスタムwait_check_expressionの使用","content":" COSMOSのwait_check_expression（およびcheck_expression）を使用すると、より複雑なチェックを実行し、それでも何かがうまくいかなかった場合にCHECKエラーメッセージでスクリプトを停止させることができます。例えば、変数同士をチェックしたり、テレメトリポイントを範囲に対してチェックしたりできます。wait_check_expressionに渡される正確なテキスト文字列は、パスするか、タイムアウトが発生するまで繰り返し評価されます。実際の式内で文字列補間を使用しないことが重要です。そうしないと、文字列補間構文内の値は文字列に変換されるときに1回だけ評価されます。  Ruby:  one = 1 two = 2 wait_check_expression(&quot;one == two&quot;, 1) # エラー: CHECK: one == two は 1.017035 秒待機後にFALSEです # 整数範囲のチェック wait_check_expression(&quot;one &gt; 0 and one &lt; 10 # 初期値 one = #{one}&quot;, 1)   Python:  one = 1 two = 2 wait_check_expression(&quot;one == two&quot;, 1, 0.25, locals()) # エラー: CHECK: one == two は 1.017035 秒待機後にFALSEです # 整数範囲のチェック wait_check_expression(&quot;one &gt; 0 and one &lt; 10&quot;, 1, 0.25, locals())   ","version":"次へ","tagName":"h3"},{"title":"通常のRubyスクリプティングとCOSMOSスクリプティングの違い​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#通常のrubyスクリプティングとcosmosスクリプティングの違い","content":" 単一行のif文を使用しないでください​  COSMOSスクリプティングは、何かがうまくいかなかった場合に例外をキャッチするために各行をインストルメント化します。単一行のif文では、例外処理がステートメントのどの部分が失敗したかを知ることができず、適切に継続できません。単一行のif文で例外が発生すると、スクリプト全体が停止し、継続できなくなります。COSMOSスクリプトでは単一行のif文を使用しないでください（ただし、インターフェースやその他のRubyコードでは使用しても問題ありません。COSMOSスクリプトだけでは使用しないでください）。  次のようにしないでください：  run_method() if tlm(&quot;INST HEALTH_STATUS TEMP1&quot;) &gt; 10.0   代わりに次のようにしてください：  # if文の中で失敗する可能性のあるコードを実行しないのがベストです # tlm()は、CmdTlmServerが実行されていなかったり、ニーモニックのスペルが間違っていたりすると失敗する可能性があります temp1 = tlm(&quot;INST HEALTH_STATUS TEMP1&quot;) if temp1 &gt; 10.0 run_method() end   ","version":"次へ","tagName":"h3"},{"title":"問題が発生した場合​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#問題が発生した場合","content":" ","version":"次へ","tagName":"h2"},{"title":"チェックが失敗する一般的な理由​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#チェックが失敗する一般的な理由","content":" COSMOSスクリプトでチェックが失敗する一般的な理由は3つあります：  遅延が短すぎた wait_check()メソッドは、参照されるテレメトリポイントがチェックに合格するまで待機する時間を示すタイムアウトを取ります。タイムアウトは、テスト対象のシステムがアクションを完了し、更新されたテレメトリを受信するのに十分な長さである必要があります。チェックが正常に完了するとすぐにスクリプトが続行されることに注意してください。したがって、より長いタイムアウトの唯一のペナルティは、失敗条件での追加の待機時間です。 チェックされた範囲または値が不正確または厳しすぎた 実際のテレメトリ値は問題ないが、チェックされた期待値が厳しすぎることがよくあります。意味のある場合はチェックの範囲を緩めてください。浮動小数点数をチェックする場合は、スクリプトがwait_check_tolerance()ルーチンを使用していることを確認し、適切な許容値を使用していることを確認してください。 チェックが本当に失敗した もちろん、実際の失敗が発生することもあります。次のセクションでは、それらを処理して回復する方法を説明します。  ","version":"次へ","tagName":"h3"},{"title":"異常からの回復方法​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#異常からの回復方法","content":" 何かが失敗し、スクリプトがピンク色でハイライトされた行で停止した後、どのように回復できますか？幸いなことに、COSMOSはスクリプトで何かが失敗した後に回復するために使用できるいくつかのメカニズムを提供しています。  再試行 失敗後、Script Runnerの「一時停止 (Pause)」ボタンは「再試行 (Retry)」に変わります。「再試行 (Retry)」ボタンをクリックすると、失敗した行が再実行されます。タイミングの問題による失敗の場合、これにより問題が解決され、スクリプトを続行できることがよくあります。失敗に注意し、次回の実行前にスクリプトを更新するようにしてください。 デバッグプロンプトの使用 Script -&gt; Toggle Debugを選択することで、実行中のスクリプトを停止せずに状況を修正するために必要な任意のアクションを実行できます。また、なぜ何かが失敗したかを判断するために変数を検査することもできます。 選択実行 スクリプトの一部のみを実行する必要がある場合は、「選択実行 (Execute Selection)」を使用してスクリプトの一部のみを実行できます。これはスクリプトが一時停止しているか、エラーで停止している場合にも使用できます。 ここから実行 スクリプトをクリックし、右クリックして「ここから実行 (Run from here)」を選択することで、ユーザーは任意の点からスクリプトを再開できます。これは、スクリプトの前半に必要な変数定義が存在しない場合に適しています。  ","version":"次へ","tagName":"h3"},{"title":"高度なトピック​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#高度なトピック","content":" ","version":"次へ","tagName":"h2"},{"title":"CSVまたはExcelを使用した高度なスクリプト設定​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#csvまたはexcelを使用した高度なスクリプト設定","content":" スプレッドシートを使用してスクリプトで使用する値を保存することは、CM制御されたスクリプトがあるがテストのために一部の値を調整する必要がある場合や、異なるシリアル番号に対して異なる値を使用する必要がある場合に優れたオプションとなります。  Ruby CSVクラスを使用すると、CSVファイルからデータを簡単に読み取ることができます（クロスプラットフォームプロジェクトに推奨）。  require 'csv' values = CSV.read('test.csv') puts values[0][0]   Windowsのみを使用している場合、COSMOSにはExcelファイルを読み取るためのライブラリも含まれています。  require 'openc3/win32/excel' ss = ExcelSpreadsheet.new('C:/git/cosmos/test.xlsx') puts ss[0][0][0]   ","version":"次へ","tagName":"h3"},{"title":"Rubyモジュールの使用タイミング​","type":1,"pageTitle":"スクリプト作成ガイド","url":"/ja/docs/guides/script-writing#rubyモジュールの使用タイミング","content":" Rubyのモジュールには2つの目的があります：名前空間とミックスイン。名前空間は、同じ名前で意味の異なるクラスやメソッドを持つことを可能にします。例えば、名前空間を使用すれば、COSMOSはPacketクラスを持ち、別のRubyライブラリもPacketクラスを持つことができます。ただし、これはCOSMOSスクリプティングには通常役立ちません。  ミックスインは継承を使用せずにクラスに共通のメソッドを追加することを可能にします。ミックスインは、一部のクラスに共通の機能を追加し、他のクラスには追加しない場合や、クラスを複数のファイルに分割する場合に役立ちます。  module MyModule def module_method end end class MyTest &lt; OpenC3::Group include MyModule def test_1 module_method() end end  ","version":"次へ","tagName":"h3"},{"title":"コマンドとテレメトリサーバー","type":0,"sectionRef":"#","url":"/ja/docs/tools/cmd-tlm-server","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"コマンドとテレメトリサーバー","url":"/ja/docs/tools/cmd-tlm-server#はじめに","content":" コマンドとテレメトリサーバーアプリケーションは、COSMOSインストールでインスタンス化されたインターフェースとターゲットに関するステータスを提供します。インターフェースは接続または切断でき、生のバイト数が返されます。このアプリケーションは、COSMOSシステムを通過する際の生のフォーマットされたコマンドとテレメトリパケットの両方を表示するための迅速なショートカットも提供します。コマンドとテレメトリサーバーの下部には、サーバーメッセージを表示するログメッセージがあります。    ","version":"次へ","tagName":"h2"},{"title":"コマンドとテレメトリサーバーのメニュー​","type":1,"pageTitle":"コマンドとテレメトリサーバー","url":"/ja/docs/tools/cmd-tlm-server#コマンドとテレメトリサーバーのメニュー","content":" ","version":"次へ","tagName":"h2"},{"title":"ファイルメニュー項目​","type":1,"pageTitle":"コマンドとテレメトリサーバー","url":"/ja/docs/tools/cmd-tlm-server#ファイルメニュー項目","content":" コマンドとテレメトリサーバーには、ファイル (File) -&gt; オプション (Options) の下に1つのメニューがあります：    このダイアログは、ブラウザウィンドウとバックエンドサーバーの両方の負荷を軽減するために、コマンドとテレメトリサーバーの更新レートを変更します。これにより、アプリケーション内のさまざまなタブの更新レートが変更されることに注意してください。ログメッセージは、メッセージが生成されると引き続き更新されます。  ","version":"次へ","tagName":"h3"},{"title":"インターフェースタブ​","type":1,"pageTitle":"コマンドとテレメトリサーバー","url":"/ja/docs/tools/cmd-tlm-server#インターフェースタブ","content":" インターフェースタブは、COSMOSインストールで定義されたすべてのインターフェースを表示します。インターフェースを接続または切断し、生のバイトとパケット数を表示できます。    ","version":"次へ","tagName":"h2"},{"title":"ターゲットタブ​","type":1,"pageTitle":"コマンドとテレメトリサーバー","url":"/ja/docs/tools/cmd-tlm-server#ターゲットタブ","content":" ターゲットタブは、すべてのターゲットとそれらにマッピングされたインターフェース、およびコマンド権限のステータス（Enterpriseのみ）を表示します。    コマンド権限は管理コンソールで有効にされ、スコープ全体で有効になります。コマンド権限が有効になると、個々のユーザーはコマンド権限を与えたり取り消したりできるようになり、そのターゲットへの排他的なコマンドとスクリプトアクセスが可能になります。コマンド権限がなければ、ユーザーはそのターゲットでコマンドを送信したりスクリプトを開始したりすることはできません。なお、カレンダーやオートノミックでスケジュールされたコマンドやスクリプトはコマンド権限の影響を受けません。    スコープリストに表示されるもう一つのオプションは、クリティカルコマンドモードです。クリティカルコマンドでは、各コマンドを承認する別のユーザーが必要です。HAZARDOUSとRESTRICTEDコマンドのみ、または全ての手動コマンドに対して有効にすることができます。  以下は、クリティカルコマンドモードがNORMALに設定されている場合に、コマンドセンダーでHAZARDOUSコマンドを送信する例です。    ","version":"次へ","tagName":"h2"},{"title":"コマンドパケットタブ​","type":1,"pageTitle":"コマンドとテレメトリサーバー","url":"/ja/docs/tools/cmd-tlm-server#コマンドパケットタブ","content":" コマンドパケットタブは、利用可能なすべてのコマンドを表示します。テーブルは列ヘッダーをクリックすることでソートできます。テーブルはページ分割されており、何千ものコマンドをサポートしています。検索バーはすべてのページからコマンドを検索します。    「生表示 (View Raw)」をクリックすると、そのコマンドの生バイトを表示するダイアログが開きます。    「コマンドセンダーで表示 (View in Command Sender)」をクリックすると、指定されたコマンドで新しいコマンドセンダーウィンドウが開きます。  ","version":"次へ","tagName":"h2"},{"title":"テレメトリパケットタブ​","type":1,"pageTitle":"コマンドとテレメトリサーバー","url":"/ja/docs/tools/cmd-tlm-server#テレメトリパケットタブ","content":" テレメトリパケットタブは、利用可能なすべてのテレメトリを表示します。テーブルは列ヘッダーをクリックすることでソートできます。テーブルはページ分割されており、何千ものテレメトリパケットをサポートしています。検索バーはすべてのページからテレメトリパケットを検索します。    「生表示 (View Raw)」をクリックすると、そのテレメトリパケットの生バイトを表示するダイアログが開きます。    「パケットビューアで表示 (View in Packet Viewer)」をクリックすると、指定されたテレメトリパケットで新しいパケットビューアウィンドウが開きます。  ","version":"次へ","tagName":"h2"},{"title":"ステータスタブ​","type":1,"pageTitle":"コマンドとテレメトリサーバー","url":"/ja/docs/tools/cmd-tlm-server#ステータスタブ","content":" ステータスタブはCOSMOSシステムメトリクスを表示します。    ","version":"次へ","tagName":"h2"},{"title":"ログメッセージ​","type":1,"pageTitle":"コマンドとテレメトリサーバー","url":"/ja/docs/tools/cmd-tlm-server#ログメッセージ","content":" ログメッセージテーブルは、コマンドとテレメトリサーバーアプリケーションのすべてのタブの下に位置しています。リミットイベント（新しいRED、YELLOW、GREEN値）、ロギングイベント（新しいファイル）、インターフェースイベント（接続と切断）などのサーバーメッセージを表示します。重大度でフィルタリングしたり、検索ボックスに値を入力することでフィルタリングできます。また、一時停止や再開を行って個々のメッセージを検査することもできます。   ","version":"次へ","tagName":"h2"},{"title":"テレメトリビューア","type":0,"sectionRef":"#","url":"/ja/docs/tools/tlm-viewer","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"テレメトリビューア","url":"/ja/docs/tools/tlm-viewer#はじめに","content":" テレメトリビューアは、カスタム構築されたスクリーンを表示するライブテレメトリビューアです。スクリーンは、多数の組み込みウィジェットを利用した簡単なテキストファイルを通じて設定されます。    ","version":"次へ","tagName":"h2"},{"title":"ファイルメニュー項目​","type":1,"pageTitle":"テレメトリビューア","url":"/ja/docs/tools/tlm-viewer#ファイルメニュー項目","content":"   保存された設定を開く現在の設定を保存設定をリセット（デフォルト設定）  設定を開く​  設定を開くダイアログでは、保存されたすべての設定のリストが表示されます。設定を選択し、OKをクリックしてロードします。設定名の横にあるゴミ箱アイコンをクリックして、既存の設定を削除できます。  設定を保存​  設定を保存ダイアログでも、保存されたすべての設定のリストが表示されます。設定名テキストフィールドをクリックし、新しい設定の名前を入力し、OKをクリックして保存します。設定名の横にあるゴミ箱アイコンをクリックして、既存の設定を削除できます。  ","version":"次へ","tagName":"h3"},{"title":"スクリーンの選択​","type":1,"pageTitle":"テレメトリビューア","url":"/ja/docs/tools/tlm-viewer#スクリーンの選択","content":" ターゲットの選択ドロップダウンからターゲットを選択すると、スクリーンの選択ドロップダウンにそのターゲットで利用可能なスクリーンが自動的に更新されます。スクリーンを表示をクリックすると、そのスクリーンが表示されます。  ","version":"次へ","tagName":"h2"},{"title":"新規スクリーン​","type":1,"pageTitle":"テレメトリビューア","url":"/ja/docs/tools/tlm-viewer#新規スクリーン","content":" 新規スクリーンをクリックすると、新規スクリーンダイアログが表示されます。    スクリーンはターゲットによって所有されているため、ターゲットの選択ではスクリーンが作成される場所を選択します。スクリーンはパケットに基づくことができ、その特定のパケット内のすべての項目がパケットビューアに似た単純な垂直スクリーンに生成されます。これはスクリーンをカスタマイズするための良い出発点です。スクリーン名は一意である必要があるため、「ADCS」スクリーンがすでに存在するため、スクリーン名は「adcs2」に設定されていることに注意してください。  ","version":"次へ","tagName":"h2"},{"title":"スクリーンの編集​","type":1,"pageTitle":"テレメトリビューア","url":"/ja/docs/tools/tlm-viewer#スクリーンの編集","content":" スクリーンのタイトルバーの鉛筆アイコンをクリックすると、編集ダイアログが表示されます。    スクリーンのソースは、構文強調表示と自動補完機能を備えたエディタに表示されます。右上のダウンロードボタンを使用してスクリーンソースをダウンロードしたり、左上のゴミ箱アイコンを使用してスクリーンを削除したりできます。保存をクリックしてスクリーンの編集を保存すると、テレメトリビューアはスクリーンを再レンダリングします。  ","version":"次へ","tagName":"h2"},{"title":"スクリーンウィンドウの管理​","type":1,"pageTitle":"テレメトリビューア","url":"/ja/docs/tools/tlm-viewer#スクリーンウィンドウの管理","content":" すべてのスクリーンは、タイトルバーをクリックして移動することで、ブラウザウィンドウ内を移動できます。他のスクリーンはスペースを埋めるために効率良く移動します。これにより、作成順に関係なく、スクリーンを並べ替えることができます。  タイトルバーの左上にあるグリッドアイコンをクリックして、スクリーンをフロートさせることもできます。風船アイコンに変わり、上下をクリックしてウィンドウの相対的なZインデックスを変更できるようになります。以下のスクリーンショットでは、画像スクリーンがフロートしています。  タイトルバーの右上にあるダッシュボタンは、スクリーンを最小化して効果的に隠します。これにより、既存のスクリーンを閉じることなく、単一のスクリーンに集中できます。以下のスクリーンショットでは、一番下に2つの最小化されたウィンドウがあります。    Xボタンはスクリーンを閉じます。  ","version":"次へ","tagName":"h2"},{"title":"スクリーンの構築​","type":1,"pageTitle":"テレメトリビューア","url":"/ja/docs/tools/tlm-viewer#スクリーンの構築","content":" テレメトリスクリーンの構築方法とスクリーンウィジェットの設定方法については、テレメトリスクリーンのドキュメントを参照してください。 ","version":"次へ","tagName":"h2"},{"title":"リミットモニター","type":0,"sectionRef":"#","url":"/ja/docs/tools/limits-monitor","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"リミットモニター","url":"/ja/docs/tools/limits-monitor#はじめに","content":" リミットモニターアプリケーションは、制限値を持つすべてのテレメトリ項目の状況認識を提供します。黄色または赤の制限値に違反するすべての制限項目が表示され、明示的に消去されるまで表示され続けます。個々の項目やパケット全体を手動で無視して、既知の問題をフィルタリングすることができます。さらに、すべての制限イベントはテーブルに記録され、検索可能です。    ","version":"次へ","tagName":"h2"},{"title":"リミットモニターのメニュー​","type":1,"pageTitle":"リミットモニター","url":"/ja/docs/tools/limits-monitor#リミットモニターのメニュー","content":" ","version":"次へ","tagName":"h2"},{"title":"ファイルメニュー項目​","type":1,"pageTitle":"リミットモニター","url":"/ja/docs/tools/limits-monitor#ファイルメニュー項目","content":"   無視された項目のリストを表示COSMOSの全体的な制限セットを変更保存された設定を開く現在の設定（無視された項目）を保存設定をリセット（デフォルト設定）  無視された項目を表示​  このダイアログは、制限を超えた項目の横にある無視アイコンをクリックして、ユーザーが手動で無視したすべての項目を表示します。無視されたパケット全体はターゲットパケットとして項目なしでリストされることに注意してください（INST MECHのように表示されます）。無視された項目はゴミ箱アイコンをクリックすることで削除されます。これは、この項目が次回制限を超えると表示されることを意味します。    制限セットの変更​  制限セットはテレメトリ項目のLIMITSキーワードで定義されます。各項目には少なくとも DEFAULT 制限セットが必要ですが、他の名前付き制限セットを持つこともできます。COSMOSは一度に1つの制限セットのみをアクティブにします。このダイアログでは、ユーザーがアクティブな制限セットを変更し、COSMOS全体に新しい制限値を適用することができます。    設定を開く​  設定を開くダイアログでは、保存されたすべての設定のリストが表示されます。設定を選択し、OKをクリックしてロードします。設定名の横にあるゴミ箱アイコンをクリックして、既存の設定を削除できます。  設定を保存​  設定を保存ダイアログでも、保存されたすべての設定のリストが表示されます。設定名テキストフィールドをクリックし、新しい設定の名前を入力し、OKをクリックして保存します。設定名の横にあるゴミ箱アイコンをクリックして、既存の設定を削除できます。  ","version":"次へ","tagName":"h3"},{"title":"制限項目​","type":1,"pageTitle":"リミットモニター","url":"/ja/docs/tools/limits-monitor#制限項目","content":" リミットモニターの主要なインターフェースは、黄色または赤の制限に違反した場合に項目が表示される上部です。    制限値を持つ項目は、定義された制限内で現在の値がどこにあるかを表示する赤黄緑の制限バーを使用して表示されます（様々なTEMP項目で示されています）。黄色または赤の状態を持つ項目は、単にその状態の色で表示されます（GROUND1STATUSで示されています）。COSMOS Demoには、異なるターゲットパケット内の同一名の項目であるINST HEALTH_STATUS TEMP2とINST2 HEALTH_STATUS TEMP2の両方が含まれています。リミットモニターはスペースを節約するために項目名のみを表示しますが、値ボックスにマウスを合わせると、ターゲットとパケットの完全な名前が表示されます。  最初のネストされた「X」アイコンをクリックすると、項目が存在するパケット全体が無視されます。そのパケット内の制限を超える追加の項目もリミットモニターによって無視されます。2番目（中央）の「X」をクリックすると、その特定の項目「のみ」が無視されます。パケットや項目が無視されている場合、全体的な制限状態は「（一部の項目が無視されています） Some Items Ignored」と表示され、制限状態が無視された項目の影響を受ける可能性があることを示します。  最後のアイコン（取り消し線の付いた目）をクリックすると、指定された項目が一時的に非表示になります。これは項目を無視することとは異なり、この項目が制限を超えると再び表示されます。項目を非表示にすることは、項目が緑に戻り、それを追跡し続けたいが現在の項目リストをクリーンアップしたい場合に便利です。例えば、上記の例でGROUND1STATUS項目が緑に戻ったため、これらを非表示にすることがあります。  ","version":"次へ","tagName":"h2"},{"title":"制限ログ​","type":1,"pageTitle":"リミットモニター","url":"/ja/docs/tools/limits-monitor#制限ログ","content":" ログセクションにはすべての制限イベントがリストされます。イベントは、図のように検索ボックスを使用してフィルタリングできます。   ","version":"次へ","tagName":"h2"},{"title":"バケットエクスプローラー","type":0,"sectionRef":"#","url":"/ja/docs/tools/bucket-explorer","content":"","keywords":"","version":"次へ"},{"title":"はじめに​","type":1,"pageTitle":"バケットエクスプローラー","url":"/ja/docs/tools/bucket-explorer#はじめに","content":" バケットエクスプローラーは、COSMOSバックエンドのバケットストレージシステムへのファイルブラウザです。ファイルブラウザ階層でファイルを閲覧し、ダウンロードすることができます。バケットエクスプローラーは、COSMOSのローカルインストールだけでなく、AWS S3やGCP Cloud Storageなどのクラウドストレージを利用するクラウドデプロイメントでも動作します。    ","version":"次へ","tagName":"h2"},{"title":"ファイルの閲覧​","type":1,"pageTitle":"バケットエクスプローラー","url":"/ja/docs/tools/bucket-explorer#ファイルの閲覧","content":" 上部には標準的なCOSMOSの3つのバケット：config、logs、toolsがあります。各バケットにはスコープ名の最上位フォルダが含まれています。オープンソース版では唯一のスコープはDEFAULTです。configバケットはプラグインがインストールされると設定ファイルが格納されます。logsバケットには、様々なCOSMOSマイクロサービスによって生成されるCOSMOSログが保存されます（詳細はロギングを参照）。これらのログはストレージ容量を節約するためにgzip圧縮されています。toolsバケットには、組み込みのCOSMOSツールのソースコードだけでなく、プラグインとしてインストールされたユーザー作成ツールも格納されています。検索ボックスは現在の画面に表示されているファイルのみを検索し、バケット全体を検索するわけではないことに注意してください。  ツールは静的ウェブサイトとして提供 バケットストレージを使用することで、COSMOSはツールを静的ウェブサイトとして直接提供でき、そのためS3のようなクラウド技術ではパブリックバケットである必要があります  ","version":"次へ","tagName":"h2"},{"title":"アップロード​","type":1,"pageTitle":"バケットエクスプローラー","url":"/ja/docs/tools/bucket-explorer#アップロード","content":" アップロード(Upload)アイコンをクリックすると、現在のバケットとパスにアップロードするファイルを選択するためのファイルブラウザが表示されます。COSMOS Enterpriseでは、管理者でない限りconfig/DEFAULT/targets_modifiedフォルダにのみファイルをアップロードできることに注意してください。  ","version":"次へ","tagName":"h3"},{"title":"ダウンロード​","type":1,"pageTitle":"バケットエクスプローラー","url":"/ja/docs/tools/bucket-explorer#ダウンロード","content":" ダウンロード(Download)アイコンをクリックすると、任意のバケットとパスからファイルをダウンロードできます。  ","version":"次へ","tagName":"h3"},{"title":"削除​","type":1,"pageTitle":"バケットエクスプローラー","url":"/ja/docs/tools/bucket-explorer#削除","content":" ゴミ箱アイコンをクリックして、個々のファイルを削除できます。COSMOS Enterpriseでは、管理者でない限りconfig/DEFAULT/targets_modifiedフォルダ内のファイルのみを削除できることに注意してください。 ","version":"次へ","tagName":"h3"},{"title":"コマンド","type":0,"sectionRef":"#","url":"/ja/docs/configuration/command","content":"","keywords":"","version":"次へ"},{"title":"コマンド定義ファイル​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#コマンド定義ファイル","content":" コマンド定義ファイルは、COSMOSターゲットに送信できるコマンドパケットを定義します。コマンドパケットの定義には、1つの大きなファイルを使用することも、ユーザーの判断で複数のファイルを使用することもできます。コマンド定義ファイルはターゲットのcmd_tlmディレクトリに配置され、アルファベット順に処理されます。そのため、他のコマンドファイルに依存するコマンドファイル（例：既存のコマンドをオーバーライドまたは拡張するファイル）は、最後に名前を付ける必要があります。最も簡単な方法は、既存のファイル名に拡張子を追加することです。例えば、既にcmd.txtがある場合、cmd.txtの定義に依存するコマンドにはcmd_override.txtを作成できます。また、ASCII表の構造上、大文字で始まるファイルは小文字で始まるファイルよりも先に処理されることに注意してください。  コマンドパラメータを定義する際は、次のデータ型から選択できます：INT、UINT、FLOAT、STRING、BLOCK。これらはそれぞれ整数、符号なし整数、浮動小数点数、文字列、バイナリデータブロックに対応しています。STRINGとBLOCKの唯一の違いは、COSMOSがバイナリコマンドログを読み取る際に、STRINGタイプはnullバイト（0）に遭遇すると読み取りを停止することです。これはData Extractorによって生成されるテキストログに表示されます。これはCOSMOSが書き込むデータには影響しないことに注意してください。STRINGパラメータにnullバイト（0）を渡すことは引き続き有効です。    コマンドキーワード  ","version":"次へ","tagName":"h2"},{"title":"COMMAND​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#command","content":" 新しいコマンドパケットを定義する  パラメータ\t説明\t必須Target\tこのコマンドが関連付けられているターゲットの名前\tTrue Command\tこのコマンドの名前。ニーモニックとも呼ばれます。このターゲットへのコマンド内で一意である必要があります。理想的には短く明確であることが望ましいです。\tTrue Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tTrue Description\tこのコマンドの説明（引用符で囲む必要があります）\tFalse  使用例:  COMMAND INST COLLECT BIG_ENDIAN &quot;Start collect&quot;   ","version":"次へ","tagName":"h2"},{"title":"COMMANDの修飾子​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#commandの修飾子","content":" 以下のキーワードはCOMMANDキーワードに続いて使用する必要があります。  ","version":"次へ","tagName":"h2"},{"title":"PARAMETER​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#parameter","content":" 現在のコマンドパケット内のコマンドパラメータを定義する  パラメータ\t説明\t必須Name\tパラメータの名前。コマンド内で一意である必要があります。\tTrue Bit Offset\tこのパラメータの最上位ビットのコマンドパケット内のビットオフセット。パケットの末尾からのオフセットを示すために負の値を使用することもできます。派生パラメータには常にビットオフセット0を使用してください。\tTrue Bit Size\tこのパラメータのビットサイズ。ゼロまたは負の値を使用して、文字列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。Bit Offsetが0でBit Sizeが0の場合、これは派生パラメータであり、Data Typeは'DERIVED'に設定する必要があります。\tTrue Data Type\tこのパラメータのデータ型 有効な値: INT, UINT, FLOAT, DERIVED, STRING, BLOCK\tTrue  Data TypeがINT、UINT、FLOAT、DERIVEDの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Minimum Value\tこのパラメータに許可される最小値\tTrue Maximum Value\tこのパラメータに許可される最大値\tTrue Default Value\tこのパラメータのデフォルト値。デフォルト値を指定する必要がありますが、パラメータをREQUIREDとマークすると、スクリプトは値を指定するよう強制されます。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します。リトルエンディアンビットフィールドのガイドを参照してください。 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  Data TypeがSTRING、BLOCKの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Default Value\tこのパラメータのデフォルト値。デフォルト値を指定する必要がありますが、パラメータをREQUIREDとマークすると、スクリプトは値を指定するよう強制されます。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  使用例:  PARAMETER SYNC 0 32 UINT 0xDEADBEEF 0xDEADBEEF 0xDEADBEEF &quot;Sync pattern&quot; PARAMETER DATA 32 32 INT MIN MAX 0 &quot;Data value&quot; PARAMETER VALUE 64 32 FLOAT 0 10.5 2.5 PARAMETER LABEL 96 96 STRING &quot;OPENC3&quot; &quot;The label to apply&quot; PARAMETER BLOCK 192 0 BLOCK 0x0 &quot;Block of binary data&quot;   ","version":"次へ","tagName":"h3"},{"title":"PARAMETERの修飾子​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#parameterの修飾子","content":" 以下のキーワードはPARAMETERキーワードに続いて使用する必要があります。  FORMAT_STRING​  printfスタイルのフォーマットを追加する  パラメータ\t説明\t必須Format\tprintf構文を使用してフォーマットする方法。例えば、'0x%0X'は値を16進数で表示します。\tTrue  使用例:  FORMAT_STRING &quot;0x%0X&quot;   UNITS​  表示単位を追加する  パラメータ\t説明\t必須Full Name\t単位タイプのフルネーム（例：摂氏）\tTrue Abbreviated\t単位の略称（例：C）\tTrue  使用例:  UNITS Celsius C UNITS Kilometers KM   DESCRIPTION​  定義された説明をオーバーライドする  パラメータ\t説明\t必須Value\t新しい説明\tTrue  META​  カスタムユーザーメタデータを格納する  メタデータは、カスタムツールがさまざまな目的で使用できるユーザー固有のデータです。一例として、ソースコードヘッダーファイルを生成するために必要な追加情報を格納するためのものがあります。  パラメータ\t説明\t必須Meta Name\t格納するメタデータの名前\tTrue Meta Values\tこのMeta Nameに格納する1つ以上の値\tFalse  使用例:  META TEST &quot;This parameter is for test purposes only&quot;   OVERLAP​   (Since 4.4.1) このアイテムはパケット内の他のアイテムと重複することが許可されています   アイテムのビットオフセットが他のアイテムと重複する場合、OpenC3は警告を発します。このキーワードは、アイテムが他のアイテムと重複することを明示的に許可し、警告メッセージを抑制します。  KEY​   (Since 5.0.10) パケット内のこの生の値にアクセスするために使用されるキーを定義します。   キーは多くの場合、JSONPathやXPath文字列です。  パラメータ\t説明\t必須Key string\tこのアイテムにアクセスするためのキー\tTrue  使用例:  KEY $.book.title   VARIABLE_BIT_SIZE​   (Since 5.18.0) アイテムのビットサイズが別の長さアイテムによって定義されていることを示す   パラメータ\t説明\t必須Length Item Name\t関連する長さアイテムの名前\tTrue Length Bits Per Count\t長さアイテムのカウント当たりのビット数。デフォルトは8\tFalse Length Value Bit Offset\t長さフィールド値に適用するビットオフセット。デフォルトは0\tFalse  REQUIRED​  スクリプトでパラメータを必ず指定する必要がある  Script Runner経由でコマンドを送信する際、現在のコマンドパラメータに常に値を指定する必要があります。これにより、ユーザーがデフォルト値に依存することを防ぎます。これはCommand Senderには影響せず、PARAMETER定義で提供されたデフォルト値でフィールドが入力されることに注意してください。  MINIMUM_VALUE​  定義された最小値をオーバーライドする  パラメータ\t説明\t必須Value\tパラメータの新しい最小値\tTrue  MAXIMUM_VALUE​  定義された最大値をオーバーライドする  パラメータ\t説明\t必須Value\tパラメータの新しい最大値\tTrue  DEFAULT_VALUE​  定義されたデフォルト値をオーバーライドする  パラメータ\t説明\t必須Value\tパラメータの新しいデフォルト値\tTrue  STATE​  現在のコマンドパラメータのキー/値ペアを定義する  キー値のペアにより、ユーザーフレンドリーな文字列が可能になります。例えば、ON = 1およびOFF = 0の状態を定義できます。これにより、コマンドパラメータを送信する際に、数字の1ではなく単語「ON」を使用できるようになり、より明確で、ユーザーエラーの可能性が低くなります。  パラメータ\t説明\t必須Key\t文字列の状態名\tTrue Value\t数値の状態値\tTrue Hazardous / Disable Messages\t状態が危険であることを示します。これにより、このコマンドを送信する際にユーザー確認を求めるポップアップが表示されます。危険でない状態の場合、DISABLE_MESSAGESを設定することもでき、その状態を使用する際にコマンドを表示しません。 有効な値: HAZARDOUS\tFalse Hazardous Description\tこの状態が危険である理由を説明する文字列\tFalse  使用例:  APPEND_PARAMETER ENABLE 32 UINT 0 1 0 &quot;Enable setting&quot; STATE FALSE 0 STATE TRUE 1 APPEND_PARAMETER STRING 1024 STRING &quot;NOOP&quot; &quot;String parameter&quot; STATE &quot;NOOP&quot; &quot;NOOP&quot; DISABLE_MESSAGES STATE &quot;ARM LASER&quot; &quot;ARM LASER&quot; HAZARDOUS &quot;Arming the laser is an eye safety hazard&quot; STATE &quot;FIRE LASER&quot; &quot;FIRE LASER&quot; HAZARDOUS &quot;WARNING! Laser will be fired!&quot;   WRITE_CONVERSION​  現在のコマンドパラメータに書き込み時の変換を適用する  変換はカスタムRubyまたはPythonファイルで実装され、ターゲットのlibフォルダーに配置する必要があります。クラスはConversionを継承する必要があります。追加パラメータを取る場合はinitialize（Ruby）または__init__（Python）メソッドを実装する必要があり、常にcallメソッドを実装する必要があります。変換係数は、ユーザーが入力した値にバイナリコマンドパケットに書き込まれて送信される前に適用されます。  書き込み変換を適用する場合、データ型が変更されることがあります。例えば、入力STRING型からUINT型を作成する場合（この例についてはip_write_conversion.rbまたはip_write_conversion.pyを参照）。この場合、コマンド定義のデータ型はUINTであり、最小値・最大値は重要ではない（ただし指定する必要がある）ため、通常はMIN MAXに設定されます。デフォルト値は重要であり、文字列として指定する必要があります。完全な例については、COSMOS DemoのTIME_OFFSETコマンド定義のIP_ADDRESSパラメータを参照してください：INST inst_cmds.txtまたはINST2 inst_cmds.txt。  コマンドパラメータに対する複数の書き込み変換 コマンドが構築されると、各アイテムがデフォルト値を設定するために書き込まれ（このとき書き込み変換が実行されます）、その後、ユーザーが提供した値でアイテムが書き込まれます（ここでも書き込み変換が実行されます）。したがって、書き込み変換は2回実行される可能性があります。また、どのパラメータがすでに書き込まれたかについての保証はありません。パケット自体には、コマンドにユーザーが提供した値のハッシュを取得するためのgiven_values()メソッドがあります。これを使用して渡されたパラメータ値を確認できます。  パラメータ\t説明\t必須Class Filename\tRubyまたはPythonクラスを含むファイル名。ファイル名はクラス名に基づいて命名する必要があり、クラスはアンダースコア付きのファイル名のCamelCase版である必要があります。例えば、'the_great_conversion.rb'は'class TheGreatConversion'を含んでいるべきです。\tTrue Parameter\tクラスコンストラクタに渡される変換の追加パラメータ値。\tFalse  Ruby例:  WRITE_CONVERSION the_great_conversion.rb 1000 Defined in the_great_conversion.rb: require 'openc3/conversions/conversion' module OpenC3 class TheGreatConversion &lt; Conversion def initialize(multiplier) super() @multiplier = multiplier.to_f end def call(value, packet, buffer) return value * multiplier end end end   Python例:  WRITE_CONVERSION the_great_conversion.py 1000 Defined in the_great_conversion.py: from openc3.conversions.conversion import Conversion class TheGreatConversion(Conversion): def __init__(self, multiplier): super().__init__() self.multiplier = float(multiplier) def call(self, value, packet, buffer): return value * self.multiplier   POLY_WRITE_CONVERSION​  現在のコマンドパラメータに多項式変換係数を追加する  変換係数は、ユーザーが入力した値にバイナリコマンドパケットに書き込まれて送信される前に適用されます。  パラメータ\t説明\t必須C0\t係数\tTrue Cx\t変換の追加係数値。任意の次数の多項式変換を使用できるため、「x」の値は多項式の次数によって異なります。より高次の多項式は処理に時間がかかりますが、より精度が高くなることがあります。\tFalse  使用例:  POLY_WRITE_CONVERSION 10 0.5 0.25   SEG_POLY_WRITE_CONVERSION​  現在のコマンドパラメータに区分的多項式変換係数を追加する  この変換係数は、ユーザーが入力した値にバイナリコマンドパケットに書き込まれて送信される前に適用されます。  パラメータ\t説明\t必須Lower Bound\tこの区分的多項式が適用される値の範囲の下限を定義します。最小下限値のセグメントでは無視されます。\tTrue C0\t係数\tTrue Cx\t変換の追加係数値。任意の次数の多項式変換を使用できるため、「x」の値は多項式の次数によって異なります。より高次の多項式は処理に時間がかかりますが、より精度が高くなることがあります。\tFalse  使用例:  SEG_POLY_WRITE_CONVERSION 0 10 0.5 0.25 # Apply the conversion to all values &lt; 50 SEG_POLY_WRITE_CONVERSION 50 11 0.5 0.275 # Apply the conversion to all values &gt;= 50 and &lt; 100 SEG_POLY_WRITE_CONVERSION 100 12 0.5 0.3 # Apply the conversion to all values &gt;= 100   GENERIC_WRITE_CONVERSION_START​  汎用書き込み変換を開始する  現在のコマンドパラメータに汎用変換関数を追加します。 この変換係数は、ユーザーが入力した値にバイナリコマンドパケットに書き込まれて送信される前に適用されます。変換はRubyまたはPythonコードとして指定され、2つの暗黙のパラメータを受け取ります。'value'は書き込まれる生の値であり、'packet'はコマンドパケットクラスへの参照です（注：後方互換性のためにパケットを'myself'として参照することもサポートされています）。コードの最後の行は変換された値を返す必要があります。GENERIC_WRITE_CONVERSION_ENDキーワードは、変換のすべてのコード行が与えられたことを指定します。  コマンドパラメータに対する複数の書き込み変換 コマンドが構築されると、各アイテムがデフォルト値を設定するために書き込まれ（このとき書き込み変換が実行されます）、その後、ユーザーが提供した値でアイテムが書き込まれます（ここでも書き込み変換が実行されます）。したがって、書き込み変換は2回実行される可能性があります。また、どのパラメータがすでに書き込まれたかについての保証はありません。パケット自体には、コマンドにユーザーが提供した値のハッシュを取得するためのgiven_values()メソッドがあります。これを使用して渡されたパラメータ値を確認できます。  警告 汎用変換は長期的な解決策としては適していません。変換クラスを作成してWRITE_CONVERSIONを使用することを検討してください。WRITE_CONVERSIONはデバッグが容易で、パフォーマンスが高いです。  Ruby例:  APPEND_PARAMETER ITEM1 32 UINT 0 0xFFFFFFFF 0 GENERIC_WRITE_CONVERSION_START return (value * 1.5).to_i # Convert the value by a scale factor GENERIC_WRITE_CONVERSION_END   Python例:  APPEND_PARAMETER ITEM1 32 UINT 0 0xFFFFFFFF 0 GENERIC_WRITE_CONVERSION_START return int(value * 1.5) # Convert the value by a scale factor GENERIC_WRITE_CONVERSION_END   GENERIC_WRITE_CONVERSION_END​  汎用書き込み変換を完了する  OVERFLOW​  値を書き込む際に型のオーバーフローが発生した場合の動作を設定する  デフォルトでは、OpenC3は指定された型をオーバーフローする値を書き込もうとするとエラーをスローします（例：8ビット符号付き値に255を書き込む場合）。オーバーフロー動作を設定することで、OpenC3に値を'TRUNCATE'（上位ビットを除外する）させることもできます。また、'SATURATE'を設定することもでき、これによりOpenC3はその型で許容される最大値または最小値に値を置き換えます。最後に、'ERROR_ALLOW_HEX'を指定することもでき、これにより最大16進値を書き込むことが可能になります（例：8ビット符号付き値に255を正常に書き込める）。  パラメータ\t説明\t必須Behavior\tOpenC3がオーバーフロー値をどのように扱うか。符号付きおよび符号なし整数データ型にのみ適用されます。 有効な値: ERROR, ERROR_ALLOW_HEX, TRUNCATE, SATURATE\tTrue  使用例:  OVERFLOW TRUNCATE   ","version":"次へ","tagName":"h3"},{"title":"APPEND_PARAMETER​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#append_parameter","content":" 現在のコマンドパケット内のコマンドパラメータを定義する  パラメータ\t説明\t必須Name\tパラメータの名前。コマンド内で一意である必要があります。\tTrue Bit Size\tこのパラメータのビットサイズ。ゼロまたは負の値を使用して、文字列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。Bit Offsetが0でBit Sizeが0の場合、これは派生パラメータであり、Data Typeは'DERIVED'に設定する必要があります。\tTrue Data Type\tこのパラメータのデータ型 有効な値: INT, UINT, FLOAT, DERIVED, STRING, BLOCK\tTrue  Data TypeがINT、UINT、FLOAT、DERIVEDの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Minimum Value\tこのパラメータに許可される最小値\tTrue Maximum Value\tこのパラメータに許可される最大値\tTrue Default Value\tこのパラメータのデフォルト値。デフォルト値を指定する必要がありますが、パラメータをREQUIREDとマークすると、スクリプトは値を指定するよう強制されます。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します。リトルエンディアンビットフィールドのガイドを参照してください。 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  Data TypeがSTRING、BLOCKの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Default Value\tこのパラメータのデフォルト値。デフォルト値を指定する必要がありますが、パラメータをREQUIREDとマークすると、スクリプトは値を指定するよう強制されます。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  使用例:  APPEND_PARAMETER SYNC 32 UINT 0xDEADBEEF 0xDEADBEEF 0xDEADBEEF &quot;Sync pattern&quot; APPEND_PARAMETER VALUE 32 FLOAT 0 10.5 2.5 APPEND_PARAMETER LABEL 0 STRING &quot;OPENC3&quot; &quot;The label to apply&quot;   ","version":"次へ","tagName":"h3"},{"title":"ID_PARAMETER​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#id_parameter","content":" 現在のコマンドパケット内の識別コマンドパラメータを定義する  ID パラメータは、バイナリデータブロックを特定のコマンドとして識別するために使用されます。コマンドパケットには1つ以上のID_PARAMETERを含めることができ、コマンドを識別するにはすべてがバイナリデータと一致する必要があります。  パラメータ\t説明\t必須Name\tパラメータの名前。コマンド内で一意である必要があります。\tTrue Bit Offset\tこのパラメータの最上位ビットのコマンドパケット内のビットオフセット。パケットの末尾からのオフセットを示すために負の値を使用することもできます。\tTrue Bit Size\tこのパラメータのビットサイズ。ゼロまたは負の値を使用して、文字列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。Bit Offsetが0でBit Sizeが0の場合、これは派生パラメータであり、Data Typeは'DERIVED'に設定する必要があります。\tTrue Data Type\tこのパラメータのデータ型 有効な値: INT, UINT, FLOAT, DERIVED, STRING, BLOCK\tTrue  Data TypeがINT、UINT、FLOAT、DERIVEDの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Minimum Value\tこのパラメータに許可される最小値\tTrue Maximum Value\tこのパラメータに許可される最大値\tTrue ID Value\tこのパラメータの識別値。バッファをこのパケットとして識別するには、バイナリデータがこの値と一致する必要があります。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します。リトルエンディアンビットフィールドのガイドを参照してください。 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  Data TypeがSTRING、BLOCKの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Default Value\tこのパラメータのデフォルト値。デフォルト値を指定する必要がありますが、パラメータをREQUIREDとマークすると、スクリプトは値を指定するよう強制されます。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  使用例:  ID_PARAMETER OPCODE 32 32 UINT 2 2 2 &quot;Opcode identifier&quot;   ","version":"次へ","tagName":"h3"},{"title":"APPEND_ID_PARAMETER​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#append_id_parameter","content":" 現在のコマンドパケット内の識別コマンドパラメータを定義する  ID パラメータは、バイナリデータブロックを特定のコマンドとして識別するために使用されます。コマンドパケットには1つ以上のID_PARAMETERを含めることができ、コマンドを識別するにはすべてがバイナリデータと一致する必要があります。  パラメータ\t説明\t必須Name\tパラメータの名前。コマンド内で一意である必要があります。\tTrue Bit Size\tこのパラメータのビットサイズ。ゼロまたは負の値を使用して、文字列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。Bit Offsetが0でBit Sizeが0の場合、これは派生パラメータであり、Data Typeは'DERIVED'に設定する必要があります。\tTrue Data Type\tこのパラメータのデータ型 有効な値: INT, UINT, FLOAT, DERIVED, STRING, BLOCK\tTrue  Data TypeがINT、UINT、FLOAT、DERIVEDの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Minimum Value\tこのパラメータに許可される最小値\tTrue Maximum Value\tこのパラメータに許可される最大値\tTrue ID Value\tこのパラメータの識別値。バッファをこのパケットとして識別するには、バイナリデータがこの値と一致する必要があります。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します。リトルエンディアンビットフィールドのガイドを参照してください。 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  Data TypeがSTRING、BLOCKの場合、残りのパラメータは次のとおりです：  パラメータ\t説明\t必須Default Value\tこのパラメータのデフォルト値。デフォルト値を指定する必要がありますが、パラメータをREQUIREDとマークすると、スクリプトは値を指定するよう強制されます。\tTrue Description\tこのパラメータの説明（引用符で囲む必要があります）\tFalse Endianness\tこのコマンド内のデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  使用例:  APPEND_ID_PARAMETER OPCODE 32 UINT 2 2 2 &quot;Opcode identifier&quot;   ","version":"次へ","tagName":"h3"},{"title":"ARRAY_PARAMETER​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#array_parameter","content":" 現在のコマンドパケット内の配列であるコマンドパラメータを定義する  パラメータ\t説明\t必須Name\tパラメータの名前。コマンド内で一意である必要があります。\tTrue Bit Offset\tこのパラメータの最上位ビットのコマンドパケット内のビットオフセット。パケットの末尾からのオフセットを示すために負の値を使用することもできます。派生パラメータには常にビットオフセット0を使用してください。\tTrue Item Bit Size\t各配列アイテムのビットサイズ\tTrue Item Data Type\t各配列アイテムのデータ型 有効な値: INT, UINT, FLOAT, STRING, BLOCK, DERIVED\tTrue Array Bit Size\t配列の合計ビットサイズ。ゼロまたは負の値を使用して、配列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。\tTrue Description\t説明（引用符で囲む必要があります）\tFalse Endianness\tデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  使用例:  ARRAY_PARAMETER ARRAY 64 64 FLOAT 640 &quot;Array of 10 64bit floats&quot;   ","version":"次へ","tagName":"h3"},{"title":"APPEND_ARRAY_PARAMETER​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#append_array_parameter","content":" 現在のコマンドパケット内の配列であるコマンドパラメータを定義する  パラメータ\t説明\t必須Name\tパラメータの名前。コマンド内で一意である必要があります。\tTrue Item Bit Size\t各配列アイテムのビットサイズ\tTrue Item Data Type\t各配列アイテムのデータ型 有効な値: INT, UINT, FLOAT, STRING, BLOCK, DERIVED\tTrue Array Bit Size\t配列の合計ビットサイズ。ゼロまたは負の値を使用して、配列がこの値で指定されたパケットの末尾からのオフセットまでパケットを埋めることを示すことができます。\tTrue Description\t説明（引用符で囲む必要があります）\tFalse Endianness\tデータがビッグエンディアンまたはリトルエンディアン形式で送信されるかを示します 有効な値: BIG_ENDIAN, LITTLE_ENDIAN\tFalse  使用例:  APPEND_ARRAY_PARAMETER ARRAY 64 FLOAT 640 &quot;Array of 10 64bit floats&quot;   ","version":"次へ","tagName":"h3"},{"title":"SELECT_PARAMETER​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#select_parameter","content":" 編集用に既存のコマンドパラメータを選択する  最初にパケットを選択するためにSELECT_COMMANDと組み合わせて使用する必要があります。通常、生成された値をオーバーライドしたり、複数回使用されるターゲットの特定のインスタンスにのみ影響する特定の変更を行ったりするために使用されます。  パラメータ\t説明\t必須Parameter\t変更のために選択するパラメータの名前\tTrue  使用例:  SELECT_COMMAND INST COLLECT SELECT_PARAMETER DURATION # Add units UNITS Seconds S   ","version":"次へ","tagName":"h3"},{"title":"DELETE_PARAMETER​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#delete_parameter","content":"  (Since 4.4.1) 既存のコマンドパラメータをパケット定義から削除する   コマンド定義からパラメータを削除しても、そのパラメータの定義されたスペースは削除されません。したがって、新しいパラメータを再定義しない限り、データにアクセスできない「穴」がパケットに残ります。SELECT_COMMANDを使用してから、PARAMETERを使用して新しいパラメータを定義できます。  パラメータ\t説明\t必須Parameter\t削除するパラメータの名前\tTrue  使用例:  SELECT_COMMAND INST COLLECT DELETE_PARAMETER DURATION   ","version":"次へ","tagName":"h3"},{"title":"HIDDEN​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#hidden","content":" このコマンドをCommand SenderやHandbook CreatorなどすべてのOpenC3ツールから隠す  隠されたコマンドはスクリプトを書くときにScript Runnerのポップアップヘルパーに表示されません。コマンドはシステムに存在し、スクリプトから送信できます。  ","version":"次へ","tagName":"h3"},{"title":"DISABLED​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#disabled","content":" このコマンドが送信されないようにする  コマンドを隠し、スクリプトからの送信も無効にします。DISABLEDコマンドを送信しようとするとエラーメッセージが表示されます。  ","version":"次へ","tagName":"h3"},{"title":"DISABLE_MESSAGES​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#disable_messages","content":" サーバーがcmd(...)メッセージを表示しないようにする。コマンドは引き続き記録されます。  ","version":"次へ","tagName":"h3"},{"title":"META​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#meta-1","content":" 現在のコマンドのメタデータを格納する  メタデータは、カスタムツールがさまざまな目的で使用できるユーザー固有のデータです。一例として、ソースコードヘッダーファイルを生成するために必要な追加情報を格納するためのものがあります。  パラメータ\t説明\t必須Meta Name\t格納するメタデータの名前\tTrue Meta Values\tこのMeta Nameに格納する1つ以上の値\tFalse  使用例:  META FSW_TYPE &quot;struct command&quot;   ","version":"次へ","tagName":"h3"},{"title":"HAZARDOUS​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#hazardous","content":" 現在のコマンドを危険として指定する  危険なコマンドを送信すると、コマンドを送信する前に確認を求めるダイアログが表示されます。  パラメータ\t説明\t必須Description\tコマンドが危険である理由の説明（引用符で囲む必要があります）\tFalse  ","version":"次へ","tagName":"h3"},{"title":"ACCESSOR​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#accessor","content":"  (Since 5.0.10) パケットから生の値を読み書きするために使用されるクラスを定義する   パケットから生の値を読み取るために使用されるクラスを定義します。デフォルトはBinaryAccessorです。詳細については、アクセサーを参照してください。  パラメータ\t説明\t必須Accessor Class Name\tアクセサークラスの名前\tTrue Argument\tアクセサークラスコンストラクタに渡される追加引数\tFalse  ","version":"次へ","tagName":"h3"},{"title":"TEMPLATE​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#template","content":"  (Since 5.0.10) デフォルト値が入力される前にコマンドを初期化するために使用されるテンプレート文字列を定義する   一般的に、テンプレート文字列はJSONまたはHTML形式で、コマンドパラメータで値が入力されます。UTF-8エンコードである必要があります。  パラメータ\t説明\t必須Template\t引用符で囲まれるべきテンプレート文字列\tTrue  ","version":"次へ","tagName":"h3"},{"title":"TEMPLATE_FILE​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#template_file","content":"  (Since 5.0.10) デフォルト値が入力される前にコマンドを初期化するために使用されるテンプレートファイルを定義する   一般的に、テンプレートファイルはJSONまたはHTML形式で、コマンドパラメータで値が入力されます。バイナリまたはUTF-8の場合があります。  パラメータ\t説明\t必須Template File Path\tテンプレートファイルへの相対パス。ファイル名は一般的にアンダースコアで始まります。\tTrue  ","version":"次へ","tagName":"h3"},{"title":"RESPONSE​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#response","content":"  (Since 5.14.0) このコマンドに対する予期されるテレメトリパケットレスポンスを示す   パラメータ\t説明\t必須Target Name\tテレメトリレスポンスパケットのターゲット名\tTrue Packet Name\tテレメトリレスポンスパケットのパケット名\tTrue  ","version":"次へ","tagName":"h3"},{"title":"ERROR_RESPONSE​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#error_response","content":"  (Since 5.14.0) このコマンドに対する予期されるテレメトリパケットエラーレスポンスを示す   パラメータ\t説明\t必須Target Name\tテレメトリエラーレスポンスパケットのターゲット名\tTrue Packet Name\tテレメトリエラーレスポンスパケットのパケット名\tTrue  ","version":"次へ","tagName":"h3"},{"title":"RELATED_ITEM​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#related_item","content":"  (Since 5.14.0) このコマンドに関連するテレメトリアイテムを定義する   パラメータ\t説明\t必須Target Name\t関連するテレメトリアイテムのターゲット名\tTrue Packet Name\t関連するテレメトリアイテムのパケット名\tTrue Item Name\t関連するテレメトリアイテムのアイテム名\tTrue  ","version":"次へ","tagName":"h3"},{"title":"SCREEN​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#screen","content":"  (Since 5.14.0) このコマンドに関連するテレメトリ画面を定義する   パラメータ\t説明\t必須Target Name\t関連するテレメトリ画面のターゲット名\tTrue Screen Name\t関連するテレメトリ画面の画面名\tTrue  ","version":"次へ","tagName":"h3"},{"title":"VIRTUAL​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#virtual","content":"  (Since 5.18.0) このパケットを仮想としてマークし、識別に参加しないようにする   特定のパケットを持つアイテムの構造として使用できるパケット定義に使用されます。  ","version":"次へ","tagName":"h3"},{"title":"RESTRICTED​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#restricted","content":"  (Since 5.20.0) このパケットを制限付きとしてマークし、クリティカルコマンディングが有効な場合は承認が必要になる   クリティカルコマンドの2種類のタイプ（HAZARDOUSとRESTRICTED）の1つとして使用されます。  ","version":"次へ","tagName":"h3"},{"title":"VALIDATOR​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#validator","content":"  (Since 5.19.0) コマンドのバリデータクラスを定義する   バリデータクラスは、pre_checkとpost_checkの両方のメソッドを持つコマンドの成功または失敗を検証するために使用されます。  パラメータ\t説明\t必須Class Filename\tRubyまたはPythonクラスを含むファイル名。ファイル名はクラス名に基づいて命名する必要があり、クラスはアンダースコア付きのファイル名のCamelCase版である必要があります。例えば、'command_validator.rb'は'class CommandValidator'を含んでいるべきです。\tTrue Argument\tバリデータクラスコンストラクタに渡される追加引数\tFalse  Ruby例:  VALIDATOR custom_validator.rb Defined in custom_validator.rb: require 'openc3/packets/command_validator' class CustomValidator &lt; OpenC3::CommandValidator # Both the pre_check and post_check are passed the command packet that was sent # You can inspect the command in your checks as follows: # packet.target_name =&gt; target name # packet.packet_name =&gt; packet name (command name) # packet.read(&quot;ITEM&quot;) =&gt; converted value # packet.read(&quot;ITEM&quot;, :RAW) =&gt; raw value def pre_check(packet) if tlm(&quot;TGT PKT ITEM&quot;) == 0 return [false, &quot;TGT PKT ITEM is 0&quot;] end @cmd_acpt_cnt = tlm(&quot;TGT PKT CMD_ACPT_CNT&quot;) return [true, nil] end def post_check(packet) wait_check(&quot;TGT PKT CMD_ACPT_CNT &gt; #{@cmd_acpt_cnt}&quot;, 10) return [true, nil] end end   Python例:  VALIDATOR custom_validator.rb Defined in custom_validator.py: class CustomValidator(CommandValidator): # Both the pre_check and post_check are passed the command packet that was sent # You can inspect the command in your checks as follows: # packet.target_name =&gt; target name # packet.packet_name =&gt; packet name (command name) # packet.read(&quot;ITEM&quot;) =&gt; converted value # packet.read(&quot;ITEM&quot;, :RAW) =&gt; raw value def pre_check(self, command): if tlm(&quot;TGT PKT ITEM&quot;) == 0: return [False, &quot;TGT PKT ITEM is 0&quot;] self.cmd_acpt_cnt = tlm(&quot;INST HEALTH_STATUS CMD_ACPT_CNT&quot;) return [True, None] def post_check(self, command): wait_check(f&quot;INST HEALTH_STATUS CMD_ACPT_CNT &gt; {self.cmd_acpt_cnt}&quot;, 10) return [True, None]   ","version":"次へ","tagName":"h3"},{"title":"SELECT_COMMAND​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#select_command","content":" 編集用に既存のコマンドパケットを選択する  通常、元のコマンドが定義されている場所とは別の設定ファイルで使用され、既存のコマンド定義をオーバーライドまたは追加します。個々のパラメータを変更するには、SELECT_PARAMETERと組み合わせて使用する必要があります。  パラメータ\t説明\t必須Target Name\tこのコマンドが関連付けられているターゲットの名前\tTrue Command Name\t選択するコマンドの名前\tTrue  使用例:  SELECT_COMMAND INST COLLECT SELECT_PARAMETER DURATION # Add units UNITS Seconds S   ","version":"次へ","tagName":"h2"},{"title":"サンプルファイル​","type":1,"pageTitle":"コマンド","url":"/ja/docs/configuration/command#サンプルファイル","content":" サンプルファイル: TARGET/cmd_tlm/cmd.txt  COMMAND TARGET COLLECT_DATA BIG_ENDIAN &quot;Commands my target to collect data&quot; PARAMETER CCSDSVER 0 3 UINT 0 0 0 &quot;CCSDS PRIMARY HEADER VERSION NUMBER&quot; PARAMETER CCSDSTYPE 3 1 UINT 1 1 1 &quot;CCSDS PRIMARY HEADER PACKET TYPE&quot; PARAMETER CCSDSSHF 4 1 UINT 0 0 0 &quot;CCSDS PRIMARY HEADER SECONDARY HEADER FLAG&quot; ID_PARAMETER CCSDSAPID 5 11 UINT 0 2047 100 &quot;CCSDS PRIMARY HEADER APPLICATION ID&quot; PARAMETER CCSDSSEQFLAGS 16 2 UINT 3 3 3 &quot;CCSDS PRIMARY HEADER SEQUENCE FLAGS&quot; PARAMETER CCSDSSEQCNT 18 14 UINT 0 16383 0 &quot;CCSDS PRIMARY HEADER SEQUENCE COUNT&quot; PARAMETER CCSDSLENGTH 32 16 UINT 4 4 4 &quot;CCSDS PRIMARY HEADER PACKET LENGTH&quot; PARAMETER ANGLE 48 32 FLOAT -180.0 180.0 0.0 &quot;ANGLE OF INSTRUMENT IN DEGREES&quot; POLY_WRITE_CONVERSION 0 0.01745 0 0 PARAMETER MODE 80 8 UINT 0 1 0 &quot;DATA COLLECTION MODE&quot; STATE NORMAL 0 STATE DIAG 1 COMMAND TARGET NOOP BIG_ENDIAN &quot;Do Nothing&quot; PARAMETER CCSDSVER 0 3 UINT 0 0 0 &quot;CCSDS PRIMARY HEADER VERSION NUMBER&quot; PARAMETER CCSDSTYPE 3 1 UINT 1 1 1 &quot;CCSDS PRIMARY HEADER PACKET TYPE&quot; PARAMETER CCSDSSHF 4 1 UINT 0 0 0 &quot;CCSDS PRIMARY HEADER SECONDARY HEADER FLAG&quot; ID_PARAMETER CCSDSAPID 5 11 UINT 0 2047 101 &quot;CCSDS PRIMARY HEADER APPLICATION ID&quot; PARAMETER CCSDSSEQFLAGS 16 2 UINT 3 3 3 &quot;CCSDS PRIMARY HEADER SEQUENCE FLAGS&quot; PARAMETER CCSDSSEQCNT 18 14 UINT 0 16383 0 &quot;CCSDS PRIMARY HEADER SEQUENCE COUNT&quot; PARAMETER CCSDSLENGTH 32 16 UINT 0 0 0 &quot;CCSDS PRIMARY HEADER PACKET LENGTH&quot; PARAMETER DUMMY 48 8 UINT 0 0 0 &quot;DUMMY PARAMETER BECAUSE CCSDS REQUIRES 1 BYTE OF DATA&quot; COMMAND TARGET SETTINGS BIG_ENDIAN &quot;Set the Settings&quot; PARAMETER CCSDSVER 0 3 UINT 0 0 0 &quot;CCSDS PRIMARY HEADER VERSION NUMBER&quot; PARAMETER CCSDSTYPE 3 1 UINT 1 1 1 &quot;CCSDS PRIMARY HEADER PACKET TYPE&quot; PARAMETER CCSDSSHF 4 1 UINT 0 0 0 &quot;CCSDS PRIMARY HEADER SECONDARY HEADER FLAG&quot; ID_PARAMETER CCSDSAPID 5 11 UINT 0 2047 102 &quot;CCSDS PRIMARY HEADER APPLICATION ID&quot; PARAMETER CCSDSSEQFLAGS 16 2 UINT 3 3 3 &quot;CCSDS PRIMARY HEADER SEQUENCE FLAGS&quot; PARAMETER CCSDSSEQCNT 18 14 UINT 0 16383 0 &quot;CCSDS PRIMARY HEADER SEQUENCE COUNT&quot; PARAMETER CCSDSLENGTH 32 16 UINT 0 0 0 &quot;CCSDS PRIMARY HEADER PACKET LENGTH&quot; &lt;% 5.times do |x| %&gt; APPEND_PARAMETER SETTING&lt;%= x %&gt; 16 UINT 0 5 0 &quot;Setting &lt;%= x %&gt;&quot; &lt;% end %&gt;  ","version":"次へ","tagName":"h2"},{"title":"スクリプティング API ガイド","type":0,"sectionRef":"#","url":"/ja/docs/guides/scripting-api","content":"","keywords":"","version":"次へ"},{"title":"概念​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#概念","content":" ","version":"次へ","tagName":"h2"},{"title":"プログラミング言語​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#プログラミング言語","content":" COSMOS スクリプティングは Ruby または Python のいずれかを使って実装されています。Ruby と Python は非常に似たスクリプト言語であり、多くの場合、COSMOS API は両方で同一です。このガイドは両方をサポートするために書かれており、言語固有の追加情報は スクリプト作成ガイド にあります。  ","version":"次へ","tagName":"h3"},{"title":"Script Runner の使用​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script-runner-の使用","content":" Script Runner はテスト手順の実行と実装のための理想的な環境を提供するグラフィカルアプリケーションです。Script Runner ツールは主に 4 つのセクションに分かれています。ツールの上部にはメニューバーがあり、ファイルの開閉、構文チェック、スクリプトの実行などができます。  次に、現在実行中のスクリプトと「Start/Go」、「Pause/Retry」、「Stop」の 3 つのボタンを表示するツールバーがあります。Start/Go ボタンはスクリプトを開始し、エラーや待機を越えて継続するために使用されます。Pause/Retry ボタンは実行中のスクリプトを一時停止します。エラーが発生した場合、Pause ボタンは Retry に変わり、エラーが発生した行を再実行します。最後に、Stop ボタンはいつでも実行中のスクリプトを停止します。  3 番目は実際のスクリプトの表示です。スクリプトが実行されていないとき、このエリアでスクリプトを編集・作成することができます。便利なコード補完機能があり、スクリプトを書いている時に利用可能なコマンドやテレメトリポイントのリストが表示されます。cmd( または tlm( の行を書き始めるだけでコード補完が表示されます。この機能により、コマンドとテレメトリのニーモニックでのタイプミスが大幅に減少します。  最後に、ディスプレイの一番下にはログメッセージがあります。送信されたコマンド、発生したエラー、ユーザーのプリント文がすべてこのエリアに表示されます。  ","version":"次へ","tagName":"h3"},{"title":"テレメトリタイプ​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#テレメトリタイプ","content":" COSMOS ではテレメトリ値を取得する 4 つの異なる方法があります。以下の表ではその違いを説明しています。  テレメトリタイプ\t説明Raw\t生のテレメトリは、変換前のテレメトリパケットにあるまさにそのままの状態です。派生テレメトリポイント（パケット内に実際の位置を持たないもの）を除くすべてのテレメトリ項目は生の値を持ちます。派生項目に対して生のテレメトリを要求すると nil が返されます。 Converted\t変換されたテレメトリは、状態変換や多項式変換などの変換係数を通過した生のテレメトリです。テレメトリ項目に変換が定義されていない場合、変換されたテレメトリは生のテレメトリと同じになります。これはスクリプトで最も一般的に使用されるテレメトリのタイプです。 Formatted\tフォーマットされたテレメトリは、printf スタイルの変換を経て文字列になった変換済みテレメトリです。フォーマットされたテレメトリは常に文字列表現を持ちます。テレメトリポイントにフォーマット文字列が定義されていない場合、フォーマットされたテレメトリは変換されたテレメトリと同じですが、文字列として表現されます。 Formatted with Units\t単位付きでフォーマットされたテレメトリは、フォーマットされたテレメトリと同じですが、文字列の末尾にスペースとテレメトリ項目の単位が追加されます。テレメトリ項目に単位が定義されていない場合、このタイプはフォーマットされたテレメトリと同じになります。  ","version":"次へ","tagName":"h3"},{"title":"Script Runner API​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script-runner-api","content":" 以下のメソッドは Script Runner の手順で使用するために設計されています。多くは、カスタムビルドされた COSMOS ツールでも使用できます。カスタムツールでより効率的に使用するメソッドについては、COSMOS Tool API セクションを参照してください。  ","version":"次へ","tagName":"h2"},{"title":"COSMOS v5 から v6 への移行​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#cosmos-v5-から-v6-への移行","content":" 以下の API メソッドは COSMOS v6 から削除されました。ほとんどの非推奨 API メソッドは後方互換性のために残っています。  メソッド\tツール\tステータスget_all_target_info\tCommand and Telemetry Server\t削除、get_target_interfaces を使用 play_wav_file\tScript Runner\t削除 status_bar\tScript Runner\t削除  ","version":"次へ","tagName":"h3"},{"title":"COSMOS v4 から v5 への移行​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#cosmos-v4-から-v5-への移行","content":" 以下の API メソッドはいずれも非推奨（COSMOS 5 に移植されません）、または現在未実装（最終的に COSMOS 5 に移植される予定）です：  メソッド\tツール\tステータスclear\tTelemetry Viewer\t非推奨、clear_screen を使用 clear_all\tTelemetry Viewer\t非推奨、clear_all_screens を使用 close_local_screens\tTelemetry Viewer\t非推奨、clear_screen を使用 clear_disconnected_targets\tScript Runner\t非推奨 cmd_tlm_clear_counters\tCommand and Telemetry Server\t非推奨 cmd_tlm_reload\tCommand and Telemetry Server\t非推奨 display\tTelemetry Viewer\t非推奨、display_screen を使用 get_all_packet_logger_info\tCommand and Telemetry Server\t非推奨 get_all_target_info\tCommand and Telemetry Server\t非推奨、get_target_interfaces を使用 get_background_tasks\tCommand and Telemetry Server\t非推奨 get_all_cmd_info\tCommand and Telemetry Server\t非推奨、get_all_cmds を使用 get_all_tlm_info\tCommand and Telemetry Server\t非推奨、get_all_tlm を使用 get_cmd_list\tCommand and Telemetry Server\t非推奨、get_all_cmds を使用 get_cmd_log_filename\tCommand and Telemetry Server\t非推奨 get_cmd_param_list\tCommand and Telemetry Server\t非推奨、get_cmd を使用 get_cmd_tlm_disconnect\tScript Runner\t非推奨、$disconnect を使用 get_disconnected_targets\tScript Runner\t未実装 get_interface_info\tCommand and Telemetry Server\t非推奨、get_interface を使用 get_interface_targets\tCommand and Telemetry Server\t非推奨 get_output_logs_filenames\tCommand and Telemetry Server\t非推奨 get_packet\tCommand and Telemetry Server\t非推奨、get_packets を使用 get_packet_data\tCommand and Telemetry Server\t非推奨、get_packets を使用 get_packet_logger_info\tCommand and Telemetry Server\t非推奨 get_packet_loggers\tCommand and Telemetry Server\t非推奨 get_replay_mode\tReplay\t非推奨 get_router_info\tCommand and Telemetry Server\t非推奨、get_router を使用 get_scriptrunner_message_log_filename\tCommand and Telemetry Server\t非推奨 get_server_message\tCommand and Telemetry Server\t非推奨 get_server_message_log_filename\tCommand and Telemetry Server\t非推奨 get_server_status\tCommand and Telemetry Server\t非推奨 get_stale\tCommand and Telemetry Server\t非推奨 get_target_ignored_items\tCommand and Telemetry Server\t非推奨、get_target を使用 get_target_ignored_parameters\tCommand and Telemetry Server\t非推奨、get_target を使用 get_target_info\tCommand and Telemetry Server\t非推奨、get_target を使用 get_target_list\tCommand and Telemetry Server\t非推奨、get_target_names を使用 get_tlm_details\tCommand and Telemetry Server\t非推奨 get_tlm_item_list\tCommand and Telemetry Server\t非推奨 get_tlm_list\tCommand and Telemetry Server\t非推奨 get_tlm_log_filename\tCommand and Telemetry Server\t非推奨 interface_state\tCommand and Telemetry Server\t非推奨、get_interface を使用 override_tlm_raw\tCommand and Telemetry Server\t非推奨、override_tlm を使用 open_directory_dialog\tScript Runner\t非推奨 play_wav_file\tScript Runner\t非推奨 replay_move_end\tReplay\t非推奨 replay_move_index\tReplay\t非推奨 replay_move_start\tReplay\t非推奨 replay_play\tReplay\t非推奨 replay_reverse_play\tReplay\t非推奨 replay_select_file\tReplay\t非推奨 replay_set_playback_delay\tReplay\t非推奨 replay_status\tReplay\t非推奨 replay_step_back\tReplay\t非推奨 replay_step_forward\tReplay\t非推奨 replay_stop\tReplay\t非推奨 require_utility\tScript Runner\t非推奨ですが後方互換性のため存在、load_utility を使用 router_state\tCommand and Telemetry Server\t非推奨、get_router を使用 save_file_dialog\tScript Runner\t非推奨 save_setting\tCommand and Telemetry Server\t非推奨ですが後方互換性のため存在、set_setting を使用 set_cmd_tlm_disconnect\tScript Runner\t非推奨、disconnect_script を使用 set_disconnected_targets\tScript Runner\t未実装 set_replay_mode\tReplay\t非推奨 set_stdout_max_lines\tScript Runner\t非推奨 set_tlm_raw\tScript Runner\t非推奨、set_tlm を使用 show_backtrace\tScript Runner\t非推奨、バックトレースは常に表示 status_bar\tScript Runner\t非推奨 shutdown_cmd_tlm\tCommand and Telemetry Server\t非推奨 start_cmd_log\tCommand and Telemetry Server\t非推奨 start_logging\tCommand and Telemetry Server\t非推奨 start_new_scriptrunner_message_log\tCommand and Telemetry Server\t非推奨 start_new_server_message_log\tCommand and Telemetry Server\t非推奨 start_tlm_log\tCommand and Telemetry Server\t非推奨 stop_background_task\tCommand and Telemetry Server\t非推奨 stop_cmd_log\tCommand and Telemetry Server\t非推奨 stop_logging\tCommand and Telemetry Server\t非推奨 stop_tlm_log\tCommand and Telemetry Server\t非推奨 subscribe_limits_events\tCommand and Telemetry Server\t非推奨 subscribe_packet_data\tCommand and Telemetry Server\t非推奨、subscribe_packets を使用 subscribe_server_messages\tCommand and Telemetry Server\t未実装 tlm_variable\tScript Runner\t非推奨、tlm() を使用してタイプを渡す unsubscribe_limits_events\tCommand and Telemetry Server\t非推奨 unsubscribe_packet_data\tCommand and Telemetry Server\t非推奨 unsubscribe_server_messages\tCommand and Telemetry Server\t非推奨 wait_raw\tScript Runner\t非推奨、wait(..., type: :RAW) を使用 wait_check_raw\tScript Runner\t非推奨、wait_check(..., type: :RAW) を使用 wait_tolerance_raw\tScript Runner\t非推奨、wait_tolerance(..., type: :RAW) を使用 wait_check_tolerance_raw\tScript Runner\t非推奨、wait_check_tolerance(..., type: :RAW) を使用  ","version":"次へ","tagName":"h3"},{"title":"ユーザー入力の取得​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#ユーザー入力の取得","content":" これらのメソッドを使用すると、スクリプトに必要な値をユーザーが入力できます。  ","version":"次へ","tagName":"h2"},{"title":"ask​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#ask","content":" 質問でユーザーに入力を促します。ユーザー入力は自動的に文字列から適切なデータ型に変換されます。例えば、ユーザーが「1」と入力すると、整数としての数値 1 が返されます。  Ruby / Python 構文：  ask(&quot;&lt;question&gt;&quot;, &lt;Blank or Default&gt;, &lt;Password&gt;)   パラメータ\t説明question\tユーザーに表示する質問。 Blank or Default\t空の応答を許可するかどうか（オプション - デフォルトは false）。ブール値でない値が渡された場合、デフォルト値として使用されます。 Password\t入力をパスワードとして扱うかどうか。パスワードはドットで表示され、ログに記録されません。デフォルトは false です。  Ruby の例：  value = ask(&quot;整数を入力してください&quot;) value = ask(&quot;値を入力するか何も入力しないでください&quot;, true) value = ask(&quot;値を入力してください&quot;, 10) password = ask(&quot;パスワードを入力してください&quot;, false, true)   Python の例：  value = ask(&quot;整数を入力してください&quot;) value = ask(&quot;値を入力するか何も入力しないでください&quot;, True) value = ask(&quot;値を入力してください&quot;, 10) password = ask(&quot;パスワードを入力してください&quot;, False, True)   ","version":"次へ","tagName":"h3"},{"title":"ask_string​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#ask_string","content":" 質問でユーザーに入力を促します。ユーザー入力は常に文字列として返されます。例えば、ユーザーが「1」と入力すると、文字列「1」が返されます。  Ruby / Python 構文：  ask_string(&quot;&lt;question&gt;&quot;, &lt;Blank or Default&gt;, &lt;Password&gt;)   パラメータ\t説明question\tユーザーに表示する質問。 Blank or Default\t空の応答を許可するかどうか（オプション - デフォルトは false）。ブール値でない値が渡された場合、デフォルト値として使用されます。 Password\t入力をパスワードとして扱うかどうか。パスワードはドットで表示され、ログに記録されません。デフォルトは false です。  Ruby の例：  string = ask_string(&quot;値を入力するか何も入力しないでください&quot;, true) string = ask_string(&quot;値を入力してください&quot;, &quot;test&quot;) password = ask_string(&quot;パスワードを入力してください&quot;, false, true)   Python の例：  string = ask_string(&quot;文字列を入力してください&quot;) string = ask_string(&quot;値を入力するか何も入力しないでください&quot;, True) string = ask_string(&quot;値を入力してください&quot;, &quot;test&quot;) password = ask_string(&quot;パスワードを入力してください&quot;, False, True)   ","version":"次へ","tagName":"h3"},{"title":"message_box​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#message_box","content":" ","version":"次へ","tagName":"h3"},{"title":"vertical_message_box​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#vertical_message_box","content":" ","version":"次へ","tagName":"h3"},{"title":"combo_box​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#combo_box","content":" message_box、vertical_message_box、および combo_box メソッドは、ユーザーがクリックできる任意のボタンまたは選択肢を持つメッセージボックスを作成します。クリックされたボタンのテキストが返されます。  Ruby / Python 構文：  message_box(&quot;&lt;Message&gt;&quot;, &quot;&lt;button text 1&gt;&quot;, ...) vertical_message_box(&quot;&lt;Message&gt;&quot;, &quot;&lt;button text 1&gt;&quot;, ...) combo_box(&quot;&lt;Message&gt;&quot;, &quot;&lt;selection text 1&gt;&quot;, ...)   パラメータ\t説明Message\tユーザーに表示するメッセージ。 Button/Selection Text\tボタンまたは選択肢のテキスト  Ruby の例：  value = message_box(&quot;センサー番号を選択してください&quot;, 'One', 'Two') value = vertical_message_box(&quot;センサー番号を選択してください&quot;, 'One', 'Two') value = combo_box(&quot;センサー番号を選択してください&quot;, 'One', 'Two') case value when 'One' puts 'センサー One' when 'Two' puts 'センサー Two' end   Python の例：  value = message_box(&quot;センサー番号を選択してください&quot;, 'One', 'Two') value = vertical_message_box(&quot;センサー番号を選択してください&quot;, 'One', 'Two') value = combo_box(&quot;センサー番号を選択してください&quot;, 'One', 'Two') match value: case 'One': print('センサー One') case 'Two': print('センサー Two')   ","version":"次へ","tagName":"h3"},{"title":"get_target_file​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_target_file","content":" ターゲットディレクトリ内のファイルへのファイルハンドルを返します  Ruby 構文：  get_target_file(&quot;&lt;File Path&gt;&quot;, original: false)   Python 構文：  get_target_file(&quot;&lt;File Path&gt;&quot;, original=False)   パラメータ\t説明File Path\tターゲットディレクトリ内のファイルへのパス。TARGET 名で始まると想定されます。例：INST/procedures/proc.rb original\tプラグインから元のファイルを取得するか、ファイルへの変更を取得するかどうか。デフォルトは false で、これは変更されたファイルを取得することを意味します。変更されたファイルが存在しない場合、API は自動的に元のファイルを取得しようとします。  Ruby の例：  file = get_target_file(&quot;INST/data/attitude.bin&quot;) puts file.read().formatted # バイナリファイルをフォーマット file.unlink # ファイルを削除 file = get_target_file(&quot;INST/procedures/checks.rb&quot;, original: true) puts file.read() file.unlink # ファイルを削除   Python の例：  from openc3.utilities.string import formatted file = get_target_file(&quot;INST/data/attitude.bin&quot;) print(formatted(file.read())) # バイナリファイルをフォーマット file.close() # ファイルを削除 file = get_target_file(&quot;INST/procedures/checks.rb&quot;, original=True) print(file.read()) file.close() # ファイルを削除   ","version":"次へ","tagName":"h3"},{"title":"put_target_file​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#put_target_file","content":" ターゲットディレクトリにファイルを書き込みます  Ruby / Python 構文：  put_target_file(&quot;&lt;File Path&gt;&quot;, &quot;IO or String&quot;)   パラメータ\t説明File Path\tターゲットディレクトリ内のファイルへのパス。TARGET 名で始まると想定されます。例：INST/procedures/proc.rb。ファイルは以前に存在していてもしていなくても構いません。注意：プラグインの元のファイルは変更されませんが、既存の変更されたファイルは上書きされます。 IO or String\tデータは IO オブジェクトまたは文字列です  Ruby の例：  put_target_file(&quot;INST/test1.txt&quot;, &quot;これは文字列テストです&quot;) file = Tempfile.new('test') file.write(&quot;これは Io テストです&quot;) file.rewind put_target_file(&quot;INST/test2.txt&quot;, file) put_target_file(&quot;INST/test3.bin&quot;, &quot;\\x00\\x01\\x02\\x03\\xFF\\xEE\\xDD\\xCC&quot;) # バイナリ   Python の例：  put_target_file(&quot;INST/test1.txt&quot;, &quot;これは文字列テストです&quot;) file = tempfile.NamedTemporaryFile(mode=&quot;w+t&quot;) file.write(&quot;これは Io テストです&quot;) file.seek(0) put_target_file(&quot;INST/test2.txt&quot;, file) put_target_file(&quot;INST/test3.bin&quot;, b&quot;\\x00\\x01\\x02\\x03\\xFF\\xEE\\xDD\\xCC&quot;) # バイナリ   ","version":"次へ","tagName":"h3"},{"title":"delete_target_file​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#delete_target_file","content":" ターゲットディレクトリ内のファイルを削除します  Ruby / Python 構文：  delete_target_file(&quot;&lt;File Path&gt;&quot;)   パラメータ\t説明File Path\tターゲットディレクトリ内のファイルへのパス。TARGET 名で始まると想定されます。例：INST/procedures/proc.rb。注意：put_target_file で作成されたファイルのみ削除できます。プラグインのインストールからの元のファイルは残ります。  Ruby / Python の例：  put_target_file(&quot;INST/delete_me.txt&quot;, &quot;削除される予定&quot;) delete_target_file(&quot;INST/delete_me.txt&quot;)   ","version":"次へ","tagName":"h3"},{"title":"open_file_dialog​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#open_file_dialog","content":" ","version":"次へ","tagName":"h3"},{"title":"open_files_dialog​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#open_files_dialog","content":" open_file_dialog および open_files_dialog メソッドは、ユーザーが単一または複数のファイルを選択できるファイルダイアログボックスを作成します。選択したファイルが返されます。  注意：COSMOS 5 では save_file_dialog および open_directory_dialog メソッドが非推奨になっています。ファイルをターゲットに書き戻したい場合は、save_file_dialog を put_target_file に置き換えることができます。新しいアーキテクチャでは open_directory_dialog は意味がないため、個々のファイルをリクエストする必要があります。  Ruby 構文：  open_file_dialog(&quot;&lt;Title&gt;&quot;, &quot;&lt;Message&gt;&quot;, filter: &quot;&lt;filter&gt;&quot;) open_files_dialog(&quot;&lt;Title&gt;&quot;, &quot;&lt;Message&gt;&quot;, filter: &quot;&lt;filter&gt;&quot;)   Python 構文：  open_file_dialog(&quot;&lt;Title&gt;&quot;, &quot;&lt;Message&gt;&quot;, filter=&quot;&lt;filter&gt;&quot;) open_files_dialog(&quot;&lt;Title&gt;&quot;, &quot;&lt;Message&gt;&quot;, filter=&quot;&lt;filter&gt;&quot;)   パラメータ\t説明Title\tダイアログに表示するタイトル。必須。 Message\tダイアログボックスに表示するメッセージ。オプションのパラメータ。 filter\t許可されるファイルタイプをフィルタリングするための名前付きパラメータ。オプションのパラメータで、コンマ区切りのファイルタイプで指定します。例：&quot;.txt,.doc&quot;。詳細は https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#accept を参照してください。  Ruby の例：  file = open_file_dialog(&quot;単一ファイルを開く&quot;, &quot;ファイルを選んでください&quot;, filter: &quot;.txt&quot;) puts file # Ruby File オブジェクト puts file.read file.delete files = open_files_dialog(&quot;複数のファイルを開く&quot;) # メッセージはオプション puts files # File オブジェクトの配列（1つだけ選択しても） files.each do |file| puts file puts file.read file.delete end   Python の例：  file = open_file_dialog(&quot;単一ファイルを開く&quot;, &quot;ファイルを選んでください&quot;, filter=&quot;.txt&quot;) print(file) print(file.read()) file.close() files = open_files_dialog(&quot;複数のファイルを開く&quot;) # メッセージはオプション print(files) # File オブジェクトの配列（1つだけ選択しても） for file in files: print(file) print(file.read()) file.close()   ","version":"次へ","tagName":"h3"},{"title":"ユーザーへの情報提供​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#ユーザーへの情報提供","content":" これらのメソッドは、何かが発生したことをユーザーに通知します。  ","version":"次へ","tagName":"h2"},{"title":"prompt​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#prompt","content":" ユーザーにメッセージを表示し、OKボタンを押すのを待ちます。  Ruby / Python 構文：  prompt(&quot;&lt;Message&gt;&quot;)   パラメータ\t説明Message\tユーザーに表示するメッセージ。  Ruby / Python の例：  prompt(&quot;続行するには OK を押してください&quot;)   ","version":"次へ","tagName":"h3"},{"title":"コマンド​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#コマンド","content":" これらのメソッドは、ターゲットにコマンドを送信し、システム内のコマンドに関する情報を受信する機能を提供します。  ","version":"次へ","tagName":"h2"},{"title":"cmd​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#cmd","content":" 指定されたコマンドを送信します。  Ruby 構文：  cmd(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;Param #1 Name&quot; =&gt; &lt;Param #1 Value&gt;, &quot;Param #2 Name&quot; =&gt; &lt;Param #2 Value&gt;, ...)   Python 構文：  cmd(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, {&quot;Param #1 Name&quot;: &lt;Param #1 Value&gt;, &quot;Param #2 Name&quot;: &lt;Param #2 Value&gt;, ...})   パラメータ\t説明Target Name\tこのコマンドに関連付けられているターゲットの名前。 Command Name\tこのコマンドの名前。ニーモニックとも呼ばれます。 Param #x Name\tコマンドパラメータの名前。パラメータがない場合は 'with' キーワードを指定しないでください。 Param #x Value\tコマンドパラメータの値。値は自動的に適切な型に変換されます。 timeout\tデフォルトのタイムアウト値（5秒）を変更するための名前付きパラメータ log_message\tコマンドのログを防ぐための名前付きパラメータ  Ruby の例：  cmd(&quot;INST COLLECT with DURATION 10, TYPE NORMAL&quot;) # Ruby ではパラメータの周りの括弧はオプション cmd(&quot;INST&quot;, &quot;COLLECT&quot;, &quot;DURATION&quot; =&gt; 10, &quot;TYPE&quot; =&gt; &quot;NORMAL&quot;) cmd(&quot;INST&quot;, &quot;COLLECT&quot;, { &quot;DURATION&quot; =&gt; 10, &quot;TYPE&quot; =&gt; &quot;NORMAL&quot; }) cmd(&quot;INST ABORT&quot;, timeout: 10, log_message: false)   Python の例：  cmd(&quot;INST COLLECT with DURATION 10, TYPE NORMAL&quot;) cmd(&quot;INST&quot;, &quot;COLLECT&quot;, { &quot;DURATION&quot;: 10, &quot;TYPE&quot;: &quot;NORMAL&quot; }) cmd(&quot;INST ABORT&quot;, timeout=10, log_message=False)   ","version":"次へ","tagName":"h3"},{"title":"cmd_no_range_check​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#cmd_no_range_check","content":" パラメータの範囲チェックを実行せずに指定したコマンドを送信します。これは、ターゲットをテストするために意図的に不正なコマンドパラメータを送信する必要がある場合にのみ使用してください。  Ruby 構文：  cmd_no_range_check(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_no_range_check(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;Param #1 Name&quot; =&gt; &lt;Param #1 Value&gt;, &quot;Param #2 Name&quot; =&gt; &lt;Param #2 Value&gt;, ...)   Python 構文：  cmd_no_range_check(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_no_range_check(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, {&quot;Param #1 Name&quot;: &lt;Param #1 Value&gt;, &quot;Param #2 Name&quot;: &lt;Param #2 Value&gt;, ...})   パラメータ\t説明Target Name\tこのコマンドに関連付けられているターゲットの名前。 Command Name\tこのコマンドの名前。ニーモニックとも呼ばれます。 Param #x Name\tコマンドパラメータの名前。パラメータがない場合は 'with' キーワードを指定しないでください。 Param #x Value\tコマンドパラメータの値。値は自動的に適切な型に変換されます。 timeout\tデフォルトのタイムアウト値（5秒）を変更するための名前付きパラメータ log_message\tコマンドのログを防ぐための名前付きパラメータ  Ruby の例：  cmd_no_range_check(&quot;INST COLLECT with DURATION 11, TYPE NORMAL&quot;) cmd_no_range_check(&quot;INST&quot;, &quot;COLLECT&quot;, &quot;DURATION&quot; =&gt; 11, &quot;TYPE&quot; =&gt; &quot;NORMAL&quot;)   Python の例：  cmd_no_range_check(&quot;INST COLLECT with DURATION 11, TYPE NORMAL&quot;) cmd_no_range_check(&quot;INST&quot;, &quot;COLLECT&quot;, {&quot;DURATION&quot;: 11, &quot;TYPE&quot;: &quot;NORMAL&quot;})   ","version":"次へ","tagName":"h3"},{"title":"cmd_no_hazardous_check​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#cmd_no_hazardous_check","content":" 危険なコマンドである場合の通知を行わずに指定されたコマンドを送信します。これは、危険なコマンドを含むテストを完全に自動化する必要がある場合にのみ使用してください。  Ruby 構文：  cmd_no_hazardous_check(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_no_hazardous_check(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;Param #1 Name&quot; =&gt; &lt;Param #1 Value&gt;, &quot;Param #2 Name&quot; =&gt; &lt;Param #2 Value&gt;, ...)   Python 構文：  cmd_no_hazardous_check(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_no_hazardous_check(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, {&quot;Param #1 Name&quot;: &lt;Param #1 Value&gt;, &quot;Param #2 Name&quot;: &lt;Param #2 Value&gt;, ...})   パラメータ\t説明Target Name\tこのコマンドに関連付けられているターゲットの名前。 Command Name\tこのコマンドの名前。ニーモニックとも呼ばれます。 Param #x Name\tコマンドパラメータの名前。パラメータがない場合は 'with' キーワードを指定しないでください。 Param #x Value\tコマンドパラメータの値。値は自動的に適切な型に変換されます。 timeout\tデフォルトのタイムアウト値（5秒）を変更するための名前付きパラメータ log_message\tコマンドのログを防ぐための名前付きパラメータ  Ruby / Python の例：  cmd_no_hazardous_check(&quot;INST CLEAR&quot;) cmd_no_hazardous_check(&quot;INST&quot;, &quot;CLEAR&quot;)   ","version":"次へ","tagName":"h3"},{"title":"cmd_no_checks​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#cmd_no_checks","content":" パラメータの範囲チェックを実行せず、コマンドが危険なコマンドである場合の通知も行わずに指定されたコマンドを送信します。これは、意図的に無効なパラメータを持つ危険なコマンドを含むテストを完全に自動化する必要がある場合にのみ使用してください。  Ruby 構文：  cmd_no_checks(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_no_checks(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;Param #1 Name&quot; =&gt; &lt;Param #1 Value&gt;, &quot;Param #2 Name&quot; =&gt; &lt;Param #2 Value&gt;, ...)   Python 構文：  cmd_no_checks(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_no_checks(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, {&quot;Param #1 Name&quot;: &lt;Param #1 Value&gt;, &quot;Param #2 Name&quot;: &lt;Param #2 Value&gt;, ...})   パラメータ\t説明Target Name\tこのコマンドに関連付けられているターゲットの名前。 Command Name\tこのコマンドの名前。ニーモニックとも呼ばれます。 Param #x Name\tコマンドパラメータの名前。パラメータがない場合は 'with' キーワードを指定しないでください。 Param #x Value\tコマンドパラメータの値。値は自動的に適切な型に変換されます。 timeout\tデフォルトのタイムアウト値（5秒）を変更するための名前付きパラメータ log_message\tコマンドのログを防ぐための名前付きパラメータ  Ruby の例：  cmd_no_checks(&quot;INST COLLECT with DURATION 11, TYPE SPECIAL&quot;) cmd_no_checks(&quot;INST&quot;, &quot;COLLECT&quot;, &quot;DURATION&quot; =&gt; 11, &quot;TYPE&quot; =&gt; &quot;SPECIAL&quot;)   Python の例：  cmd_no_checks(&quot;INST COLLECT with DURATION 11, TYPE SPECIAL&quot;) cmd_no_checks(&quot;INST&quot;, &quot;COLLECT&quot;, {&quot;DURATION&quot;: 11, &quot;TYPE&quot;: &quot;SPECIAL&quot;})   ","version":"次へ","tagName":"h3"},{"title":"cmd_raw​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#cmd_raw","content":" 変換を実行せずに指定されたコマンドを送信します。  Ruby 構文：  cmd_raw(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_raw(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;&lt;Param #1 Name&gt;&quot; =&gt; &lt;Param #1 Value&gt;, &quot;&lt;Param #2 Name&gt;&quot; =&gt; &lt;Param #2 Value&gt;, ...)   Python 構文：  cmd_raw(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_raw(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, {&quot;&lt;Param #1 Name&gt;&quot;: &lt;Param #1 Value&gt;, &quot;&lt;Param #2 Name&gt;&quot;: &lt;Param #2 Value&gt;, ...})   パラメータ\t説明Target Name\tこのコマンドに関連付けられているターゲットの名前。 Command Name\tこのコマンドの名前。ニーモニックとも呼ばれます。 Param #x Name\tコマンドパラメータの名前。パラメータがない場合は 'with' キーワードを指定しないでください。 Param #x Value\tコマンドパラメータの値。値は自動的に適切な型に変換されます。 timeout\tデフォルトのタイムアウト値（5秒）を変更するための名前付きパラメータ log_message\tコマンドのログを防ぐための名前付きパラメータ  Ruby の例：  cmd_raw(&quot;INST COLLECT with DURATION 10, TYPE 0&quot;) cmd_raw(&quot;INST&quot;, &quot;COLLECT&quot;, &quot;DURATION&quot; =&gt; 10, &quot;TYPE&quot; =&gt; 0)   Python の例：  cmd_raw(&quot;INST COLLECT with DURATION 10, TYPE 0&quot;) cmd_raw(&quot;INST&quot;, &quot;COLLECT&quot;, {&quot;DURATION&quot;: 10, &quot;TYPE&quot;: 0})   ","version":"次へ","tagName":"h3"},{"title":"cmd_raw_no_range_check​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#cmd_raw_no_range_check","content":" 変換を実行せず、パラメータの範囲チェックも実行せずに指定されたコマンドを送信します。これは、ターゲットをテストするために意図的に不正なコマンドパラメータを送信する必要がある場合にのみ使用してください。  Ruby 構文：  cmd_raw_no_range_check(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_raw_no_range_check(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;&lt;Param #1 Name&gt;&quot; =&gt; &lt;Param #1 Value&gt;, &quot;&lt;Param #2 Name&gt;&quot; =&gt; &lt;Param #2 Value&gt;, ...)   Python 構文：  cmd_raw_no_range_check(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_raw_no_range_check(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, {&quot;&lt;Param #1 Name&gt;&quot;: &lt;Param #1 Value&gt;, &quot;&lt;Param #2 Name&gt;&quot;: &lt;Param #2 Value&gt;, ...})   パラメータ\t説明Target Name\tこのコマンドに関連付けられているターゲットの名前。 Command Name\tこのコマンドの名前。ニーモニックとも呼ばれます。 Param #x Name\tコマンドパラメータの名前。パラメータがない場合は 'with' キーワードを指定しないでください。 Param #x Value\tコマンドパラメータの値。値は自動的に適切な型に変換されます。 timeout\tデフォルトのタイムアウト値（5秒）を変更するための名前付きパラメータ log_message\tコマンドのログを防ぐための名前付きパラメータ  Ruby の例：  cmd_raw_no_range_check(&quot;INST COLLECT with DURATION 11, TYPE 0&quot;) cmd_raw_no_range_check(&quot;INST&quot;, &quot;COLLECT&quot;, &quot;DURATION&quot; =&gt; 11, &quot;TYPE&quot; =&gt; 0)   Python の例：  cmd_raw_no_range_check(&quot;INST COLLECT with DURATION 11, TYPE 0&quot;) cmd_raw_no_range_check(&quot;INST&quot;, &quot;COLLECT&quot;, {&quot;DURATION&quot;: 11, &quot;TYPE&quot;: 0})   ","version":"次へ","tagName":"h3"},{"title":"cmd_raw_no_hazardous_check​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#cmd_raw_no_hazardous_check","content":" 変換を実行せず、コマンドが危険なコマンドである場合の通知も行わずに指定されたコマンドを送信します。これは、危険なコマンドを含むテストを完全に自動化する必要がある場合にのみ使用してください。  Ruby 構文：  cmd_raw_no_hazardous_check(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_raw_no_hazardous_check(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;&lt;Param #1 Name&gt;&quot; =&gt; &lt;Param #1 Value&gt;, &quot;&lt;Param #2 Name&gt;&quot; =&gt; &lt;Param #2 Value&gt;, ...)   Python 構文：  cmd_raw_no_hazardous_check(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_raw_no_hazardous_check(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, {&quot;&lt;Param #1 Name&gt;&quot;: &lt;Param #1 Value&gt;, &quot;&lt;Param #2 Name&gt;&quot;: &lt;Param #2 Value&gt;, ...})   パラメータ\t説明Target Name\tこのコマンドに関連付けられているターゲットの名前。 Command Name\tこのコマンドの名前。ニーモニックとも呼ばれます。 Param #x Name\tコマンドパラメータの名前。パラメータがない場合は 'with' キーワードを指定しないでください。 Param #x Value\tコマンドパラメータの値。値は自動的に適切な型に変換されます。 timeout\tデフォルトのタイムアウト値（5秒）を変更するための名前付きパラメータ log_message\tコマンドのログを防ぐための名前付きパラメータ  Ruby / Python の例：  cmd_raw_no_hazardous_check(&quot;INST CLEAR&quot;) cmd_raw_no_hazardous_check(&quot;INST&quot;, &quot;CLEAR&quot;)   ","version":"次へ","tagName":"h3"},{"title":"cmd_raw_no_checks​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#cmd_raw_no_checks","content":" 変換、パラメータの範囲チェック、およびコマンドが危険なコマンドである場合の通知を実行せずに指定されたコマンドを送信します。これは、意図的に無効なパラメータを持つ危険なコマンドを含むテストを完全に自動化する必要がある場合にのみ使用してください。  Ruby 構文：  cmd_raw_no_checks(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_raw_no_checks(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;&lt;Param #1 Name&gt;&quot; =&gt; &lt;Param #1 Value&gt;, &quot;&lt;Param #2 Name&gt;&quot; =&gt; &lt;Param #2 Value&gt;, ...)   Python 構文：  cmd_raw_no_checks(&quot;&lt;Target Name&gt; &lt;Command Name&gt; with &lt;Param #1 Name&gt; &lt;Param #1 Value&gt;, &lt;Param #2 Name&gt; &lt;Param #2 Value&gt;, ...&quot;) cmd_raw_no_checks(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, {&quot;&lt;Param #1 Name&gt;&quot;: &lt;Param #1 Value&gt;, &quot;&lt;Param #2 Name&gt;&quot;: &lt;Param #2 Value&gt;, ...})   パラメータ\t説明Target Name\tこのコマンドに関連付けられているターゲットの名前。 Command Name\tこのコマンドの名前。ニーモニックとも呼ばれます。 Param #x Name\tコマンドパラメータの名前。パラメータがない場合は 'with' キーワードを指定しないでください。 Param #x Value\tコマンドパラメータの値。値は自動的に適切な型に変換されます。 timeout\tデフォルトのタイムアウト値（5秒）を変更するための名前付きパラメータ log_message\tコマンドのログを防ぐための名前付きパラメータ  Ruby の例：  cmd_raw_no_checks(&quot;INST COLLECT with DURATION 11, TYPE 1&quot;) cmd_raw_no_checks(&quot;INST&quot;, &quot;COLLECT&quot;, &quot;DURATION&quot; =&gt; 11, &quot;TYPE&quot; =&gt; 1)   Python の例：  cmd_raw_no_checks(&quot;INST COLLECT with DURATION 11, TYPE 1&quot;) cmd_raw_no_checks(&quot;INST&quot;, &quot;COLLECT&quot;, {&quot;DURATION&quot;: 11, &quot;TYPE&quot;: 1})   ","version":"次へ","tagName":"h3"},{"title":"build_cmd​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#build_cmd","content":" 5.13.0 から、5.8.0 では build_command として  特定のコマンドの生のバイトを確認できるようにコマンドのバイナリ文字列を構築します。コマンドについてのエンディアン、説明、項目などの情報を取得するには get_cmd を使用してください。  Ruby 構文：  build_cmd(&lt;ARGS&gt;, range_check: true, raw: false)   Python 構文：  build_cmd(&lt;ARGS&gt;, range_check=True, raw=False)   パラメータ\t説明ARGS\tコマンドパラメータ（cmd を参照） range_check\tコマンドの範囲チェックを実行するかどうか。デフォルトは true。 raw\tコマンド引数を RAW または CONVERTED 値として書き込むかどうか。デフォルトは CONVERTED。  Ruby の例：  x = build_cmd(&quot;INST COLLECT with DURATION 10, TYPE NORMAL&quot;) puts x #=&gt; {&quot;id&quot;=&gt;&quot;1696437370872-0&quot;, &quot;result&quot;=&gt;&quot;SUCCESS&quot;, &quot;time&quot;=&gt;&quot;1696437370872305961&quot;, &quot;received_time&quot;=&gt;&quot;1696437370872305961&quot;, &quot;target_name&quot;=&gt;&quot;INST&quot;, &quot;packet_name&quot;=&gt;&quot;COLLECT&quot;, &quot;received_count&quot;=&gt;&quot;3&quot;, &quot;buffer&quot;=&gt;&quot;\\x13\\xE7\\xC0\\x00\\x00\\f\\x00\\x01\\x00\\x00A \\x00\\x00\\xAB\\x00\\x00\\x00\\x00&quot;}   Python の例：  x = build_cmd(&quot;INST COLLECT with DURATION 10, TYPE NORMAL&quot;) print(x) #=&gt; {'id': '1697298167748-0', 'result': 'SUCCESS', 'time': '1697298167749155717', 'received_time': '1697298167749155717', 'target_name': 'INST', 'packet_name': 'COLLECT', 'received_count': '2', 'buffer': bytearray(b'\\x13\\xe7\\xc0\\x00\\x00\\x0c\\x00\\x01\\x00\\x00A \\x00\\x00\\xab\\x00\\x00\\x00\\x00')}   ","version":"次へ","tagName":"h3"},{"title":"enable_cmd​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#enable_cmd","content":" 5.15.1 から  無効化されたコマンドを有効にします。無効化されたコマンドを送信すると、「INST ABORT is Disabled」のようなメッセージで DisabledError が発生します。  Ruby / Python 構文：  buffer = enable_cmd(&quot;&lt;Target Name&gt; &lt;Command Name&gt;&quot;) buffer = enable_cmd(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。 Packet Name\tコマンド（パケット）の名前。  Ruby / Python の例：  enable_cmd(&quot;INST ABORT&quot;)   ","version":"次へ","tagName":"h3"},{"title":"disable_cmd​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#disable_cmd","content":" 5.15.1 から  コマンドを無効にします。無効化されたコマンドを送信すると、「INST ABORT is Disabled」のようなメッセージで DisabledError が発生します。  Ruby / Python 構文：  buffer = disable_cmd(&quot;&lt;Target Name&gt; &lt;Command Name&gt;&quot;) buffer = disable_cmd(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。 Packet Name\tコマンド（パケット）の名前。  Ruby / Python の例：  disable_cmd(&quot;INST ABORT&quot;)   ","version":"次へ","tagName":"h3"},{"title":"send_raw​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#send_raw","content":" インターフェース上で生のデータを送信します。  Ruby / Python 構文：  send_raw(&lt;Interface Name&gt;, &lt;Data&gt;)   パラメータ\t説明Interface Name\t生のデータを送信するインターフェースの名前。 Data\t送信する生のデータのRuby文字列。  Ruby / Python の例：  send_raw(&quot;INST_INT&quot;, data)   ","version":"次へ","tagName":"h3"},{"title":"get_all_cmds​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_all_cmds","content":" 5.13.0 から、5.0.0 では get_all_commands として  特定のターゲットで利用可能なコマンドの配列を返します。返される配列は、コマンドパケットを完全に記述するハッシュの配列（Pythonではディクショナリのリスト）です。  Ruby / Python 構文：  get_all_cmds(&quot;&lt;Target Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。  Ruby の例：  cmd_list = get_all_cmds(&quot;INST&quot;) puts cmd_list #=&gt; # [{&quot;target_name&quot;=&gt;&quot;INST&quot;, # &quot;packet_name&quot;=&gt;&quot;ABORT&quot;, # &quot;endianness&quot;=&gt;&quot;BIG_ENDIAN&quot;, # &quot;description&quot;=&gt;&quot;Aborts a collect on the instrument&quot;, # &quot;items&quot;=&gt; [{&quot;name&quot;=&gt;&quot;CCSDSVER&quot;, &quot;bit_offset&quot;=&gt;0, &quot;bit_size&quot;=&gt;3, ... }] # ... # }]   Python の例：  cmd_list = get_all_cmds(&quot;INST&quot;) print(cmd_list) #=&gt; # [{'target_name': 'INST', # 'packet_name': 'ABORT', # 'endianness': 'BIG_ENDIAN', # 'description': 'Aborts a collect on the INST instrument', # 'items': [{'name': 'CCSDSVER', 'bit_offset': 0, 'bit_size': 3, ... }] # ... # }]   ","version":"次へ","tagName":"h3"},{"title":"get_all_cmd_names​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_all_cmd_names","content":" 5.13.0 から、5.0.6 では get_all_command_names として  特定のターゲットのコマンド名の配列を返します。  Ruby / Python 構文：  get_all_cmd_names(&quot;&lt;Target Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前  Ruby の例：  cmd_list = get_all_cmd_names(&quot;INST&quot;) puts cmd_list #=&gt; ['ABORT', 'ARYCMD', 'ASCIICMD', ...]   Python の例：  cmd_list = get_all_cmd_names(&quot;INST&quot;) print(cmd_list) #=&gt; ['ABORT', 'ARYCMD', 'ASCIICMD', ...]   ","version":"次へ","tagName":"h3"},{"title":"get_cmd​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_cmd","content":" 5.13.0 から、5.0.0 では get_command として  コマンドパケットを完全に記述するコマンドハッシュを返します。構築済みコマンドのバイナリバッファを取得するには build_cmd を使用してください。  Ruby / Python 構文：  get_cmd(&quot;&lt;Target Name&gt; &lt;Packet Name&gt;&quot;) get_cmd(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Packet Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。 Packet Name\tパケットの名前。  Ruby / Python の例：  abort_cmd = get_cmd(&quot;INST ABORT&quot;) puts abort_cmd #=&gt; # [{&quot;target_name&quot;=&gt;&quot;INST&quot;, # &quot;packet_name&quot;=&gt;&quot;ABORT&quot;, # &quot;endianness&quot;=&gt;&quot;BIG_ENDIAN&quot;, # &quot;description&quot;=&gt;&quot;Aborts a collect on the instrument&quot;, # &quot;items&quot;=&gt; [{&quot;name&quot;=&gt;&quot;CCSDSVER&quot;, &quot;bit_offset&quot;=&gt;0, &quot;bit_size&quot;=&gt;3, ... }] # ... # }]   Python の例：  abort_cmd = get_cmd(&quot;INST ABORT&quot;) print(abort_cmd) #=&gt; # [{'target_name': 'INST', # 'packet_name': 'ABORT', # 'endianness': 'BIG_ENDIAN', # 'description': 'Aborts a collect on the INST instrument', # 'items': [{'name': 'CCSDSVER', 'bit_offset': 0, 'bit_size': 3, ... }] # ... # }]   ","version":"次へ","tagName":"h3"},{"title":"get_param​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_param","content":" 5.13.0 から、5.0.0 では get_parameter として  指定されたコマンドパラメータのハッシュを返します  Ruby / Python 構文：  get_param(&quot;&lt;Target Name&gt; &lt;Command Name&gt; &lt;Parameter Name&gt;&quot;) get_param(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;&lt;Parameter Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。 Command Name\tコマンドの名前。 Parameter Name\tパラメータの名前。  Ruby の例：  param = get_param(&quot;INST COLLECT TYPE&quot;) puts param #=&gt; # {&quot;name&quot;=&gt;&quot;TYPE&quot;, &quot;bit_offset&quot;=&gt;64, &quot;bit_size&quot;=&gt;16, &quot;data_type&quot;=&gt;&quot;UINT&quot;, # &quot;description&quot;=&gt;&quot;Collect type which can be normal or special&quot;, &quot;default&quot;=&gt;0, # &quot;minimum&quot;=&gt;0, &quot;maximum&quot;=&gt;65535, &quot;endianness&quot;=&gt;&quot;BIG_ENDIAN&quot;, &quot;required&quot;=&gt;true, &quot;overflow&quot;=&gt;&quot;ERROR&quot;, # &quot;states&quot;=&gt;{&quot;NORMAL&quot;=&gt;{&quot;value&quot;=&gt;0}, &quot;SPECIAL&quot;=&gt;{&quot;value&quot;=&gt;1, &quot;hazardous&quot;=&gt;&quot;&quot;}}, &quot;limits&quot;=&gt;{}}   Python の例：  param = get_param(&quot;INST COLLECT TYPE&quot;) print(param) #=&gt; # {'name': 'TYPE', 'bit_offset': 64, 'bit_size': 16, 'data_type': 'UINT', # 'description': 'Collect type which can be normal or special', 'default': 0, # 'minimum': 0, 'maximum': 65535, 'endianness': 'BIG_ENDIAN', 'required': True, 'overflow': 'ERROR', # 'states': {'NORMAL': {'value': 0}, 'SPECIAL': {'value': 1, 'hazardous': ''}}, 'limits': {}}   ","version":"次へ","tagName":"h3"},{"title":"get_cmd_buffer​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_cmd_buffer","content":" Ruby文字列としての生のパケットバッファとともにパケットハッシュ（get_cmdと同様）を返します。  Ruby / Python 構文：  buffer = get_cmd_buffer(&quot;&lt;Target Name&gt; &lt;Packet Name&gt;&quot;)['buffer'] buffer = get_cmd_buffer(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Packet Name&gt;&quot;)['buffer']   パラメータ\t説明Target Name\tターゲットの名前。 Packet Name\tパケットの名前。  Ruby の例：  packet = get_cmd_buffer(&quot;INST COLLECT&quot;) puts packet #=&gt; # {&quot;time&quot;=&gt;&quot;1697298846752053420&quot;, &quot;received_time&quot;=&gt;&quot;1697298846752053420&quot;, # &quot;target_name&quot;=&gt;&quot;INST&quot;, &quot;packet_name&quot;=&gt;&quot;COLLECT&quot;, &quot;received_count&quot;=&gt;&quot;20&quot;, &quot;stored&quot;=&gt;&quot;false&quot;, # &quot;buffer&quot;=&gt;&quot;\\x13\\xE7\\xC0\\x00\\x00\\f\\x00\\x01\\x00\\x00@\\xE0\\x00\\x00\\xAB\\x00\\x00\\x00\\x00&quot;}   Python の例：  packet = get_cmd_buffer(&quot;INST COLLECT&quot;) print(packet) #=&gt; # {'time': '1697298923745982470', 'received_time': '1697298923745982470', # 'target_name': 'INST', 'packet_name': 'COLLECT', 'received_count': '21', 'stored': 'false', # 'buffer': bytearray(b'\\x13\\xe7\\xc0\\x00\\x00\\x0c\\x00\\x01\\x00\\x00@\\xe0\\x00\\x00\\xab\\x00\\x00\\x00\\x00')}   ","version":"次へ","tagName":"h3"},{"title":"get_cmd_hazardous​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_cmd_hazardous","content":" 特定のコマンドが危険としてフラグが立てられているかどうかを示すtrue/falseを返します。  Ruby / Python 構文：  get_cmd_hazardous(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &lt;Command Params - optional&gt;)   パラメータ\t説明Target Name\tターゲットの名前。 Command Name\tコマンドの名前。 Command Params\tコマンドに渡されるパラメータのハッシュ（オプション）。一部のコマンドはパラメータの状態に基づいてのみ危険です。  Ruby の例：  hazardous = get_cmd_hazardous(&quot;INST&quot;, &quot;COLLECT&quot;, {'TYPE' =&gt; 'SPECIAL'}) puts hazardous #=&gt; true   Python の例：  hazardous = get_cmd_hazardous(&quot;INST&quot;, &quot;COLLECT&quot;, {'TYPE': 'SPECIAL'}) print(hazardous) #=&gt; True   ","version":"次へ","tagName":"h3"},{"title":"get_cmd_value​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_cmd_value","content":" 最後に送信されたコマンドパケットから値を読み取ります。擬似パラメータの「PACKET_TIMESECONDS」、「PACKET_TIMEFORMATTED」、「RECEIVED_COUNT」、「RECEIVED_TIMEFORMATTED」、および「RECEIVED_TIMESECONDS」もサポートされています。  Ruby / Python 構文：  get_cmd_value(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;&lt;Parameter Name&gt;&quot;, &lt;Value Type - optional&gt;)   パラメータ\t説明Target Name\tターゲットの名前。 Command Name\tコマンドの名前。 Parameter Name\tコマンドパラメータの名前。 Value Type\t読み取る値のタイプ。RAW、CONVERTED、FORMATTED、または WITH_UNITS。注：Ruby ではシンボル、Python では文字列  Ruby の例：  value = get_cmd_value(&quot;INST&quot;, &quot;COLLECT&quot;, &quot;TEMP&quot;, :RAW) puts value #=&gt; 0.0   Python の例：  value = get_cmd_value(&quot;INST&quot;, &quot;COLLECT&quot;, &quot;TEMP&quot;, &quot;RAW&quot;) print(value) #=&gt; 0.0   ","version":"次へ","tagName":"h3"},{"title":"get_cmd_time​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_cmd_time","content":" 最近送信されたコマンドの時間を返します。  Ruby / Python 構文：  get_cmd_time(&quot;&lt;Target Name - optional&gt;&quot;, &quot;&lt;Command Name - optional&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。指定されない場合、任意のターゲットへの最新のコマンド時間が返されます Command Name\tコマンドの名前。指定されない場合、指定されたターゲットへの最新のコマンド時間が返されます  Ruby / Python の例：  target_name, command_name, time = get_cmd_time() # 任意のターゲットに送信された最新のコマンドの名前と時間 target_name, command_name, time = get_cmd_time(&quot;INST&quot;) # INSTターゲットに送信された最新のコマンドの名前と時間 target_name, command_name, time = get_cmd_time(&quot;INST&quot;, &quot;COLLECT&quot;) # 最新のINST COLLECTコマンドの名前と時間   ","version":"次へ","tagName":"h3"},{"title":"get_cmd_cnt​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_cmd_cnt","content":" 指定されたコマンドが送信された回数を返します。  Ruby / Python 構文：  get_cmd_cnt(&quot;&lt;Target Name&gt; &lt;Command Name&gt;&quot;) get_cmd_cnt(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。 Command Name\tコマンドの名前。  Ruby / Python の例：  cmd_cnt = get_cmd_cnt(&quot;INST COLLECT&quot;) # INST COLLECTコマンドが送信された回数   ","version":"次へ","tagName":"h3"},{"title":"get_cmd_cnts​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_cmd_cnts","content":" 指定されたコマンドが送信された回数を返します。  Ruby / Python 構文：  get_cmd_cnts([[&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;], [&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;], ...])   パラメータ\t説明Target Name\tターゲットの名前。 Command Name\tコマンドの名前。  Ruby / Python の例：  cmd_cnt = get_cmd_cnts([['INST', 'COLLECT'], ['INST', 'ABORT']]) # INST COLLECTとINST ABORTコマンドが送信された回数   ","version":"次へ","tagName":"h3"},{"title":"critical_cmd_status​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#critical_cmd_status","content":" クリティカルコマンドのステータスを返します。APPROVED、REJECTED、または WAITINGのいずれかです。  5.20.0 から  Ruby / Python 構文：  critical_cmd_status(uuid)   パラメータ\t説明uuid\tクリティカルコマンドのUUID（COSMOS GUIに表示されます）  Ruby / Python の例：  status = critical_cmd_status(&quot;2fa14183-3148-4399-9a74-a130257118f9&quot;) #=&gt; WAITING   ","version":"次へ","tagName":"h3"},{"title":"critical_cmd_approve​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#critical_cmd_approve","content":" 現在のユーザーとしてクリティカルコマンドを承認します。  5.20.0 から  Ruby / Python 構文：  critical_cmd_approve(uuid)   パラメータ\t説明uuid\tクリティカルコマンドのUUID（COSMOS GUIに表示されます）  Ruby / Python の例：  critical_cmd_approve(&quot;2fa14183-3148-4399-9a74-a130257118f9&quot;)   ","version":"次へ","tagName":"h3"},{"title":"critical_cmd_reject​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#critical_cmd_reject","content":" 現在のユーザーとしてクリティカルコマンドを拒否します。  5.20.0 から  Ruby / Python 構文：  critical_cmd_reject(uuid)   パラメータ\t説明uuid\tクリティカルコマンドのUUID（COSMOS GUIに表示されます）  Ruby / Python の例：  critical_cmd_reject(&quot;2fa14183-3148-4399-9a74-a130257118f9&quot;)   ","version":"次へ","tagName":"h3"},{"title":"critical_cmd_can_approve​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#critical_cmd_can_approve","content":" 現在のユーザーがクリティカルコマンドを承認できるかどうかを返します。  5.20.0 から  Ruby / Python 構文：  critical_cmd_can_approve(uuid)   パラメータ\t説明uuid\tクリティカルコマンドのUUID（COSMOS GUIに表示されます）  Ruby / Python の例：  status = critical_cmd_can_approve(&quot;2fa14183-3148-4399-9a74-a130257118f9&quot;) #=&gt; true / false   ","version":"次へ","tagName":"h3"},{"title":"テレメトリの処理​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#テレメトリの処理","content":" これらのメソッドを使用すると、ユーザーはテレメトリ項目を操作できます。  ","version":"次へ","tagName":"h2"},{"title":"check, check_raw, check_formatted, check_with_units​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#check-check_raw-check_formatted-check_with_units","content":" 指定されたテレメトリタイプを使用してテレメトリ項目の検証を実行します。検証が失敗すると、スクリプトはエラーで一時停止します。検証するための比較が与えられていない場合、テレメトリ項目は単にスクリプト出力に表示されます。注意: ほとんどの場合、check よりも wait_check を使用する方が良い選択です。  Ruby / Python 構文：  check(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt; &lt;Comparison - optional&gt;&quot;)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前。 Packet Name\tテレメトリ項目のテレメトリパケットの名前。 Item Name\tテレメトリ項目の名前。 Comparison\tテレメトリ項目に対して実行する比較。比較が与えられていない場合、テレメトリ項目はスクリプトログに表示されるだけです。  Ruby の例：  check(&quot;INST HEALTH_STATUS COLLECTS &gt; 1&quot;) check_raw(&quot;INST HEALTH_STATUS COLLECTS &gt; 1&quot;) check_formatted(&quot;INST HEALTH_STATUS COLLECTS &gt; 1&quot;) check_with_units(&quot;INST HEALTH_STATUS COLLECTS &gt; 1&quot;) # Rubyではタイプをシンボルとして渡します check(&quot;INST HEALTH_STATUS COLLECTS &gt; 1&quot;, type: :RAW)   Python の例：  check(&quot;INST HEALTH_STATUS COLLECTS &gt; 1&quot;) check_raw(&quot;INST HEALTH_STATUS COLLECTS &gt; 1&quot;) check_formatted(&quot;INST HEALTH_STATUS COLLECTS &gt; 1&quot;) check_with_units(&quot;INST HEALTH_STATUS COLLECTS &gt; 1&quot;) # Pythonではタイプを文字列として渡します check(&quot;INST HEALTH_STATUS COLLECTS &gt; 1&quot;, type='RAW')   ","version":"次へ","tagName":"h3"},{"title":"check_tolerance​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#check_tolerance","content":" 変換されたテレメトリ項目を許容範囲内の期待値と比較します。検証が失敗すると、スクリプトはエラーで一時停止します。注意: ほとんどの場合、check_tolerance よりも wait_check_tolerance を使用する方が良い選択です。  Ruby / Python 構文：  check_tolerance(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt;&quot;, &lt;Expected Value&gt;, &lt;Tolerance&gt;)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前。 Packet Name\tテレメトリ項目のテレメトリパケットの名前。 Item Name\tテレメトリ項目の名前。 Expected Value\tテレメトリ項目の期待値。 Tolerance\t期待値に対する±許容範囲。 type\tCONVERTED（デフォルト）または RAW（Rubyではシンボル、Pythonでは文字列）  Ruby の例：  check_tolerance(&quot;INST HEALTH_STATUS COLLECTS&quot;, 10.0, 5.0) check_tolerance(&quot;INST HEALTH_STATUS TEMP1&quot;, 50000, 20000, type: :RAW)   Python の例：  check_tolerance(&quot;INST HEALTH_STATUS COLLECTS&quot;, 10.0, 5.0) check_tolerance(&quot;INST HEALTH_STATUS TEMP1&quot;, 50000, 20000, type='RAW')   ","version":"次へ","tagName":"h3"},{"title":"check_expression​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#check_expression","content":" 式を評価します。式が false と評価されると、スクリプトはエラーで一時停止します。この方法は、例に示すように check を使用するよりも複雑な比較を実行するために使用できます。注意: ほとんどの場合、check_expression よりも wait_check_expression を使用するほうが良い選択です。  check_expression 文字列内のすべては直接評価されるため、有効な構文である必要があることに注意してください。よくある間違いは、変数を次のようにチェックすることです（Ruby変数の補間）：  check_expression(&quot;#{answer} == 'yes'&quot;) # answerに'yes'が含まれている場合  これは yes == 'yes' と評価されますが、yes 変数は（通常）定義されていないため、有効な構文ではありません。この式を書く正しい方法は次のとおりです：  check_expression(&quot;'#{answer}' == 'yes'&quot;) # answerに'yes'が含まれている場合  これにより、'yes' == 'yes' と評価され、true なのでチェックは合格します。  Ruby 構文：  check_expression(exp_to_eval, context = nil)   Python 構文：  check_expression(exp_to_eval, globals=None, locals=None)   パラメータ\t説明exp_to_eval\t評価する式。 context (rubyのみ)\teval を呼び出すコンテキスト。デフォルトは nil。Ruby のコンテキストは通常 binding() であり、通常は必要ありません。 globals (pythonのみ)\teval を呼び出すグローバル。デフォルトは None。tlm() などの COSMOS API を使用するには globals() を渡す必要があることに注意してください。 locals (pythonのみ)\teval を呼び出すローカル。デフォルトは None。メソッドでローカル変数を使用している場合は locals() を渡す必要があることに注意してください。  Ruby の例：  check_expression(&quot;tlm('INST HEALTH_STATUS COLLECTS') &gt; 5 and tlm('INST HEALTH_STATUS TEMP1') &gt; 25.0&quot;)   Python の例：  def check(value): # ここでは tlm() とローカル変数 'value' の両方を使用しているため、globals() と locals() を渡す必要があります check_expression(&quot;tlm('INST HEALTH_STATUS COLLECTS') &gt; value&quot;, 5, 0.25, globals(), locals()) check(5)   ","version":"次へ","tagName":"h3"},{"title":"check_exception​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#check_exception","content":" メソッドを実行し、例外が発生することを期待します。メソッドが例外を発生させない場合、CheckError が発生します。  Ruby / Python 構文：  check_exception(&quot;&lt;Method Name&gt;&quot;, &quot;&lt;Method Params - optional&gt;&quot;)   パラメータ\t説明Method Name\t実行するCOSMOSスクリプティングメソッド（例：'cmd'など）。 Method Params\tメソッドのパラメータ  Ruby の例：  check_exception(&quot;cmd&quot;, &quot;INST&quot;, &quot;COLLECT&quot;, &quot;TYPE&quot; =&gt; &quot;NORMAL&quot;)   Python の例：  check_exception(&quot;cmd&quot;, &quot;INST&quot;, &quot;COLLECT&quot;, {&quot;TYPE&quot;: &quot;NORMAL&quot;})   ","version":"次へ","tagName":"h3"},{"title":"tlm, tlm_raw, tlm_formatted, tlm_with_units​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#tlm-tlm_raw-tlm_formatted-tlm_with_units","content":" テレメトリ項目の指定された形式を読み取ります。  Ruby / Python 構文：  tlm(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt;&quot;) tlm(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Packet Name&gt;&quot;, &quot;&lt;Item Name&gt;&quot;)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前。 Packet Name\tテレメトリ項目のテレメトリパケットの名前。 Item Name\tテレメトリ項目の名前。 type\tタイプを指定する名前付きパラメータ。RAW、CONVERTED（デフォルト）、FORMATTED、WITH_UNITS（Rubyではシンボル、Pythonでは文字列）。  Ruby の例：  value = tlm(&quot;INST HEALTH_STATUS COLLECTS&quot;) value = tlm(&quot;INST&quot;, &quot;HEALTH_STATUS&quot;, &quot;COLLECTS&quot;) value = tlm_raw(&quot;INST HEALTH_STATUS COLLECTS&quot;) value = tlm_formatted(&quot;INST HEALTH_STATUS COLLECTS&quot;) value = tlm_with_units(&quot;INST HEALTH_STATUS COLLECTS&quot;) # tlm_raw と同等 raw_value = tlm(&quot;INST HEALTH_STATUS COLLECTS&quot;, type: :RAW)   Python の例：  value = tlm(&quot;INST HEALTH_STATUS COLLECTS&quot;) value = tlm(&quot;INST&quot;, &quot;HEALTH_STATUS&quot;, &quot;COLLECTS&quot;) value = tlm_raw(&quot;INST HEALTH_STATUS COLLECTS&quot;) value = tlm_formatted(&quot;INST HEALTH_STATUS COLLECTS&quot;) value = tlm_with_units(&quot;INST HEALTH_STATUS COLLECTS&quot;) # tlm_raw と同等 raw_value = tlm(&quot;INST HEALTH_STATUS COLLECTS&quot;, type='RAW')   ","version":"次へ","tagName":"h3"},{"title":"get_tlm_buffer​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_tlm_buffer","content":" 生のパケットバッファとともにパケットハッシュ（get_tlm と同様）を返します。  Ruby / Python 構文：  buffer = get_tlm_buffer(&quot;&lt;Target Name&gt; &lt;Packet Name&gt;&quot;)['buffer'] buffer = get_tlm_buffer(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Packet Name&gt;&quot;)['buffer']   パラメータ\t説明Target Name\tターゲットの名前。 Packet Name\tパケットの名前。  Ruby / Python の例：  packet = get_tlm_buffer(&quot;INST HEALTH_STATUS&quot;) packet['buffer']   ","version":"次へ","tagName":"h3"},{"title":"get_tlm_packet​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_tlm_packet","content":" 指定されたパケット内のすべてのテレメトリ項目の名前、値、およびリミット状態を返します。値は [item_name, item_value, limits_state] を含む配列の配列として返されます。  Ruby / Python 構文：  get_tlm_packet(&quot;&lt;Target Name&gt; &lt;Packet Name&gt;&quot;, &lt;type&gt;) get_tlm_packet(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Packet Name&gt;&quot;, &lt;type&gt;)   パラメータ\t説明Target Name\tターゲットの名前。 Packet Name\tパケットの名前。 type\tタイプを指定する名前付きパラメータ。RAW、CONVERTED（デフォルト）、FORMATTED、または WITH_UNITS（Rubyではシンボル、Pythonでは文字列）。  Ruby の例：  names_values_and_limits_states = get_tlm_packet(&quot;INST HEALTH_STATUS&quot;, type: :FORMATTED)   Python の例：  names_values_and_limits_states = get_tlm_packet(&quot;INST HEALTH_STATUS&quot;, type='FORMATTED')   ","version":"次へ","tagName":"h3"},{"title":"get_tlm_values​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_tlm_values","content":" 指定されたテレメトリ項目のセットの値と現在のリミット状態を返します。項目はシステム内の任意のテレメトリパケットに含めることができます。すべて同じ値タイプを使用して取得することも、各項目に特定の値タイプを指定することもできます。  Ruby / Python 構文：  values, limits_states, limits_settings, limits_set = get_tlm_values(&lt;Items&gt;)   パラメータ\t説明Items\t['TGT__PKT__ITEM__TYPE', ... ] 形式の文字列の配列  Ruby / Python の例：  values = get_tlm_values([&quot;INST__HEALTH_STATUS__TEMP1__CONVERTED&quot;, &quot;INST__HEALTH_STATUS__TEMP2__RAW&quot;]) print(values) # [[-100.0, :RED_LOW], [0, :RED_LOW]]   ","version":"次へ","tagName":"h3"},{"title":"get_all_tlm​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_all_tlm","content":" 5.13.0 から、5.0.0 では get_all_telemetry として  すべてのターゲットパケットハッシュの配列を返します。  Ruby / Python 構文：  get_all_tlm(&quot;&lt;Target Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。  Ruby / Python の例：  packets = get_all_tlm(&quot;INST&quot;) print(packets) #[{&quot;target_name&quot;=&gt;&quot;INST&quot;, # &quot;packet_name&quot;=&gt;&quot;ADCS&quot;, # &quot;endianness&quot;=&gt;&quot;BIG_ENDIAN&quot;, # &quot;description&quot;=&gt;&quot;Position and attitude data&quot;, # &quot;stale&quot;=&gt;true, # &quot;items&quot;=&gt; # [{&quot;name&quot;=&gt;&quot;CCSDSVER&quot;, # &quot;bit_offset&quot;=&gt;0, # &quot;bit_size&quot;=&gt;3, # ...   ","version":"次へ","tagName":"h3"},{"title":"get_all_tlm_names​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_all_tlm_names","content":" 5.13.0 から、5.0.6 では get_all_telemetry_names として  すべてのターゲットパケット名の配列を返します。  Ruby / Python 構文：  get_all_tlm_names(&quot;&lt;Target Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前  Ruby / Python の例：  get_all_tlm_names(&quot;INST&quot;) #=&gt; [&quot;ADCS&quot;, &quot;HEALTH_STATUS&quot;, ...]   ","version":"次へ","tagName":"h3"},{"title":"get_all_tlm_item_names​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_all_tlm_item_names","content":" ターゲット内のすべてのパケットのすべての項目名を返します  Ruby / Python 構文：  get_all_tlm_item_names(&quot;&lt;Target Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前  Ruby / Python の例：  get_all_tlm_item_names(&quot;INST&quot;) #=&gt; [&quot;ARY&quot;, &quot;ARY2&quot;, &quot;ASCIICMD&quot;, &quot;ATTPROGRESS&quot;, ...]   ","version":"次へ","tagName":"h3"},{"title":"get_tlm​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_tlm","content":" 5.13.0 から、5.0.0 では get_telemetry として  パケットハッシュを返します。  Ruby / Python 構文：  get_tlm(&quot;&lt;Target Name&gt; &lt;Packet Name&gt;&quot;) get_tlm(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Packet Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。 Packet Name\tパケットの名前。  Ruby / Python の例：  packet = get_tlm(&quot;INST HEALTH_STATUS&quot;) print(packet) #{&quot;target_name&quot;=&gt;&quot;INST&quot;, # &quot;packet_name&quot;=&gt;&quot;HEALTH_STATUS&quot;, # &quot;endianness&quot;=&gt;&quot;BIG_ENDIAN&quot;, # &quot;description&quot;=&gt;&quot;Health and status from the instrument&quot;, # &quot;stale&quot;=&gt;true, # &quot;processors&quot;=&gt; # [{&quot;name&quot;=&gt;&quot;TEMP1STAT&quot;, # &quot;class&quot;=&gt;&quot;OpenC3::StatisticsProcessor&quot;, # &quot;params&quot;=&gt;[&quot;TEMP1&quot;, 100, &quot;CONVERTED&quot;]}, # {&quot;name&quot;=&gt;&quot;TEMP1WATER&quot;, # &quot;class&quot;=&gt;&quot;OpenC3::WatermarkProcessor&quot;, # &quot;params&quot;=&gt;[&quot;TEMP1&quot;, &quot;CONVERTED&quot;]}], # &quot;items&quot;=&gt; # [{&quot;name&quot;=&gt;&quot;CCSDSVER&quot;, # &quot;bit_offset&quot;=&gt;0, # &quot;bit_size&quot;=&gt;3, # ...   ","version":"次へ","tagName":"h3"},{"title":"get_item​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_item","content":" 項目ハッシュを返します。  Ruby / Python 構文：  get_item(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt;&quot;) get_item(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Packet Name&gt;&quot;, &quot;&lt;Item Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。 Packet Name\tパケットの名前。 Item Name\t項目の名前。  Ruby / Python の例：  item = get_item(&quot;INST HEALTH_STATUS CCSDSVER&quot;) print(item) #{&quot;name&quot;=&gt;&quot;CCSDSVER&quot;, # &quot;bit_offset&quot;=&gt;0, # &quot;bit_size&quot;=&gt;3, # &quot;data_type&quot;=&gt;&quot;UINT&quot;, # &quot;description&quot;=&gt;&quot;CCSDS packet version number (See CCSDS 133.0-B-1)&quot;, # &quot;endianness&quot;=&gt;&quot;BIG_ENDIAN&quot;, # &quot;required&quot;=&gt;false, # &quot;overflow&quot;=&gt;&quot;ERROR&quot;}   ","version":"次へ","tagName":"h3"},{"title":"get_tlm_cnt​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_tlm_cnt","content":" 指定されたテレメトリパケットが受信された回数を返します。  Ruby / Python 構文：  get_tlm_cnt(&quot;&lt;Target Name&gt; &lt;Packet Name&gt;&quot;) get_tlm_cnt(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Packet Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。 Packet Name\tテレメトリパケットの名前。  Ruby / Python の例：  tlm_cnt = get_tlm_cnt(&quot;INST HEALTH_STATUS&quot;) # INST HEALTH_STATUS テレメトリパケットが受信された回数   ","version":"次へ","tagName":"h3"},{"title":"set_tlm​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#set_tlm","content":" コマンドおよびテレメトリサーバーでテレメトリ項目の値を設定します。この値は、インターフェースから新しいパケットが受信されると上書きされます。そのため、このメソッドは、インターフェースが切断されている場合や、Script Runnerの切断モードを介したテストに最も役立ちます。テレメトリ値を手動で設定することで、スクリプト内の多くの論理パスを実行できます。  Ruby / Python 構文：  set_tlm(&quot;&lt;Target&gt; &lt;Packet&gt; &lt;Item&gt; = &lt;Value&gt;&quot;, &lt;type&gt;)   パラメータ\t説明Target\tターゲット名 Packet\tパケット名 Item\t項目名 Value\t設定する値 type\t値のタイプ RAW、CONVERTED（デフォルト）、FORMATTED、WITH_UNITS（Rubyではシンボル、Pythonでは文字列）  Ruby の例：  set_tlm(&quot;INST HEALTH_STATUS COLLECTS = 5&quot;) # type はデフォルトで :CONVERTED です check(&quot;INST HEALTH_STATUS COLLECTS == 5&quot;) set_tlm(&quot;INST HEALTH_STATUS COLLECTS = 10&quot;, type: :RAW) check(&quot;INST HEALTH_STATUS COLLECTS == 10&quot;, type: :RAW)   Python の例：  set_tlm(&quot;INST HEALTH_STATUS COLLECTS = 5&quot;) # type はデフォルトで CONVERTED です check(&quot;INST HEALTH_STATUS COLLECTS == 5&quot;) set_tlm(&quot;INST HEALTH_STATUS COLLECTS = 10&quot;, type='RAW') check(&quot;INST HEALTH_STATUS COLLECTS == 10&quot;, type='RAW')   ","version":"次へ","tagName":"h3"},{"title":"inject_tlm​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#inject_tlm","content":" インターフェースから受信したかのようにパケットをシステムに注入します。  Ruby / Packet 構文：  inject_tlm(&quot;&lt;target_name&gt;&quot;, &quot;&lt;packet_name&gt;&quot;, &lt;item_hash&gt;, &lt;type&gt;)   パラメータ\t説明Target\tターゲット名 Packet\tパケット名 Item Hash\t各項目の項目名/値のハッシュ。ハッシュで項目が指定されていない場合、現在の値テーブルの値が使用されます。オプションのパラメータ、デフォルトは nil。 type\t項目ハッシュの値のタイプ、RAW、CONVERTED（デフォルト）、FORMATTED、WITH_UNITS（Rubyではシンボル、Pythonでは文字列）  Ruby の例：  inject_tlm(&quot;INST&quot;, &quot;PARAMS&quot;, {'VALUE1' =&gt; 5.0, 'VALUE2' =&gt; 7.0})   Python の例：  inject_tlm(&quot;INST&quot;, &quot;PARAMS&quot;, {'VALUE1': 5.0, 'VALUE2': 7.0})   ","version":"次へ","tagName":"h3"},{"title":"override_tlm​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#override_tlm","content":" コマンドおよびテレメトリサーバーでテレメトリポイントの変換値を設定します。この値は、normalize_tlm メソッドでオーバーライドがキャンセルされない限り、インターフェース上で新しいパケットが受信されても維持されます。  Ruby / Python 構文：  override_tlm(&quot;&lt;Target&gt; &lt;Packet&gt; &lt;Item&gt; = &lt;Value&gt;&quot;, &lt;type&gt;)   パラメータ\t説明Target\tターゲット名 Packet\tパケット名 Item\t項目名 Value\t設定する値 type\tオーバーライドするタイプ、ALL（デフォルト）、RAW、CONVERTED、FORMATTED、WITH_UNITS（Rubyではシンボル、Pythonでは文字列）  Ruby の例：  override_tlm(&quot;INST HEALTH_STATUS TEMP1 = 5&quot;) # TEMP1に対するすべてのリクエストが5を返す override_tlm(&quot;INST HEALTH_STATUS TEMP2 = 0&quot;, type: :RAW) # RAW tlmのみが0に設定される   Python の例：  override_tlm(&quot;INST HEALTH_STATUS TEMP1 = 5&quot;) # TEMP1に対するすべてのリクエストが5を返す override_tlm(&quot;INST HEALTH_STATUS TEMP2 = 0&quot;, type='RAW') # RAW tlmのみが0に設定される   ","version":"次へ","tagName":"h3"},{"title":"normalize_tlm​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#normalize_tlm","content":" コマンドおよびテレメトリサーバーでのテレメトリポイントのオーバーライドをクリアします。  Ruby / Python 構文：  normalize_tlm(&quot;&lt;Target&gt; &lt;Packet&gt; &lt;Item&gt;&quot;, &lt;type&gt;)   パラメータ\t説明Target\tターゲット名 Packet\tパケット名 Item\t項目名 type\t正規化するタイプ、ALL（デフォルト）、RAW、CONVERTED、FORMATTED、WITH_UNITS（Rubyではシンボル、Pythonでは文字列）  Ruby の例：  normalize_tlm(&quot;INST HEALTH_STATUS TEMP1&quot;) # すべてのオーバーライドをクリア normalize_tlm(&quot;INST HEALTH_STATUS TEMP1&quot;, type: :RAW) # RAWオーバーライドのみをクリア   Python の例：  normalize_tlm(&quot;INST HEALTH_STATUS TEMP1&quot;) # すべてのオーバーライドをクリア normalize_tlm(&quot;INST HEALTH_STATUS TEMP1&quot;, type='RAW') # RAWオーバーライドのみをクリア   ","version":"次へ","tagName":"h3"},{"title":"get_overrides​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_overrides","content":" override_tlm によって設定された現在オーバーライドされている値の配列を返します。注意：これはオーバーライドされているすべての値タイプを返します。デフォルトでは、override_tlm を使用する際にすべての 4 つの値タイプがオーバーライドされます。  Ruby / Python 構文：  get_overrides()   Ruby の例：  override_tlm(&quot;INST HEALTH_STATUS TEMP1 = 5&quot;) puts get_overrides() #=&gt; # [ {&quot;target_name&quot;=&gt;&quot;INST&quot;, &quot;packet_name&quot;=&gt;&quot;HEALTH_STATUS&quot;, &quot;item_name&quot;=&gt;&quot;TEMP1&quot;, &quot;value_type&quot;=&gt;&quot;RAW&quot;, &quot;value&quot;=&gt;5} # {&quot;target_name&quot;=&gt;&quot;INST&quot;, &quot;packet_name&quot;=&gt;&quot;HEALTH_STATUS&quot;, &quot;item_name&quot;=&gt;&quot;TEMP1&quot;, &quot;value_type&quot;=&gt;&quot;CONVERTED&quot;, &quot;value&quot;=&gt;5} # {&quot;target_name&quot;=&gt;&quot;INST&quot;, &quot;packet_name&quot;=&gt;&quot;HEALTH_STATUS&quot;, &quot;item_name&quot;=&gt;&quot;TEMP1&quot;, &quot;value_type&quot;=&gt;&quot;FORMATTED&quot;, &quot;value&quot;=&gt;&quot;5&quot;} # {&quot;target_name&quot;=&gt;&quot;INST&quot;, &quot;packet_name&quot;=&gt;&quot;HEALTH_STATUS&quot;, &quot;item_name&quot;=&gt;&quot;TEMP1&quot;, &quot;value_type&quot;=&gt;&quot;WITH_UNITS&quot;, &quot;value&quot;=&gt;&quot;5&quot;} ]   Python の例：  override_tlm(&quot;INST HEALTH_STATUS TEMP1 = 5&quot;) print(get_overrides()) #=&gt; # [ {'target_name': 'INST', 'packet_name': 'HEALTH_STATUS', 'item_name': 'TEMP1', 'value_type': 'RAW', 'value': 5}, # {'target_name': 'INST', 'packet_name': 'HEALTH_STATUS', 'item_name': 'TEMP1', 'value_type': 'CONVERTED', 'value': 5}, # {'target_name': 'INST', 'packet_name': 'HEALTH_STATUS', 'item_name': 'TEMP1', 'value_type': 'FORMATTED', 'value': '5'}, # {'target_name': 'INST', 'packet_name': 'HEALTH_STATUS', 'item_name': 'TEMP1', 'value_type': 'WITH_UNITS', 'value': '5'} ]   ","version":"次へ","tagName":"h3"},{"title":"パケットデータサブスクリプション​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#パケットデータサブスクリプション","content":" 特定のデータパケットをサブスクライブするためのAPI。これは、ポーリングに依存して一部のデータが見逃される可能性がある代わりに、各テレメトリパケットが確実に受信および処理されるようにするインターフェースを提供します。  ","version":"次へ","tagName":"h2"},{"title":"subscribe_packets​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#subscribe_packets","content":" ユーザーが1つ以上のテレメトリデータパケットの到着をリッスンできるようにします。データの取得に使用される一意のIDが返されます。  Ruby / Python 構文：  subscribe_packets(packets)   パラメータ\t説明packets\tユーザーがサブスクライブしたいターゲット名/パケット名のペアのネスト配列。  Ruby / Python の例：  id = subscribe_packets([['INST', 'HEALTH_STATUS'], ['INST', 'ADCS']])   ","version":"次へ","tagName":"h3"},{"title":"get_packets​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_packets","content":" 以前のサブスクリプションからパケットデータをストリーミングします。  Ruby 構文：  get_packets(id, block: nil, count: 1000)   Python 構文：  get_packets(id, block=None, count=1000)   パラメータ\t説明id\tsubscribe_packets によって返される一意の ID block\t任意のストリームからのパケットを待機している間ブロックするミリ秒数、デフォルトは nil / None（ブロックしない） count\t各パケットストリームから返すパケットの最大数  Ruby の例：  id = subscribe_packets([['INST', 'HEALTH_STATUS'], ['INST', 'ADCS']]) wait 0.1 id, packets = get_packets(id) packets.each do |packet| puts &quot;#{packet['PACKET_TIMESECONDS']}: #{packet['target_name']} #{packet['packet_name']}&quot; end # 前回の呼び出しからIDを再利用し、1秒間の待機を許可し、1つのパケットのみを取得 id, packets = get_packets(id, block: 1000, count: 1) packets.each do |packet| puts &quot;#{packet['PACKET_TIMESECONDS']}: #{packet['target_name']} #{packet['packet_name']}&quot; end   Python の例：  id = subscribe_packets([['INST', 'HEALTH_STATUS'], ['INST', 'ADCS']]) wait(0.1) id, packets = get_packets(id) for packet in packets: print(f&quot;{packet['PACKET_TIMESECONDS']}: {packet['target_name']} {packet['packet_name']}&quot;) # 前回の呼び出しからIDを再利用し、1秒間の待機を許可し、1つのパケットのみを取得 id, packets = get_packets(id, block=1000, count=1) for packet in packets: print(f&quot;{packet['PACKET_TIMESECONDS']}: {packet['target_name']} {packet['packet_name']}&quot;)   ","version":"次へ","tagName":"h3"},{"title":"get_tlm_cnt​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_tlm_cnt-1","content":" テレメトリパケットの受信カウントを取得します  Ruby / Python 構文：  get_tlm_cnt(&quot;&lt;Target&gt; &lt;Packet&gt;&quot;) get_tlm_cnt(&quot;&lt;Target&gt;&quot;, &quot;&lt;Packet&gt;&quot;)   パラメータ\t説明Target\tターゲット名 Packet\tパケット名  Ruby / Python の例：  get_tlm_cnt(&quot;INST HEALTH_STATUS&quot;) #=&gt; 10   ","version":"次へ","tagName":"h3"},{"title":"get_tlm_cnts​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_tlm_cnts","content":" テレメトリパケットの配列の受信カウントを取得します  Ruby / Python 構文：  get_tlm_cnts([[&quot;&lt;Target&gt;&quot;, &quot;&lt;Packet&gt;&quot;], [&quot;&lt;Target&gt;&quot;, &quot;&lt;Packet&gt;&quot;]])   パラメータ\t説明Target\tターゲット名 Packet\tパケット名  Ruby / Python の例：  get_tlm_cnts([[&quot;INST&quot;, &quot;ADCS&quot;], [&quot;INST&quot;, &quot;HEALTH_STATUS&quot;]]) #=&gt; [100, 10]   ","version":"次へ","tagName":"h3"},{"title":"get_packet_derived_items​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_packet_derived_items","content":" パケットの派生テレメトリ項目のリストを取得します  Ruby / Python 構文：  get_packet_derived_items(&quot;&lt;Target&gt; &lt;Packet&gt;&quot;) get_packet_derived_items(&quot;&lt;Target&gt;&quot;, &quot;&lt;Packet&gt;&quot;)   パラメータ\t説明Target\tターゲット名 Packet\tパケット名  Ruby / Python の例：  get_packet_derived_items(&quot;INST HEALTH_STATUS&quot;) #=&gt; ['PACKET_TIMESECONDS', 'PACKET_TIMEFORMATTED', ...]   ","version":"次へ","tagName":"h3"},{"title":"遅延​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#遅延","content":" これらのメソッドを使用すると、テレメトリが変更されるのを待つか、または一定の時間が経過するのを待つためにスクリプトを一時停止できます。  ","version":"次へ","tagName":"h2"},{"title":"wait​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#wait","content":" 設定可能な時間（最小10ms）だけスクリプトを一時停止するか、変換されたテレメトリ項目が指定された基準を満たすまで一時停止します。3つの異なる構文をサポートしています。パラメータが指定されていない場合、ユーザーがGoを押すまで無限に待機します。タイムアウト時に、waitはスクリプトを停止しないことに注意してください。通常、wait_check の方が良い選択です。  Ruby / Python 構文：  elapsed = wait() #=&gt; 実際に待機した時間を返す elapsed = wait(&lt;Time&gt;) #=&gt; 実際に待機した時間を返す   パラメータ\t説明Time\t遅延する時間（秒単位）。  Ruby / Python 構文：  # 式が真か偽かに基づいて true または false を返す success = wait(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt; &lt;Comparison&gt;&quot;, &lt;Timeout&gt;, &lt;Polling Rate (optional)&gt;, type, quiet)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前。 Packet Name\tテレメトリ項目のテレメトリパケットの名前。 Item Name\tテレメトリ項目の名前。 Comparison\tテレメトリ項目に対して実行する比較。 Timeout\tタイムアウト（秒）。比較が真になるのを待っている間にwait文がタイムアウトした場合、スクリプトは続行します。 Polling Rate\t比較が評価される頻度（秒単位）。指定されていない場合、デフォルトは0.25です。 type\tタイプを指定する名前付きパラメータ。RAW、CONVERTED（デフォルト）、FORMATTED、WITH_UNITS（Rubyではシンボル、Pythonでは文字列）。 quiet\t結果をログに記録するかどうかを示す名前付きパラメータ。デフォルトはtrueです。  Ruby の例：  elapsed = wait elapsed = wait 5 success = wait(&quot;INST HEALTH_STATUS COLLECTS == 3&quot;, 10) success = wait(&quot;INST HEALTH_STATUS COLLECTS == 3&quot;, 10, type: :RAW, quiet: false)   Python の例：  elapsed = wait() elapsed = wait(5) success = wait(&quot;INST HEALTH_STATUS COLLECTS == 3&quot;, 10) success = wait(&quot;INST HEALTH_STATUS COLLECTS == 3&quot;, 10, type='RAW', quiet=False)   ","version":"次へ","tagName":"h3"},{"title":"wait_tolerance​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#wait_tolerance","content":" 許容範囲内の期待値と等しくなるまで、指定可能な時間だけスクリプトを一時停止するか、変換されたテレメトリ項目を一時停止します。タイムアウト時に、wait_tolerance はスクリプトを停止しないことに注意してください。通常、wait_check_tolerance の方が良い選択です。  Ruby Python 構文：  # 式が真か偽かに基づいて true または false を返す success = wait_tolerance(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt;&quot;, &lt;Expected Value&gt;, &lt;Tolerance&gt;, &lt;Timeout&gt;, &lt;Polling Rate (optional)&gt;, type, quiet)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前。 Packet Name\tテレメトリ項目のテレメトリパケットの名前。 Item Name\tテレメトリ項目の名前。 Expected Value\tテレメトリ項目の期待値。 Tolerance\t期待値に対する±許容範囲。 Timeout\tタイムアウト（秒）。比較が真になるのを待っている間にwait文がタイムアウトした場合、スクリプトは続行します。 Polling Rate\t比較が評価される頻度（秒単位）。指定されていない場合、デフォルトは0.25です。 type\tタイプを指定する名前付きパラメータ。RAW、CONVERTED（デフォルト）、FORMATTED、WITH_UNITS（Rubyではシンボル、Pythonでは文字列）。 quiet\t結果をログに記録するかどうかを示す名前付きパラメータ。デフォルトはtrueです。  Ruby の例：  success = wait_tolerance(&quot;INST HEALTH_STATUS COLLECTS&quot;, 10.0, 5.0, 10) success = wait_tolerance(&quot;INST HEALTH_STATUS COLLECTS&quot;, 10.0, 5.0, 10, type: :RAW, quiet: true)   Python の例：  success = wait_tolerance(&quot;INST HEALTH_STATUS COLLECTS&quot;, 10.0, 5.0, 10) success = wait_tolerance(&quot;INST HEALTH_STATUS COLLECTS&quot;, 10.0, 5.0, 10, type='RAW', quiet=True)   ","version":"次へ","tagName":"h3"},{"title":"wait_expression​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#wait_expression","content":" 式が真と評価されるかタイムアウトが発生するまでスクリプトを一時停止します。タイムアウトが発生するとスクリプトは続行されます。このメソッドは、例に示すように、wait を使用するよりも複雑な比較を実行するために使用できます。タイムアウト時に、wait_expression はスクリプトを停止しないことに注意してください。通常は wait_check_expression の方が良い選択です。  Ruby 構文：  # 式の評価に基づいて true または false を返す wait_expression( exp_to_eval, timeout, polling_rate = DEFAULT_TLM_POLLING_RATE, context = nil, quiet: false ) -&gt; boolean   Python 構文：  # 式の評価に基づいて True または False を返す wait_expression( exp_to_eval, timeout, polling_rate=DEFAULT_TLM_POLLING_RATE, globals=None, locals=None, quiet=False, ) -&gt; bool   パラメータ\t説明expression\t評価する式。 timeout\tタイムアウト（秒）。比較が真になるのを待っている間にwait文がタイムアウトした場合、スクリプトは続行します。 polling_rate\t比較が評価される頻度（秒単位）。指定されていない場合、デフォルトは0.25です。 context (ruby のみ)\teval を呼び出すコンテキスト。デフォルトは nil。Ruby のコンテキストは通常 binding() であり、通常は必要ありません。 globals (python のみ)\teval を呼び出すグローバル。デフォルトは None。tlm() などの COSMOS API を使用するには globals() を渡す必要があることに注意してください。 locals (python のみ)\teval を呼び出すローカル。デフォルトは None。メソッドでローカル変数を使用している場合は locals() を渡す必要があることに注意してください。 quiet\t結果をログに記録するかどうか。デフォルトは false で、ログに記録することを意味します。  Ruby の例：  success = wait_expression(&quot;tlm('INST HEALTH_STATUS COLLECTS') &gt; 5 and tlm('INST HEALTH_STATUS TEMP1') &gt; 25.0&quot;, 10, 0.25, nil, quiet: true)   Python の例：  def check(value): # ここでは tlm() とローカル変数 'value' の両方を使用しているため、globals() と locals() を渡す必要があります return wait_expression(&quot;tlm('INST HEALTH_STATUS COLLECTS') &gt; value&quot;, 5, 0.25, globals(), locals(), quiet=True) success = check(5)   ","version":"次へ","tagName":"h3"},{"title":"wait_packet​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#wait_packet","content":" 一定数のパケットが受信されるまでスクリプトを一時停止します。タイムアウトが発生するとスクリプトは続行されます。タイムアウト時に、wait_packet はスクリプトを停止しないことに注意してください。通常は wait_check_packet の方が良い選択です。  Ruby / Python 構文：  # パケットが受信されたかどうかに基づいて true または false を返す success = wait_packet(&quot;&lt;Target&gt;&quot;, &quot;&lt;Packet&gt;&quot;, &lt;Num Packets&gt;, &lt;Timeout&gt;, &lt;Polling Rate (optional)&gt;, quiet)   パラメータ\t説明Target\tターゲット名 Packet\tパケット名 Num Packets\t受信するパケット数 Timeout\tタイムアウト（秒）。 Polling Rate\t比較が評価される頻度（秒単位）。指定されていない場合、デフォルトは0.25です。 quiet\t結果をログに記録するかどうかを示す名前付きパラメータ。デフォルトはtrueです。  Ruby / Python の例：  success = wait_packet('INST', 'HEALTH_STATUS', 5, 10) # 10秒以内に5つのINST HEALTH_STATUSパケットを待つ   ","version":"次へ","tagName":"h3"},{"title":"wait_check​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#wait_check","content":" wait キーワードと check キーワードを1つに組み合わせます。これは、テレメトリ項目の変換値が指定された基準を満たすかタイムアウトするまでスクリプトを一時停止します。タイムアウト時にスクリプトは停止します。  Ruby / Python 構文：  # 式を待っている間に経過した時間を返す elapsed = wait_check(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt; &lt;Comparison&gt;&quot;, &lt;Timeout&gt;, &lt;Polling Rate (optional)&gt;, type)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前。 Packet Name\tテレメトリ項目のテレメトリパケットの名前。 Item Name\tテレメトリ項目の名前。 Comparison\tテレメトリ項目に対して実行する比較。 Timeout\tタイムアウト（秒）。比較が真になるのを待っている間にwait文がタイムアウトした場合、スクリプトは停止します。 Polling Rate\t比較が評価される頻度（秒単位）。指定されていない場合、デフォルトは0.25です。 type\tタイプを指定する名前付きパラメータ。RAW、CONVERTED（デフォルト）、FORMATTED、WITH_UNITS（Rubyではシンボル、Pythonでは文字列）。  Ruby の例：  elapsed = wait_check(&quot;INST HEALTH_STATUS COLLECTS &gt; 5&quot;, 10) elapsed = wait_check(&quot;INST HEALTH_STATUS COLLECTS &gt; 5&quot;, 10, type: :RAW)   Python の例：  elapsed = wait_check(&quot;INST HEALTH_STATUS COLLECTS &gt; 5&quot;, 10) elapsed = wait_check(&quot;INST HEALTH_STATUS COLLECTS &gt; 5&quot;, 10, type='RAW')   ","version":"次へ","tagName":"h3"},{"title":"wait_check_tolerance​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#wait_check_tolerance","content":" 設定可能な時間だけスクリプトを一時停止するか、変換されたテレメトリ項目が許容範囲内の期待値と等しくなるまで一時停止します。タイムアウト時にスクリプトは停止します。  Ruby / Python 構文：  # 式を待っている間に経過した時間を返す elapsed = wait_check_tolerance(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt;&quot;, &lt;Expected Value&gt;, &lt;Tolerance&gt;, &lt;Timeout&gt;, &lt;Polling Rate (optional)&gt;, type)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前。 Packet Name\tテレメトリ項目のテレメトリパケットの名前。 Item Name\tテレメトリ項目の名前。 Expected Value\tテレメトリ項目の期待値。 Tolerance\t期待値に対する±許容範囲。 Timeout\tタイムアウト（秒）。比較が真になるのを待っている間にwait文がタイムアウトした場合、スクリプトは停止します。 Polling Rate\t比較が評価される頻度（秒単位）。指定されていない場合、デフォルトは0.25です。 type\tタイプを指定する名前付きパラメータ。RAW、CONVERTED（デフォルト）、FORMATTED、WITH_UNITS（Rubyではシンボル、Pythonでは文字列）。  Ruby の例：  elapsed = wait_check_tolerance(&quot;INST HEALTH_STATUS COLLECTS&quot;, 10.0, 5.0, 10) elapsed = wait_check_tolerance(&quot;INST HEALTH_STATUS COLLECTS&quot;, 10.0, 5.0, 10, type: :RAW)   Python の例：  elapsed = wait_check_tolerance(&quot;INST HEALTH_STATUS COLLECTS&quot;, 10.0, 5.0, 10) elapsed = wait_check_tolerance(&quot;INST HEALTH_STATUS COLLECTS&quot;, 10.0, 5.0, 10, type='RAW')   ","version":"次へ","tagName":"h3"},{"title":"wait_check_expression​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#wait_check_expression","content":" 式が真と評価されるかタイムアウトが発生するまでスクリプトを一時停止します。タイムアウトが発生するとスクリプトは停止します。このメソッドは、例に示すように、wait を使用するよりも複雑な比較を実行するために使用できます。check_expression の構文に関する注意事項も参照してください。  Ruby 構文：  # 式が真と評価されるまで待つのに費やした時間を返す wait_check_expression( exp_to_eval, timeout, polling_rate = DEFAULT_TLM_POLLING_RATE, context = nil ) -&gt; int   Python 構文：  # 式が真と評価されるまで待つのに費やした時間を返す wait_check_expression( exp_to_eval, timeout, polling_rate=DEFAULT_TLM_POLLING_RATE, globals=None, locals=None ) -&gt; int   パラメータ\t説明expression\t評価する式。 timeout\tタイムアウト（秒）。比較が真になるのを待っている間にwait文がタイムアウトした場合、スクリプトは続行します。 polling_rate\t比較が評価される頻度（秒単位）。指定されていない場合、デフォルトは0.25です。 context (ruby のみ)\teval を呼び出すコンテキスト。デフォルトは nil。Ruby のコンテキストは通常 binding() であり、通常は必要ありません。 globals (python のみ)\teval を呼び出すグローバル。デフォルトは None。tlm() などの COSMOS API を使用するには globals() を渡す必要があることに注意してください。 locals (python のみ)\teval を呼び出すローカル。デフォルトは None。メソッドでローカル変数を使用している場合は locals() を渡す必要があることに注意してください。  Ruby の例：  elapsed = wait_check_expression(&quot;tlm('INST HEALTH_STATUS COLLECTS') &gt; 5 and tlm('INST HEALTH_STATUS TEMP1') &gt; 25.0&quot;, 10)   Python の例：  # PythonではCOSMOS APIメソッドのtlm()などを使用するためにglobals()を渡す必要があることに注意してください elapsed = wait_check_expression(&quot;tlm('INST HEALTH_STATUS COLLECTS') &gt; 5 and tlm('INST HEALTH_STATUS TEMP1') &gt; 25.0&quot;, 10, 0.25, globals())   ","version":"次へ","tagName":"h3"},{"title":"wait_check_packet​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#wait_check_packet","content":" 一定数のパケットが受信されるまでスクリプトを一時停止します。タイムアウトが発生するとスクリプトは停止します。  Ruby / Python 構文：  # パケットを待つのに費やした時間の量を返す elapsed = wait_check_packet(&quot;&lt;Target&gt;&quot;, &quot;&lt;Packet&gt;&quot;, &lt;Num Packets&gt;, &lt;Timeout&gt;, &lt;Polling Rate (optional)&gt;, quiet)   パラメータ\t説明Target\tターゲット名 Packet\tパケット名 Num Packets\t受信するパケット数 Timeout\tタイムアウト（秒）。指定された数のパケットを待っている間にwait文がタイムアウトした場合、スクリプトは停止します。 Polling Rate\t比較が評価される頻度（秒単位）。指定されていない場合、デフォルトは0.25です。 quiet\t結果をログに記録するかどうかを示す名前付きパラメータ。デフォルトはtrueです。  Ruby / Python の例：  elapsed = wait_check_packet('INST', 'HEALTH_STATUS', 5, 10) # 10秒以内に5つのINST HEALTH_STATUSパケットを待つ   ","version":"次へ","tagName":"h3"},{"title":"リミット​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#リミット","content":" これらのメソッドは、テレメトリリミットの処理を扱います。  ","version":"次へ","tagName":"h2"},{"title":"limits_enabled?, limits_enabled​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#limits_enabled-limits_enabled","content":" limits_enabled? メソッドは、テレメトリ項目のリミットが有効かどうかに応じて true/false を返します。  Ruby 構文：  limits_enabled?(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt;&quot;)   Python 構文：  limits_enabled(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt;&quot;)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前。 Packet Name\tテレメトリ項目のテレメトリパケットの名前。 Item Name\tテレメトリ項目の名前。  Ruby の例：  enabled = limits_enabled?(&quot;INST HEALTH_STATUS TEMP1&quot;) #=&gt; true または false   Python の例：  enabled = limits_enabled(&quot;INST HEALTH_STATUS TEMP1&quot;) #=&gt; True または False   ","version":"次へ","tagName":"h3"},{"title":"enable_limits​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#enable_limits","content":" 指定されたテレメトリ項目のリミットモニタリングを有効にします。  Ruby / Python 構文：  enable_limits(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt;&quot;)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前。 Packet Name\tテレメトリ項目のテレメトリパケットの名前。 Item Name\tテレメトリ項目の名前。  Ruby / Python の例：  enable_limits(&quot;INST HEALTH_STATUS TEMP1&quot;)   ","version":"次へ","tagName":"h3"},{"title":"disable_limits​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#disable_limits","content":" 指定されたテレメトリ項目のリミットモニタリングを無効にします。  Ruby / Python 構文：  disable_limits(&quot;&lt;Target Name&gt; &lt;Packet Name&gt; &lt;Item Name&gt;&quot;)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前。 Packet Name\tテレメトリ項目のテレメトリパケットの名前。 Item Name\tテレメトリ項目の名前。  Ruby / Python の例：  disable_limits(&quot;INST HEALTH_STATUS TEMP1&quot;)   ","version":"次へ","tagName":"h3"},{"title":"enable_limits_group​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#enable_limits_group","content":" リミットグループで指定された一連のテレメトリ項目のリミットモニタリングを有効にします。  Ruby / Python 構文：  enable_limits_group(&quot;&lt;Limits Group Name&gt;&quot;)   パラメータ\t説明Limits Group Name\tリミットグループの名前。  Ruby / Python の例：  enable_limits_group(&quot;SAFE_MODE&quot;)   ","version":"次へ","tagName":"h3"},{"title":"disable_limits_group​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#disable_limits_group","content":" リミットグループで指定された一連のテレメトリ項目のリミットモニタリングを無効にします。  Ruby / Python 構文：  disable_limits_group(&quot;&lt;Limits Group Name&gt;&quot;)   パラメータ\t説明Limits Group Name\tリミットグループの名前。  Ruby / Python の例：  disable_limits_group(&quot;SAFE_MODE&quot;)   ","version":"次へ","tagName":"h3"},{"title":"get_limits_groups​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_limits_groups","content":" システム内のリミットグループのリストを返します。  Ruby / Python の例：  limits_groups = get_limits_groups()   ","version":"次へ","tagName":"h3"},{"title":"set_limits_set​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#set_limits_set","content":" 現在のリミットセットを設定します。デフォルトのリミットセットは DEFAULT です。  Ruby / Python 構文：  set_limits_set(&quot;&lt;Limits Set Name&gt;&quot;)   パラメータ\t説明Limits Set Name\tリミットセットの名前。  Ruby / Python の例：  set_limits_set(&quot;DEFAULT&quot;)   ","version":"次へ","tagName":"h3"},{"title":"get_limits_set​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_limits_set","content":" 現在のリミットセットの名前を返します。デフォルトのリミットセットは DEFAULT です。  Ruby / Python の例：  limits_set = get_limits_set()   ","version":"次へ","tagName":"h3"},{"title":"get_limits_sets​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_limits_sets","content":" システム内のリミットセットのリストを返します。  Ruby / Python の例：  limits_sets = get_limits_sets()   ","version":"次へ","tagName":"h3"},{"title":"get_limits​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_limits","content":" テレメトリポイントのすべてのリミット設定のハッシュ / 辞書を返します。  Ruby / Python 構文：  get_limits(&lt;Target Name&gt;, &lt;Packet Name&gt;, &lt;Item Name&gt;)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前 Packet Name\tテレメトリ項目のテレメトリパケットの名前 Item Name\tテレメトリ項目の名前  Ruby の例：  result = get_limits('INST', 'HEALTH_STATUS', 'TEMP1') puts result #=&gt; {&quot;DEFAULT&quot;=&gt;[-80.0, -70.0, 60.0, 80.0, -20.0, 20.0], &quot;TVAC&quot;=&gt;[-80.0, -30.0, 30.0, 80.0]} puts result.keys #=&gt; ['DEFAULT', 'TVAC'] puts result['DEFAULT'] #=&gt; [-80.0, -70.0, 60.0, 80.0, -20.0, 20.0]   Python の例：  result = get_limits('INST', 'HEALTH_STATUS', 'TEMP1') print(result) #=&gt; {'DEFAULT'=&gt;[-80.0, -70.0, 60.0, 80.0, -20.0, 20.0], 'TVAC'=&gt;[-80.0, -30.0, 30.0, 80.0]} print(result.keys()) #=&gt; dict_keys(['DEFAULT', 'TVAC']) print(result['DEFAULT']) #=&gt; [-80.0, -70.0, 60.0, 80.0, -20.0, 20.0]   ","version":"次へ","tagName":"h3"},{"title":"set_limits​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#set_limits","content":" set_limits メソッドはテレメトリポイントのリミット設定を設定します。注意：ほとんどの場合、設定ファイルを更新するか、異なるリミットセットを使用する方が、リアルタイムでリミット設定を変更するよりも良いでしょう。  Ruby / Python 構文：  set_limits(&lt;Target Name&gt;, &lt;Packet Name&gt;, &lt;Item Name&gt;, &lt;Red Low&gt;, &lt;Yellow Low&gt;, &lt;Yellow High&gt;, &lt;Red High&gt;, &lt;Green Low (オプション)&gt;, &lt;Green High (オプション)&gt;, &lt;Limits Set (オプション)&gt;, &lt;Persistence (オプション)&gt;, &lt;Enabled (オプション)&gt;)   パラメータ\t説明Target Name\tテレメトリ項目のターゲットの名前。 Packet Name\tテレメトリ項目のテレメトリパケットの名前。 Item Name\tテレメトリ項目の名前。 Red Low\tこのリミットセットの Red Low 設定。この値より下の値はすべて項目を赤にします。 Yellow Low\tこのリミットセットの Yellow Low 設定。この値より下で Red Low より大きい値はすべて項目を黄色にします。 Yellow High\tこのリミットセットの Yellow High 設定。この値より上で Red High より小さい値はすべて項目を黄色にします。 Red High\tこのリミットセットの Red High 設定。この値より上の値はすべて項目を赤にします。 Green Low\tオプション。指定された場合、Green Low より大きく Green High より小さい値は、良好な動作値を示す青色で項目を表示します。 Green High\tオプション。指定された場合、Green Low より大きく Green High より小さい値は、良好な動作値を示す青色で項目を表示します。 Limits Set\tオプション。特定のリミットセットのリミットを設定します。指定されない場合、デフォルトで CUSTOM リミットセットのリミットを設定します。 Persistence\tオプション。リミット状態を変更する前に、この項目がリミット範囲外でなければならないサンプル数を設定します。デフォルトは変更なしです。注意：これはリミットセット全体のすべてのリミット設定に影響します。 Enabled\tオプション。この項目のリミットが有効かどうか。デフォルトは true です。注意：これはリミットセット全体のすべてのリミット設定に影響します。  Ruby / Python の例：  set_limits('INST', 'HEALTH_STATUS', 'TEMP1', -10.0, 0.0, 50.0, 60.0, 30.0, 40.0, 'TVAC', 1, true)   ","version":"次へ","tagName":"h3"},{"title":"get_out_of_limits​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_out_of_limits","content":" リミット範囲外のすべての項目の target_name、packet_name、item_name、および limits_state を含む配列を返します。  Ruby / Python の例：  out_of_limits_items = get_out_of_limits()   ","version":"次へ","tagName":"h3"},{"title":"get_overall_limits_state​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_overall_limits_state","content":" COSMOS システムの全体的なリミット状態を返します。'GREEN'、'YELLOW'、または 'RED' を返します。  Ruby / Python 構文：  get_overall_limits_state(&lt;Ignored Items&gt; (オプション))   パラメータ\t説明Ignored Items\t全体的なリミット状態を決定する際に無視する項目の配列の配列。[['TARGET_NAME', 'PACKET_NAME', 'ITEM_NAME'], ...] の形式  Ruby / Python の例：  overall_limits_state = get_overall_limits_state() overall_limits_state = get_overall_limits_state([['INST', 'HEALTH_STATUS', 'TEMP1']])   ","version":"次へ","tagName":"h3"},{"title":"get_limits_events​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_limits_events","content":" 前回呼び出された時から返されたオフセットに基づいてリミットイベントを返します。  Ruby / Python 構文：  get_limits_event(&lt;Offset&gt;, count)   パラメータ\t説明Offset\tget_limits_event への前回の呼び出しによって返されたオフセット。初回呼び出しのデフォルトは nil count\t返すリミットイベントの最大数を指定する名前付きパラメータ。デフォルトは 100 Ruby / Python の例：\t  events = get_limits_event() print(events) #[[&quot;1613077715557-0&quot;, # {&quot;type&quot;=&gt;&quot;LIMITS_CHANGE&quot;, # &quot;target_name&quot;=&gt;&quot;TGT&quot;, # &quot;packet_name&quot;=&gt;&quot;PKT&quot;, # &quot;item_name&quot;=&gt;&quot;ITEM&quot;, # &quot;old_limits_state&quot;=&gt;&quot;YELLOW_LOW&quot;, # &quot;new_limits_state&quot;=&gt;&quot;RED_LOW&quot;, # &quot;time_nsec&quot;=&gt;&quot;1&quot;, # &quot;message&quot;=&gt;&quot;message&quot;}], # [&quot;1613077715557-1&quot;, # {&quot;type&quot;=&gt;&quot;LIMITS_CHANGE&quot;, # &quot;target_name&quot;=&gt;&quot;TGT&quot;, # &quot;packet_name&quot;=&gt;&quot;PKT&quot;, # &quot;item_name&quot;=&gt;&quot;ITEM&quot;, # &quot;old_limits_state&quot;=&gt;&quot;RED_LOW&quot;, # &quot;new_limits_state&quot;=&gt;&quot;YELLOW_LOW&quot;, # &quot;time_nsec&quot;=&gt;&quot;2&quot;, # &quot;message&quot;=&gt;&quot;message&quot;}]] # 最後のオフセットは最後のイベント([-1])の最初の項目([0])です events = get_limits_event(events[-1][0]) print(events) #[[&quot;1613077715657-0&quot;, # {&quot;type&quot;=&gt;&quot;LIMITS_CHANGE&quot;, # ...   ","version":"次へ","tagName":"h3"},{"title":"プラグイン / パッケージ​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#プラグイン--パッケージ","content":" プラグインとパッケージに関する情報を取得するためのAPI。  ","version":"次へ","tagName":"h2"},{"title":"plugin_list​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#plugin_list","content":" インストールされているすべてのプラグインを返します。  Ruby 構文：  plugin_list(default: false)   Python 構文：  plugin_list(default = False)   パラメータ\t説明default\tデフォルトのCOSMOSプラグイン（すべての通常のアプリケーション）を含めるかどうか  Ruby / Python の例：  plugins = plugin_list() #=&gt; ['openc3-cosmos-demo-6.0.3.pre.beta0.20250116214358.gem__20250116214539'] plugins = plugin_list(default: true) #=&gt; # ['openc3-cosmos-demo-6.0.3.pre.beta0.20250116214358.gem__20250116214539', # 'openc3-cosmos-tool-admin-6.0.3.pre.beta0.20250115200004.gem__20250116211504', # 'openc3-cosmos-tool-bucketexplorer-6.0.3.pre.beta0.20250115200008.gem__20250116211525', # 'openc3-cosmos-tool-cmdsender-6.0.3.pre.beta0.20250115200012.gem__20250116211515', # 'openc3-cosmos-tool-cmdtlmserver-6.0.3.pre.beta0.20250115200015.gem__20250116211512', # 'openc3-cosmos-tool-dataextractor-6.0.3.pre.beta0.20250115200005.gem__20250116211521', # 'openc3-cosmos-tool-dataviewer-6.0.3.pre.beta0.20250115200009.gem__20250116211522', # 'openc3-cosmos-tool-docs-6.0.3.pre.beta0.20250117042104.gem__20250117042154', # 'openc3-cosmos-tool-handbooks-6.0.3.pre.beta0.20250115200014.gem__20250116211523', # 'openc3-cosmos-tool-iframe-6.0.3.pre.beta0.20250115200011.gem__20250116211503', # 'openc3-cosmos-tool-limitsmonitor-6.0.3.pre.beta0.20250115200017.gem__20250116211514', # 'openc3-cosmos-tool-packetviewer-6.0.3.pre.beta0.20250115200004.gem__20250116211518', # 'openc3-cosmos-tool-scriptrunner-6.0.3.pre.beta0.20250115200012.gem__20250116211517', # 'openc3-cosmos-tool-tablemanager-6.0.3.pre.beta0.20250115200018.gem__20250116211524', # 'openc3-cosmos-tool-tlmgrapher-6.0.3.pre.beta0.20250115200005.gem__20250116211520', # 'openc3-cosmos-tool-tlmviewer-6.0.3.pre.beta0.20250115200008.gem__20250116211519', # 'openc3-tool-base-6.0.3.pre.beta0.20250115195959.gem__20250116211459']   ","version":"次へ","tagName":"h3"},{"title":"plugin_get​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#plugin_get","content":" インストールされたプラグインに関する情報を返します。  Ruby / Python 構文：  plugin_get(&lt;Plugin Name&gt;)   パラメータ\t説明Plugin Name\tプラグインの完全な名前（通常は plugin_list() から取得）  Ruby / Python の例：  plugin_get('openc3-cosmos-demo-6.0.3.pre.beta0.20250116214358.gem__20250116214539') #=&gt; # { &quot;name&quot;=&gt;&quot;openc3-cosmos-demo-6.0.3.pre.beta0.20250116214358.gem__20250116214539&quot;, # &quot;variables&quot;=&gt;{&quot;inst_target_name&quot;=&gt;&quot;INST&quot;, ...}, # &quot;plugin_txt_lines&quot;=&gt;[&quot;# Note: This plugin includes 4 targets ...&quot;], # &quot;needs_dependencies&quot;=&gt;true, # &quot;updated_at&quot;=&gt;1737063941094624764 }   ","version":"次へ","tagName":"h3"},{"title":"package_list​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#package_list","content":" COSMOSにインストールされているすべてのパッケージをリストします。  Ruby の例：  package_list() #=&gt; {&quot;ruby&quot;=&gt;[&quot;openc3-cosmos-demo-6.0.3.pre.beta0.20250116214358.gem&quot;, ..., &quot;openc3-tool-base-6.0.3.pre.beta0.20250115195959.gem&quot;], # &quot;python&quot;=&gt;[&quot;numpy-2.1.1&quot;, &quot;pip-24.0&quot;, &quot;setuptools-65.5.0&quot;]}   Python の例：  package_list() #=&gt; {'ruby': ['openc3-cosmos-demo-6.0.3.pre.beta0.20250116214358.gem', ..., 'openc3-tool-base-6.0.3.pre.beta0.20250115195959.gem'], # 'python': ['numpy-2.1.1', 'pip-24.0', 'setuptools-65.5.0']}   ","version":"次へ","tagName":"h3"},{"title":"ターゲット​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#ターゲット","content":" ターゲットに関する情報を取得するためのAPI。  ","version":"次へ","tagName":"h2"},{"title":"get_target_names​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_target_names","content":" システム内のターゲットのリストを配列で返します。  Ruby の例：  targets = get_target_names() #=&gt; ['INST', 'INST2', 'EXAMPLE', 'TEMPLATED']   ","version":"次へ","tagName":"h3"},{"title":"get_target​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_target","content":" ターゲットに関するすべての情報を含むターゲットハッシュを返します。  Ruby 構文：  get_target(&quot;&lt;Target Name&gt;&quot;)   パラメータ\t説明Target Name\tターゲットの名前。  Ruby の例：  target = get_target(&quot;INST&quot;) print(target) # {&quot;name&quot;=&gt;&quot;INST&quot;, # &quot;folder_name&quot;=&gt;&quot;INST&quot;, # &quot;requires&quot;=&gt;[], # &quot;ignored_parameters&quot;=&gt; # [&quot;CCSDSVER&quot;, # &quot;CCSDSTYPE&quot;, # &quot;CCSDSSHF&quot;, # &quot;CCSDSAPID&quot;, # &quot;CCSDSSEQFLAGS&quot;, # &quot;CCSDSSEQCNT&quot;, # &quot;CCSDSLENGTH&quot;, # &quot;PKTID&quot;], # &quot;ignored_items&quot;=&gt; # [&quot;CCSDSVER&quot;, # &quot;CCSDSTYPE&quot;, # &quot;CCSDSSHF&quot;, # &quot;CCSDSAPID&quot;, # &quot;CCSDSSEQFLAGS&quot;, # &quot;CCSDSSEQCNT&quot;, # &quot;CCSDSLENGTH&quot;, # &quot;RECEIVED_COUNT&quot;, # &quot;RECEIVED_TIMESECONDS&quot;, # &quot;RECEIVED_TIMEFORMATTED&quot;], # &quot;limits_groups&quot;=&gt;[], # &quot;cmd_tlm_files&quot;=&gt; # [&quot;.../targets/INST/cmd_tlm/inst_cmds.txt&quot;, # &quot;.../targets/INST/cmd_tlm/inst_tlm.txt&quot;], # &quot;cmd_unique_id_mode&quot;=&gt;false, # &quot;tlm_unique_id_mode&quot;=&gt;false, # &quot;id&quot;=&gt;nil, # &quot;updated_at&quot;=&gt;1613077058266815900, # &quot;plugin&quot;=&gt;nil}   ","version":"次へ","tagName":"h3"},{"title":"get_target_interfaces​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_target_interfaces","content":" すべてのターゲットのインターフェースを返します。戻り値は配列の配列で、各サブ配列にはターゲット名とすべてのインターフェース名の文字列が含まれています。  Ruby / Python の例：  target_ints = get_target_interfaces() target_ints.each do |target_name, interfaces| puts &quot;Target: #{target_name}, Interfaces: #{interfaces}&quot; end   ","version":"次へ","tagName":"h3"},{"title":"インターフェース​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#インターフェース","content":" これらのメソッドを使用すると、ユーザーはCOSMOSインターフェースを操作できます。  ","version":"次へ","tagName":"h2"},{"title":"get_interface​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_interface","content":" ビルド済みのインターフェースとその現在のステータス（コマンド/テレメトリカウンターなど）を含むインターフェースのステータスを返します。  Ruby / Python 構文：  get_interface(&quot;&lt;Interface Name&gt;&quot;)   パラメータ\t説明Interface Name\tインターフェースの名前。  Ruby / Python の例：  interface = get_interface(&quot;INST_INT&quot;) print(interface) # {&quot;name&quot;=&gt;&quot;INST_INT&quot;, # &quot;config_params&quot;=&gt;[&quot;interface.rb&quot;], # &quot;target_names&quot;=&gt;[&quot;INST&quot;], # &quot;connect_on_startup&quot;=&gt;true, # &quot;auto_reconnect&quot;=&gt;true, # &quot;reconnect_delay&quot;=&gt;5.0, # &quot;disable_disconnect&quot;=&gt;false, # &quot;options&quot;=&gt;[], # &quot;protocols&quot;=&gt;[], # &quot;log&quot;=&gt;true, # &quot;log_raw&quot;=&gt;false, # &quot;plugin&quot;=&gt;nil, # &quot;updated_at&quot;=&gt;1613076213535979900, # &quot;state&quot;=&gt;&quot;CONNECTED&quot;, # &quot;clients&quot;=&gt;0, # &quot;txsize&quot;=&gt;0, # &quot;rxsize&quot;=&gt;0, # &quot;txbytes&quot;=&gt;0, # &quot;rxbytes&quot;=&gt;0, # &quot;txcnt&quot;=&gt;0, # &quot;rxcnt&quot;=&gt;0}   ","version":"次へ","tagName":"h3"},{"title":"get_interface_names​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_interface_names","content":" システム内のインターフェースのリストを配列で返します。  Ruby / Python の例：  interface_names = get_interface_names() #=&gt; ['INST_INT', 'INST2_INT', 'EXAMPLE_INT', 'TEMPLATED_INT']   ","version":"次へ","tagName":"h3"},{"title":"connect_interface​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#connect_interface","content":" COSMOSインターフェースに関連付けられたターゲットに接続します。  Ruby / Python 構文：  connect_interface(&quot;&lt;Interface Name&gt;&quot;, &lt;Interface Parameters (オプション)&gt;)   パラメータ\t説明Interface Name\tインターフェースの名前。 Interface Parameters\tインターフェースの初期化に使用されるパラメータ。指定されない場合、インターフェースはサーバー構成ファイルで指定されたパラメータを使用します。  Ruby / Python の例：  connect_interface(&quot;INT1&quot;) connect_interface(&quot;INT1&quot;, hostname, port)   ","version":"次へ","tagName":"h3"},{"title":"disconnect_interface​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#disconnect_interface","content":" COSMOSインターフェースに関連付けられたターゲットから切断します。  Ruby / Python 構文：  disconnect_interface(&quot;&lt;Interface Name&gt;&quot;)   パラメータ\t説明Interface Name\tインターフェースの名前。  Ruby / Python の例：  disconnect_interface(&quot;INT1&quot;)   ","version":"次へ","tagName":"h3"},{"title":"start_raw_logging_interface​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#start_raw_logging_interface","content":" 1つまたはすべてのインターフェースでの生データのロギングを開始します。これはデバッグ目的のみです。  Ruby / Python 構文：  start_raw_logging_interface(&quot;&lt;Interface Name (オプション)&gt;&quot;)   パラメータ\t説明Interface Name\t生データロギングを開始するように命令するインターフェースの名前。デフォルトは 'ALL' で、生データロギングをサポートするすべてのインターフェースで生データのロギングを開始します。  Ruby / Python の例：  start_raw_logging_interface(&quot;int1&quot;)   ","version":"次へ","tagName":"h3"},{"title":"stop_raw_logging_interface​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#stop_raw_logging_interface","content":" 1つまたはすべてのインターフェースでの生データのロギングを停止します。これはデバッグ目的のみです。  Ruby / Python 構文：  stop_raw_logging_interface(&quot;&lt;Interface Name (オプション)&gt;&quot;)   パラメータ\t説明Interface Name\t生データロギングを停止するように命令するインターフェースの名前。デフォルトは 'ALL' で、生データロギングをサポートするすべてのインターフェースで生データのロギングを停止します。  Ruby / Python の例：  stop_raw_logging_interface(&quot;int1&quot;)   ","version":"次へ","tagName":"h3"},{"title":"get_all_interface_info​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_all_interface_info","content":" すべてのインターフェースに関する情報を返します。戻り値は配列の配列で、各サブ配列にはインターフェース名、接続状態、接続クライアント数、送信キューサイズ、受信キューサイズ、送信バイト数、受信バイト数、コマンド数、テレメトリ数が含まれています。  Ruby の例：  interface_info = get_all_interface_info() interface_info.each do |interface_name, connection_state, num_clients, tx_q_size, rx_q_size, tx_bytes, rx_bytes, cmd_count, tlm_count| puts &quot;Interface: #{interface_name}, Connection state: #{connection_state}, Num connected clients: #{num_clients}&quot; puts &quot;Transmit queue size: #{tx_q_size}, Receive queue size: #{rx_q_size}, Bytes transmitted: #{tx_bytes}, Bytes received: #{rx_bytes}&quot; puts &quot;Cmd count: #{cmd_count}, Tlm count: #{tlm_count}&quot; end   Python の例：  interface_info = get_all_interface_info() for interface in interface_info(): # [interface_name, connection_state, num_clients, tx_q_size, rx_q_size, tx_bytes, rx_bytes, cmd_count, tlm_count] print(f&quot;Interface: {interface[0]}, Connection state: {interface[1]}, Num connected clients: {interface[2]}&quot;) print(f&quot;Transmit queue size: {interface[3]}, Receive queue size: {interface[4]}, Bytes transmitted: {interface[5]}, Bytes received: {interface[6]}&quot;) print(f&quot;Cmd count: {interface[7]}, Tlm count: {interface[8]}&quot;)   ","version":"次へ","tagName":"h3"},{"title":"map_target_to_interface​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#map_target_to_interface","content":" ターゲットをインターフェースにマップして、ターゲットコマンドとテレメトリがそのインターフェースによって処理されるようにします。  Ruby / Python 構文：  map_target_to_interface(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Interface Name&gt;&quot;, cmd_only, tlm_only, unmap_old)   パラメータ\t説明Target Name\tターゲットの名前 Interface Name\tインターフェースの名前 cmd_only\tターゲットコマンドのみをインターフェースにマップするかどうかを指定する名前付きパラメータ（デフォルト：false） tlm_only\tターゲットテレメトリのみをインターフェースにマップするかどうかを指定する名前付きパラメータ（デフォルト：false） unmap_old\tターゲットをすべての既存のインターフェースから削除するかどうかを指定する名前付きパラメータ（デフォルト：true）  Ruby の例：  map_target_to_interface(&quot;INST&quot;, &quot;INST_INT&quot;, unmap_old: false)   Python の例：  map_target_to_interface(&quot;INST&quot;, &quot;INST_INT&quot;, unmap_old=False)   ","version":"次へ","tagName":"h3"},{"title":"interface_cmd​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#interface_cmd","content":" コマンドを直接インターフェースに送信します。これは標準のCOSMOSインターフェースでは効果がありませんが、動作を変更するためにカスタムインターフェースで実装できます。 Ruby / Python 構文：  interface_cmd(&quot;&lt;Interface Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;&lt;Command Parameters&gt;&quot;)   パラメータ\t説明Interface Name\tインターフェースの名前 Command Name\t送信するコマンドの名前 Command Parameters\tコマンドと共に送信するパラメータ  Ruby / Python の例：  interface_cmd(&quot;INST&quot;, &quot;DISABLE_CRC&quot;)   ","version":"次へ","tagName":"h3"},{"title":"interface_protocol_cmd​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#interface_protocol_cmd","content":" コマンドを直接インターフェースプロトコルに送信します。これは標準のCOSMOSプロトコルでは効果がありませんが、動作を変更するためにカスタムプロトコルで実装できます。  Ruby / Python 構文：  interface_protocol_cmd(&quot;&lt;Interface Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;&lt;Command Parameters&gt;&quot;)   パラメータ\t説明Interface Name\tインターフェースの名前 Command Name\t送信するコマンドの名前 Command Parameters\tコマンドと共に送信するパラメータ read_write\tコマンドが送信される読み取りまたは書き込みプロトコル。READ、WRITE、または READ_WRITE（Rubyではシンボル、Pythonでは文字列）のいずれかである必要があります。デフォルトは READ_WRITE です。 index\tスタック内のどのプロトコルにコマンドが適用されるか。デフォルトは -1 で、すべてにコマンドを適用します。  Ruby の例：  interface_protocol_cmd(&quot;INST&quot;, &quot;DISABLE_CRC&quot;, read_write: :READ_WRITE, index: -1)   Python の例：  interface_protocol_cmd(&quot;INST&quot;, &quot;DISABLE_CRC&quot;, read_write='READ_WRITE', index=-1)   ","version":"次へ","tagName":"h3"},{"title":"ルーター​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#ルーター","content":" これらのメソッドを使用すると、ユーザーはCOSMOSルーターを操作できます。  ","version":"次へ","tagName":"h2"},{"title":"connect_router​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#connect_router","content":" COSMOSルーターを接続します。  Ruby / Python 構文：  connect_router(&quot;&lt;Router Name&gt;&quot;, &lt;Router Parameters (オプション)&gt;)   パラメータ\t説明Router Name\tルーターの名前。 Router Parameters\tルーターの初期化に使用されるパラメータ。指定されない場合、ルーターはサーバー構成ファイルで指定されたパラメータを使用します。  Ruby / Python の例：  connect_ROUTER(&quot;INST_ROUTER&quot;) connect_router(&quot;INST_ROUTER&quot;, 7779, 7779, nil, 10.0, 'PREIDENTIFIED')   ","version":"次へ","tagName":"h3"},{"title":"disconnect_router​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#disconnect_router","content":" COSMOSルーターを切断します。  Ruby / Python 構文：  disconnect_router(&quot;&lt;Router Name&gt;&quot;)   パラメータ\t説明Router Name\tルーターの名前。  Ruby / Python の例：  disconnect_router(&quot;INT1_ROUTER&quot;)   ","version":"次へ","tagName":"h3"},{"title":"get_router_names​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_router_names","content":" システム内のルーターのリストを配列で返します。  Ruby / Python の例：  router_names = get_router_names() #=&gt; ['ROUTER_INT']   ","version":"次へ","tagName":"h3"},{"title":"get_router​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_router","content":" ビルド済みのルーターとその現在のステータス（コマンド/テレメトリカウンターなど）を含むルーターのステータスを返します。  Ruby / Python 構文：  get_router(&quot;&lt;Router Name&gt;&quot;)   パラメータ\t説明Router Name\tルーターの名前。  Ruby / Python の例：  router = get_router(&quot;ROUTER_INT&quot;) print(router) #{&quot;name&quot;=&gt;&quot;ROUTER_INT&quot;, # &quot;config_params&quot;=&gt;[&quot;router.rb&quot;], # &quot;target_names&quot;=&gt;[&quot;INST&quot;], # &quot;connect_on_startup&quot;=&gt;true, # &quot;auto_reconnect&quot;=&gt;true, # &quot;reconnect_delay&quot;=&gt;5.0, # &quot;disable_disconnect&quot;=&gt;false, # &quot;options&quot;=&gt;[], # &quot;protocols&quot;=&gt;[], # &quot;log&quot;=&gt;true, # &quot;log_raw&quot;=&gt;false, # &quot;plugin&quot;=&gt;nil, # &quot;updated_at&quot;=&gt;1613076213535979900, # &quot;state&quot;=&gt;&quot;CONNECTED&quot;, # &quot;clients&quot;=&gt;0, # &quot;txsize&quot;=&gt;0, # &quot;rxsize&quot;=&gt;0, # &quot;txbytes&quot;=&gt;0, # &quot;rxbytes&quot;=&gt;0, # &quot;txcnt&quot;=&gt;0, # &quot;rxcnt&quot;=&gt;0}   ","version":"次へ","tagName":"h3"},{"title":"get_all_router_info​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_all_router_info","content":" すべてのルーターに関する情報を返します。戻り値は配列の配列で、各サブ配列にはルーター名、接続状態、接続クライアント数、送信キューサイズ、受信キューサイズ、送信バイト数、受信バイト数、受信パケット数、送信パケット数が含まれています。  Ruby の例：  router_info = get_all_router_info() router_info.each do |router_name, connection_state, num_clients, tx_q_size, rx_q_size, tx_bytes, rx_bytes, pkts_rcvd, pkts_sent| puts &quot;Router: #{router_name}, Connection state: #{connection_state}, Num connected clients: #{num_clients}&quot; puts &quot;Transmit queue size: #{tx_q_size}, Receive queue size: #{rx_q_size}, Bytes transmitted: #{tx_bytes}, Bytes received: #{rx_bytes}&quot; puts &quot;Packets received: #{pkts_rcvd}, Packets sent: #{pkts_sent}&quot; end   Python の例：  router_info = get_all_router_info() # router_name, connection_state, num_clients, tx_q_size, rx_q_size, tx_bytes, rx_bytes, pkts_rcvd, pkts_sent for router in router_info: print(f&quot;Router: {router[0]}, Connection state: {router[1]}, Num connected clients: {router[2]}&quot;) print(f&quot;Transmit queue size: {router[3]}, Receive queue size: {router[4]}, Bytes transmitted: {router[5]}, Bytes received: {router[6]}&quot;) print(f&quot;Packets received: {router[7]}, Packets sent: {router[8]}&quot;)   ","version":"次へ","tagName":"h3"},{"title":"start_raw_logging_router​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#start_raw_logging_router","content":" 1つまたはすべてのルーターでの生データのロギングを開始します。これはデバッグ目的のみです。  Ruby / Python 構文：  start_raw_logging_router(&quot;&lt;Router Name (オプション)&gt;&quot;)   パラメータ\t説明Router Name\t生データロギングを開始するように命令するルーターの名前。デフォルトは 'ALL' で、生データロギングをサポートするすべてのルーターで生データのロギングを開始します。  Ruby / Python の例：  start_raw_logging_router(&quot;router1&quot;)   ","version":"次へ","tagName":"h3"},{"title":"stop_raw_logging_router​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#stop_raw_logging_router","content":" 1つまたはすべてのルーターでの生データのロギングを停止します。これはデバッグ目的のみです。  Ruby / Python 構文：  stop_raw_logging_router(&quot;&lt;Router Name (オプション)&gt;&quot;)   パラメータ\t説明Router Name\t生データロギングを停止するように命令するルーターの名前。デフォルトは 'ALL' で、生データロギングをサポートするすべてのルーターで生データのロギングを停止します。  Ruby / Python の例：  stop_raw_logging_router(&quot;router1&quot;)   ","version":"次へ","tagName":"h3"},{"title":"router_cmd​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#router_cmd","content":" コマンドを直接ルーターに送信します。これは標準のCOSMOSルーターでは効果がありませんが、動作を変更するためにカスタムルーターで実装できます。  Ruby / Python 構文：  router_cmd(&quot;&lt;Router Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;&lt;Command Parameters&gt;&quot;)   パラメータ\t説明Router Name\tルーターの名前 Command Name\t送信するコマンドの名前 Command Parameters\tコマンドと共に送信するパラメータ  Ruby / Python の例：  router_cmd(&quot;INST&quot;, &quot;DISABLE_CRC&quot;)   ","version":"次へ","tagName":"h3"},{"title":"router_protocol_cmd​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#router_protocol_cmd","content":" コマンドを直接ルータープロトコルに送信します。これは標準のCOSMOSプロトコルでは効果がありませんが、動作を変更するためにカスタムプロトコルで実装できます。  Ruby / Python 構文：  router_protocol_cmd(&quot;&lt;Router Name&gt;&quot;, &quot;&lt;Command Name&gt;&quot;, &quot;&lt;Command Parameters&gt;&quot;, read_write, index)   パラメータ\t説明Router Name\tルーターの名前 Command Name\t送信するコマンドの名前 Command Parameters\tコマンドと共に送信するパラメータ read_write\tコマンドが送信される読み取りまたは書き込みプロトコル。READ、WRITE、または READ_WRITE（Rubyではシンボル、Pythonでは文字列）のいずれかである必要があります。デフォルトは READ_WRITE です。 index\tスタック内のどのプロトコルにコマンドが適用されるか。デフォルトは -1 で、すべてにコマンドを適用します。  Ruby の例：  router_protocol_cmd(&quot;INST&quot;, &quot;DISABLE_CRC&quot;, read_write: :READ_WRITE, index: -1)   Python の例：  router_protocol_cmd(&quot;INST&quot;, &quot;DISABLE_CRC&quot;, read_write='READ_WRITE', index=-1)   ","version":"次へ","tagName":"h3"},{"title":"テーブル​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#テーブル","content":" これらのメソッドを使用すると、ユーザーはTable Managerをスクリプト化できます。  ","version":"次へ","tagName":"h2"},{"title":"table_create_binary​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#table_create_binary","content":" バージョン 6.1.0 以降  テーブル定義ファイルに基づいてテーブルバイナリを作成します。Table Manager GUIの「ファイル (File)-&gt;新規ファイル (New File)」と同じ結果を得ることができます。作成されたバイナリファイルへのパスを返します。  Ruby / Python 構文：  table_create_binary(&lt;Table Definition File&gt;)   パラメータ\t説明Table Definition File\tテーブル定義ファイルへのパス（例：INST/tables/config/ConfigTables_def.txt）  Ruby の例：  # table_create_binaryを使用してからバイナリを編集する完全な例 require 'openc3/tools/table_manager/table_config' # これはハッシュを返します: {&quot;filename&quot;=&gt;&quot;INST/tables/bin/MCConfigurationTable.bin&quot;} table = table_create_binary(&quot;INST/tables/config/MCConfigurationTable_def.txt&quot;) file = get_target_file(table['filename']) table_binary = file.read() # バイナリを処理するために定義ファイルを取得 def_file = get_target_file(&quot;INST/tables/config/MCConfigurationTable_def.txt&quot;) # 定義を処理するために内部TableConfigにアクセス config = OpenC3::TableConfig.process_file(def_file.path()) # 定義名でテーブルを取得（例：TABLE &quot;MC_Configuration&quot;） table = config.table('MC_CONFIGURATION') # これでテーブル内の個々の項目を読み書きできます table.write(&quot;MEMORY_SCRUBBING&quot;, &quot;DISABLE&quot;) # 最後にtable.buffer（バイナリ）をストレージに書き戻します put_target_file(&quot;INST/tables/bin/MCConfigurationTable_NoScrub.bin&quot;, table.buffer)   Python の例：  # table_create_binaryを使用してからバイナリを編集する完全な例 from openc3.tools.table_manager.table_config import TableConfig # 辞書を返します: {'filename': 'INST/tables/bin/ConfigTables.bin'} table = table_create_binary(&quot;INST2/tables/config/ConfigTables_def.txt&quot;) file = get_target_file(table['filename']) table_binary = file.read() # バイナリを処理するために定義ファイルを取得 def_file = get_target_file(&quot;INST2/tables/config/MCConfigurationTable_def.txt&quot;) # 定義を処理するために内部TableConfigにアクセス config = TableConfig.process_file(def_file.name) # 定義名でテーブルを取得（例：TABLE &quot;MC_Configuration&quot;） table = config.table('MC_CONFIGURATION') # これでテーブル内の個々の項目を読み書きできます table.write(&quot;MEMORY_SCRUBBING&quot;, &quot;DISABLE&quot;) # 最後にtable.buffer（バイナリ）をストレージに書き戻します put_target_file(&quot;INST2/tables/bin/MCConfigurationTable_NoScrub.bin&quot;, table.buffer)   ","version":"次へ","tagName":"h3"},{"title":"table_create_report​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#table_create_report","content":" バージョン 6.1.0 以降  テーブル定義ファイルに基づいてテーブルバイナリを作成します。Table Manager GUIの「ファイル-&gt;新規ファイル」と同じ結果を得ることができます。作成されたバイナリファイルへのパスを返します。  Ruby / Python 構文：  table_create_report(&lt;Table Binary Filename&gt;, &lt;Table Definition File&gt;, &lt;Table Name (オプション)&gt;)   filename, definition, table_name  パラメータ\t説明Table Binary File\tテーブルバイナリファイルへのパス（例：INST/tables/bin/ConfigTables.bin） Table Definition File\tテーブル定義ファイルへのパス（例：INST/tables/config/ConfigTables_def.txt） Table Name\tレポートを作成するテーブルの名前。これはテーブルバイナリとテーブル定義が複数のテーブルで構成されている場合にのみ適用されます。デフォルトでは、レポートはすべてのテーブルで構成され、バイナリファイルにちなんで名前が付けられます。テーブル名が指定されている場合、レポートは指定されたテーブルのみで構成され、テーブルにちなんで名前が付けられます。  Ruby の例：  table = table_create_report(&quot;INST/tables/bin/ConfigTables.bin&quot;, &quot;INST/tables/config/ConfigTables_def.txt&quot;) #=&gt; # {&quot;filename&quot;=&gt;&quot;INST/tables/bin/ConfigTables.csv&quot;, &quot;contents&quot;=&gt;&quot;MC_CONFIGURATION\\nLabel, ... table = table_create_report(&quot;INST/tables/bin/ConfigTables.bin&quot;, &quot;INST/tables/config/ConfigTables_def.txt&quot;, table_name: &quot;MC_CONFIGURATION&quot;) #=&gt; # {&quot;filename&quot;=&gt;&quot;INST/tables/bin/McConfiguration.csv&quot;, &quot;contents&quot;=&gt;&quot;MC_CONFIGURATION\\nLabel, ...   Python の例：  table = table_create_report(&quot;INST/tables/bin/ConfigTables.bin&quot;, &quot;INST/tables/config/ConfigTables_def.txt&quot;) #=&gt; # {'filename': 'INST/tables/bin/ConfigTables.csv', 'contents': 'MC_CONFIGURATION\\nLabel, ... table = table_create_report(&quot;INST/tables/bin/ConfigTables.bin&quot;, &quot;INST/tables/config/ConfigTables_def.txt&quot;, table_name=&quot;MC_CONFIGURATION&quot;) #=&gt; # {'filename': 'INST/tables/bin/ConfigTables.csv', 'contents': 'MC_CONFIGURATION\\nLabel, ...   ","version":"次へ","tagName":"h3"},{"title":"データのスタッシュ​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#データのスタッシュ","content":" これらのメソッドを使用すると、ユーザーは一時的なデータをCOSMOSに保存して取得できます。ストレージはキー/値ストレージ（Rubyのハッシュまたはpythonの辞書）として実装されています。これは、複数のスクリプトや単一スクリプトの複数の実行にまたがって適用される情報を保存するためにスクリプトで使用できます。  ","version":"次へ","tagName":"h2"},{"title":"stash_set​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#stash_set","content":" スタッシュアイテムを設定します。  Ruby / Python 構文：  stash_set(&quot;&lt;Stash Key&gt;&quot;, &lt;Stash Value&gt;)   パラメータ\t説明Stash Key\t設定するスタッシュキーの名前 Stash Value\t設定する値  Ruby / Python の例：  stash_set('run_count', 5) stash_set('setpoint', 23.4)   ","version":"次へ","tagName":"h3"},{"title":"stash_get​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#stash_get","content":" 指定されたスタッシュアイテムを返します。  Ruby / Python 構文：  stash_get(&quot;&lt;Stash Key&gt;&quot;)   パラメータ\t説明Stash Key\t返すスタッシュキーの名前  Ruby / Python の例：  stash_get('run_count') #=&gt; 5   ","version":"次へ","tagName":"h3"},{"title":"stash_all​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#stash_all","content":" すべてのスタッシュアイテムをRubyのハッシュまたはPythonの辞書として返します。  Ruby の例：  stash_all() #=&gt; ['run_count' =&gt; 5, 'setpoint' =&gt; 23.4]   Python の例：  stash_all() #=&gt; ['run_count': 5, 'setpoint': 23.4]   ","version":"次へ","tagName":"h3"},{"title":"stash_keys​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#stash_keys","content":" すべてのスタッシュキーを返します。  Ruby / Python の例：  stash_keys() #=&gt; ['run_count', 'setpoint']   ","version":"次へ","tagName":"h3"},{"title":"stash_delete​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#stash_delete","content":" スタッシュアイテムを削除します。この操作は永続的であることに注意してください！  Ruby / Python 構文：  stash_delete(&quot;&lt;Stash Key&gt;&quot;)   パラメータ\t説明Stash Key\t削除するスタッシュキーの名前  Ruby / Python の例：  stash_delete(&quot;run_count&quot;)   ","version":"次へ","tagName":"h3"},{"title":"テレメトリ画面​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#テレメトリ画面","content":" これらのメソッドを使用すると、ユーザーはテスト手順内からテレメトリ画面を開いたり、閉じたり、一意のテレメトリ画面を作成したりできます。  ","version":"次へ","tagName":"h2"},{"title":"display_screen​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#display_screen","content":" 指定された位置にテレメトリ画面を開きます。  Ruby / Python 構文：  display_screen(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Screen Name&gt;&quot;, &lt;X Position (オプション)&gt;, &lt;Y Position (オプション)&gt;)   パラメータ\t説明Target Name\tテレメトリ画面のターゲット名 Screen Name\t指定されたターゲット内の画面名 X Position\t画面の左上隅のX座標 Y Position\t画面の左上隅のY座標  Ruby / Python の例：  display_screen(&quot;INST&quot;, &quot;ADCS&quot;, 100, 200)   ","version":"次へ","tagName":"h3"},{"title":"clear_screen​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#clear_screen","content":" 開いているテレメトリ画面を閉じます。  Ruby / Python 構文：  clear_screen(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Screen Name&gt;&quot;)   パラメータ\t説明Target Name\tテレメトリ画面のターゲット名 Screen Name\t指定されたターゲット内の画面名 Ruby / Python の例：\t  clear_screen(&quot;INST&quot;, &quot;ADCS&quot;)   ","version":"次へ","tagName":"h3"},{"title":"clear_all_screens​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#clear_all_screens","content":" 開いているすべての画面を閉じます。  Ruby / Python の例：  clear_all_screens()   ","version":"次へ","tagName":"h3"},{"title":"delete_screen​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#delete_screen","content":" 既存のTelemetry Viewer画面を削除します。  Ruby / Python 構文：  delete_screen(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Screen Name&gt;&quot;)   パラメータ\t説明Target Name\tテレメトリ画面のターゲット名 Screen Name\t指定されたターゲット内の画面名  Ruby / Python の例：  delete_screen(&quot;INST&quot;, &quot;ADCS&quot;)   ","version":"次へ","tagName":"h3"},{"title":"get_screen_list​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_screen_list","content":" 利用可能なテレメトリ画面のリストを返します。  Ruby / Python の例：  get_screen_list() #=&gt; ['INST ADCS', 'INST COMMANDING', ...]   ","version":"次へ","tagName":"h3"},{"title":"get_screen_definition​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_screen_definition","content":" テレメトリ画面定義のテキストファイルの内容を返します。  構文：  get_screen_definition(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Screen Name&gt;&quot;)   パラメータ\t説明Target Name\tテレメトリ画面のターゲット名 Screen Name\t指定されたターゲット内の画面名  Ruby / Python の例：  screen_definition = get_screen_definition(&quot;INST&quot;, &quot;HS&quot;)   ","version":"次へ","tagName":"h3"},{"title":"create_screen​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#create_screen","content":" スクリプトから直接画面を作成することができます。この画面は、そのアプリケーションで未来に使用するためにTelemetry Viewerに保存されます。  Ruby / Python 構文：  create_screen(&quot;&lt;Target Name&gt;&quot;, &quot;&lt;Screen Name&gt;&quot; &quot;&lt;Definition&gt;&quot;)   パラメータ\t説明Target Name\tテレメトリ画面のターゲット名 Screen Name\t指定されたターゲット内の画面名 Definition\t画面定義全体を文字列として  Ruby の例：  screen_def = ' SCREEN AUTO AUTO 0.1 FIXED VERTICAL TITLE &quot;New Screen&quot; VERTICALBOX LABELVALUE INST HEALTH_STATUS TEMP1 END END ' # ここでは画面定義を文字列として渡します create_screen(&quot;INST&quot;, &quot;LOCAL&quot;, screen_def)   Python の例：  screen_def = ' SCREEN AUTO AUTO 0.1 FIXED VERTICAL TITLE &quot;New Screen&quot; VERTICALBOX LABELVALUE INST HEALTH_STATUS TEMP1 END END ' # ここでは画面定義を文字列として渡します create_screen(&quot;INST&quot;, &quot;LOCAL&quot;, screen_def)   ","version":"次へ","tagName":"h3"},{"title":"local_screen​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#local_screen","content":" スクリプトから直接ローカル画面を作成することができます。この画面はTelemetry Viewerの画面リストに永続的に保存されません。これは、スクリプトとのユーザー対話を支援する一度限りの画面に役立ちます。  Ruby / Python 構文：  local_screen(&quot;&lt;Screen Name&gt;&quot;, &quot;&lt;Definition&gt;&quot;, &lt;X Position (オプション)&gt;, &lt;Y Position (オプション)&gt;)   パラメータ\t説明Screen Name\t指定されたターゲット内の画面名 Definition\t画面定義全体を文字列として X Position\t画面の左上隅のX座標 Y Position\t画面の左上隅のY座標  注意：表示可能な画面の外にX、Y位置を指定することも可能です。そうして画面を再作成しようとすると表示されません（すでに表示されているため）。まず clear_all_screens() を発行して、表示可能な画面スペースから画面をクリアしてみてください。  Ruby の例：  screen_def = ' SCREEN AUTO AUTO 0.1 FIXED VERTICAL TITLE &quot;Local Screen&quot; VERTICALBOX LABELVALUE INST HEALTH_STATUS TEMP1 END END ' # ここでは画面定義を文字列として渡します local_screen(&quot;TESTING&quot;, screen_def, 600, 75)   Python の例：  screen_def = &quot;&quot;&quot; SCREEN AUTO AUTO 0.1 FIXED VERTICAL TITLE &quot;Local Screen&quot; VERTICALBOX LABELVALUE INST HEALTH_STATUS TEMP1 END END &quot;&quot;&quot; # ここでは画面定義を文字列として渡します local_screen(&quot;TESTING&quot;, screen_def, 600, 75)   ","version":"次へ","tagName":"h3"},{"title":"Script Runner スクリプト​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script-runner-スクリプト","content":" これらのメソッドを使用すると、ユーザーはScript Runnerスクリプトを制御できます。  ","version":"次へ","tagName":"h2"},{"title":"start​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#start","content":" 高レベルテスト手順の実行を開始します。Script Runnerはファイルをロードし、呼び出し元の手順に戻る前に直ちに実行を開始します。高レベルテスト手順にパラメータを渡すことはできません。パラメータが必要な場合は、サブルーチンの使用を検討してください。  Ruby / Python 構文：  start(&quot;&lt;Procedure Filename&gt;&quot;)   パラメータ\t説明Procedure Filename\tテスト手順ファイルの名前。これらのファイルは通常、proceduresフォルダにありますが、Rubyの検索パスのどこにでも配置できます。さらに、絶対パスもサポートされています。  Ruby / Python の例：  start(&quot;test1.rb&quot;)   ","version":"次へ","tagName":"h3"},{"title":"load_utility​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#load_utility","content":" テスト手順で使用するための便利なサブルーチンを含むスクリプトファイルを読み込みます。これらのサブルーチンがScriptRunnerまたはTestRunnerで実行されると、それらの行が強調表示されます。サブルーチンをインポートしたいが、ScriptRunnerまたはTestRunnerでそれらの行を強調表示したくない場合は、標準のRubyの 'load' または 'require' ステートメント、またはPythonの 'import' ステートメントを使用してください。  Ruby / Python 構文：  load_utility(&quot;TARGET/lib/&lt;Utility Filename&gt;&quot;)   パラメータ\t説明Utility Filename\t.rb または .py 拡張子を含むサブルーチンを含むスクリプトファイルの名前。TARGET/lib/utility.rb のような完全なターゲット名とパスを含める必要があります  Ruby / Python の例：  load_utility(&quot;TARGET/lib/mode_changes.rb&quot;) # Ruby load_utility(&quot;TARGET/lib/mode_changes.py&quot;) # Python   ","version":"次へ","tagName":"h3"},{"title":"script_list​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script_list","content":" COSMOSで使用可能なすべてのファイルを配列/リストとして返します。これには、ユーザーがすべてのファイルにアクセスできるように、あらゆるディレクトリレベルの設定ファイルが含まれます。必要に応じて、クライアント側でリストを 'lib' や 'procedures' ディレクトリのみにフィルタリングすることができます。注意：スクリプト名には、変更を示す '*' は含まれません。  Ruby の例：  scripts = script_list() puts scripts.length #=&gt; 139 puts scripts.select {|script| script.include?('/lib/') || script.include?('/procedures/')} #=&gt; # [EXAMPLE/lib/example_interface.rb, INST/lib/example_limits_response.rb, ...]   Python の例：  scripts = script_list() print(len(scripts)) print(list(script for script in scripts if '/lib/' in script or '/procedures/' in script)) #=&gt; # [EXAMPLE/lib/example_interface.rb, INST/lib/example_limits_response.rb, ...]   ","version":"次へ","tagName":"h3"},{"title":"script_create​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script_create","content":" 指定された内容で新しいスクリプトを作成します。  Ruby / Python 構文：  script_create(&quot;&lt;Script Name&gt;&quot;, &quot;&lt;Script Contents&gt;&quot;)   パラメータ\t説明Script Name\tターゲットから始まるスクリプトの完全なパス名 Script Contents\tテキストとしてのスクリプトの内容  Ruby の例：  contents = 'puts &quot;Hello from Ruby&quot;' script_create(&quot;INST/procedures/new_script.rb&quot;, contents)   Python の例：  contents = 'print(&quot;Hello from Python&quot;)' script_create(&quot;INST2/procedures/new_script.py&quot;, contents)   ","version":"次へ","tagName":"h3"},{"title":"script_body​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script_body","content":" スクリプトの内容を返します。  Ruby / Python 構文：  script_body(&quot;&lt;Script Name&gt;&quot;)   パラメータ\t説明Script Name\tターゲットから始まるスクリプトの完全なパス名  Ruby の例：  script = script_body(&quot;INST/procedures/checks.rb&quot;) puts script #=&gt; # Display all environment variables\\nputs ENV.inspect ...   Python の例：  script = script_body(&quot;INST2/procedures/checks.py&quot;) print(script) #=&gt; # import os\\n\\n# Display the environment variables ...   ","version":"次へ","tagName":"h3"},{"title":"script_delete​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script_delete","content":" COSMOSからスクリプトを削除します。注意：実際に削除できるのはTEMPスクリプトと変更されたスクリプトのみです。インストールされたCOSMOSプラグインの一部であるスクリプトは、インストールされたままの状態を維持します。  Ruby / Python 構文：  script_delete(&quot;&lt;Script Name&gt;&quot;)   パラメータ\t説明Script Name\tターゲットから始まるスクリプトの完全なパス名  Ruby / Python の例：  script_delete(&quot;INST/procedures/checks.rb&quot;)   ","version":"次へ","tagName":"h3"},{"title":"script_run​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script_run","content":" Script Runnerでスクリプトを実行します。スクリプトはバックグラウンドで実行され、Script Runnerの「Script-&gt;Execution Status」を選択して接続することで開くことができます。  注意：Enterpriseでは、このメソッドを呼び出すユーザーに対して initialize_offline_access が少なくとも1回呼び出されている必要があります。  Ruby / Python 構文：  script_run(&quot;&lt;Script Name&gt;&quot;)   パラメータ\t説明Script Name\tターゲットから始まるスクリプトの完全なパス名  Ruby の例：  id = script_run(&quot;INST/procedures/checks.rb&quot;) puts id   Python の例：  id = script_run(&quot;INST2/procedures/checks.py&quot;) print(id)   ","version":"次へ","tagName":"h3"},{"title":"script_lock​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script_lock","content":" 編集のためにスクリプトをロックします。このスクリプトを後続のユーザーが開くと、スクリプトが現在ロックされているという警告が表示されます。  Ruby / Python 構文：  script_lock(&quot;&lt;Script Name&gt;&quot;)   パラメータ\t説明Script Name\tターゲットから始まるスクリプトの完全なパス名  Ruby / Python の例：  script_lock(&quot;INST/procedures/checks.rb&quot;)   ","version":"次へ","tagName":"h3"},{"title":"script_unlock​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script_unlock","content":" 編集のためにスクリプトのロックを解除します。スクリプトが以前にロックされていなかった場合、何も行いません。  Ruby / Python 構文：  script_unlock(&quot;&lt;Script Name&gt;&quot;)   パラメータ\t説明Script Name\tターゲットから始まるスクリプトの完全なパス名  Ruby / Python の例：  script_unlock(&quot;INST/procedures/checks.rb&quot;)   ","version":"次へ","tagName":"h3"},{"title":"script_syntax_check​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script_syntax_check","content":" 指定されたスクリプトに対してRubyまたはPython構文チェックを実行します。  Ruby / Python 構文：  script_syntax_check(&quot;&lt;Script Name&gt;&quot;)   パラメータ\t説明Script Name\tターゲットから始まるスクリプトの完全なパス名  Ruby の例：  result = script_syntax_check(&quot;INST/procedures/checks.rb&quot;) puts result #=&gt; {&quot;title&quot;=&gt;&quot;Syntax Check Successful&quot;, &quot;description&quot;=&gt;&quot;[\\&quot;Syntax OK\\\\n\\&quot;]&quot;, &quot;success&quot;=&gt;true}   Python の例：  result = script_syntax_check(&quot;INST2/procedures/checks.py&quot;) print(result) #=&gt; {'title': 'Syntax Check Successful', 'description': '[&quot;Syntax OK&quot;]', 'success': True}   ","version":"次へ","tagName":"h3"},{"title":"script_instrumented​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script_instrumented","content":" COSMOSスクリプトランナーが実行を監視し、行ごとの視覚化を提供できるようにする計装済みスクリプトを返します。これは主にCOSMOS開発者によって使用される低レベルのデバッグメソッドです。  Ruby / Python 構文：  script_instrumented(&quot;&lt;Script Name&gt;&quot;)   パラメータ\t説明Script Name\tターゲットから始まるスクリプトの完全なパス名  Ruby の例：  script = script_instrumented(&quot;INST/procedures/checks.rb&quot;) puts script #=&gt; private; __return_val = nil; begin; RunningScript.instance.script_binding = binding(); ...   Python の例：  script = script_instrumented(&quot;INST2/procedures/checks.py&quot;) print(script) #=&gt; while True:\\ntry:\\nRunningScript.instance.pre_line_instrumentation ...   ","version":"次へ","tagName":"h3"},{"title":"script_delete_all_breakpoints​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script_delete_all_breakpoints","content":" すべてのスクリプトに関連付けられたすべてのブレークポイントを削除します。  Ruby / Python の例：  script_delete_all_breakpoints()   ","version":"次へ","tagName":"h3"},{"title":"step_mode​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#step_mode","content":" ScriptRunnerをステップモードにします。次の行に進むには「Go」をクリックする必要があります。  Ruby / Python の例：  step_mode()   ","version":"次へ","tagName":"h3"},{"title":"run_mode​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#run_mode","content":" ScriptRunnerを実行モードにします。次の行は自動的に実行されます。  Ruby / Python の例：  run_mode()   ","version":"次へ","tagName":"h3"},{"title":"disconnect_script​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#disconnect_script","content":" スクリプトを切断モードにします。切断モードでは、コマンドはターゲットに送信されず、すべてのチェックは成功し、待機は即座に期限切れになります。テレメトリのリクエスト（tlm()）は通常0を返します。切断モードは、接続されていないターゲットでスクリプトをドライランするのに役立ちます。  Ruby / Python の例：  disconnect_script()   ","version":"次へ","tagName":"h3"},{"title":"running_script_list​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#running_script_list","content":" 現在実行中のスクリプトをリストします。注意：このメソッドを呼び出しているスクリプトも含まれます。したがって、リストは決して空にならず、常に少なくとも1つの項目が含まれます。ハッシュの配列/辞書のリストを返します（ハッシュ/辞書の内容についてはrunning_script_getを参照）。  Ruby の例：  running_script_list() #=&gt; [{&quot;id&quot;=&gt;5, &quot;scope&quot;=&gt;&quot;DEFAULT&quot;, &quot;name&quot;=&gt;&quot;__TEMP__/2025_01_15_13_16_26_210_temp.rb&quot;, &quot;user&quot;=&gt;&quot;Anonymous&quot;, &quot;start_time&quot;=&gt;&quot;2025-01-15 20:16:52 +0000&quot;, &quot;disconnect&quot;=&gt;false, &quot;environment&quot;=&gt;[]}]   Python の例：  running_script_list() #=&gt; [{'id': 15, 'scope': 'DEFAULT', 'name': 'INST2/procedures/scripting.py', 'user': 'Anonymous', 'start_time': '2025-01-16 17:36:22 +0000', 'disconnect': False, 'environment': []}]   ","version":"次へ","tagName":"h3"},{"title":"running_script_get​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#running_script_get","content":" 指定されたIDで現在実行中のスクリプトを取得します。返される情報は、スクリプトID、スコープ、名前、ユーザー、開始時間、切断状態、環境変数、ホスト名、状態、行番号、更新時間です。  Ruby / Python 構文：  running_script_get(&quot;&lt;Script Id&gt;&quot;)   パラメータ\t説明Script Id\tscript_runによって返されるスクリプトID  Ruby の例：  running_script_get(15) #=&gt; {&quot;id&quot;=&gt;15, &quot;scope&quot;=&gt;&quot;DEFAULT&quot;, &quot;name&quot;=&gt;&quot;INST/procedures/new_script.rb&quot;, &quot;user&quot;=&gt;&quot;Anonymous&quot;, &quot;start_time&quot;=&gt;&quot;2025-01-16 00:28:44 +0000&quot;, &quot;disconnect&quot;=&gt;false, &quot;environment&quot;=&gt;[], &quot;hostname&quot;=&gt;&quot;ac9dde3c59c1&quot;, &quot;state&quot;=&gt;&quot;spawning&quot;, &quot;line_no&quot;=&gt;1, &quot;update_time&quot;=&gt;&quot;2025-01-16 00:28:44 +0000&quot;}   Python の例：  running_script_get(15) #=&gt; {'id': 15, 'scope': 'DEFAULT', 'name': 'INST2/procedures/new_script.py', 'user': 'Anonymous', 'start_time': '2025-01-16 18:04:03 +0000', 'disconnect': False, 'environment': [], 'hostname': 'b84dbcee54ad', 'state': 'running', 'line_no': 3, 'update_time': '2025-01-16T18:04:05.255638Z'}   ","version":"次へ","tagName":"h3"},{"title":"running_script_stop​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#running_script_stop","content":" 指定されたIDの実行中のスクリプトを停止します。これはScript Runner GUIの「Stop」ボタンをクリックするのと同じです。  Ruby / Python 構文：  running_script_stop(&quot;&lt;Script Id&gt;&quot;)   パラメータ\t説明Script Id\tscript_runによって返されるスクリプトID  Ruby / Python の例：  running_script_stop(15)   ","version":"次へ","tagName":"h3"},{"title":"running_script_pause​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#running_script_pause","content":" 指定されたIDの実行中のスクリプトを一時停止します。これはScript Runner GUIの「Pause」ボタンをクリックするのと同じです。  Ruby / Python 構文：  running_script_pause(&quot;&lt;Script Id&gt;&quot;)   パラメータ\t説明Script Id\tscript_runによって返されるスクリプトID  Ruby / Python の例：  running_script_pause(15)   ","version":"次へ","tagName":"h3"},{"title":"running_script_retry​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#running_script_retry","content":" 指定されたIDの実行中のスクリプトの現在の行を再試行します。これはScript Runner GUIの「Retry」ボタンをクリックするのと同じです。  Ruby / Python 構文：  running_script_retry(&quot;&lt;Script Id&gt;&quot;)   パラメータ\t説明Script Id\tscript_runによって返されるスクリプトID  Ruby / Python の例：  running_script_retry(15)   ","version":"次へ","tagName":"h3"},{"title":"running_script_go​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#running_script_go","content":" 指定されたIDの実行中のスクリプトの一時停止を解除します。これはScript Runner GUIの「Go」ボタンをクリックするのと同じです。  Ruby / Python 構文：  running_script_go(&quot;&lt;Script Id&gt;&quot;)   パラメータ\t説明Script Id\tscript_runによって返されるスクリプトID  Ruby / Python の例：  running_script_go(15)   ","version":"次へ","tagName":"h3"},{"title":"running_script_step​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#running_script_step","content":" 指定されたIDの実行中のスクリプトをステップ実行します。これはScript Runner GUIのDebugウィンドウの「Step」ボタンをクリックするのと同じです。  Ruby / Python 構文：  running_script_step(&quot;&lt;Script Id&gt;&quot;)   パラメータ\t説明Script Id\tscript_runによって返されるスクリプトID  Ruby / Python の例：  running_script_step(15)   ","version":"次へ","tagName":"h3"},{"title":"running_script_delete​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#running_script_delete","content":" 指定されたIDの実行中のスクリプトを強制終了します。これはScript Runner GUIのScript -&gt; Execution Statusページの「Running Scripts」の下にある「Delete」ボタンをクリックするのと同じです。注意：まず「stop」信号が指定されたスクリプトに送信され、その後スクリプトが強制的に削除されます。通常はrunning_script_stopメソッドを使用する必要があります。  Ruby / Python 構文：  running_script_delete(&quot;&lt;Script Id&gt;&quot;)   パラメータ\t説明Script Id\tscript_runによって返されるスクリプトID  Ruby / Python の例：  running_script_delete(15)   ","version":"次へ","tagName":"h3"},{"title":"completed_script_list​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#completed_script_list","content":" 完了したスクリプトをリストします。id、ユーザー名、スクリプト名、スクリプトログ、開始時間を含むハッシュの配列/辞書のリストを返します。  Ruby の例：  completed_script_list() #=&gt; [{&quot;id&quot;=&gt;&quot;15&quot;, &quot;user&quot;=&gt;&quot;Anonymous&quot;, &quot;name&quot;=&gt;&quot;__TEMP__/2025_01_15_17_07_51_568_temp.rb&quot;, &quot;log&quot;=&gt;&quot;DEFAULT/tool_logs/sr/20250116/2025_01_16_00_28_43_sr_2025_01_15_17_07_51_568_temp.txt&quot;, &quot;start&quot;=&gt;&quot;2025-01-16 00:28:43 +0000&quot;}, ...]   Python の例：  completed_script_list() #=&gt; [{'id': 16, 'user': 'Anonymous', 'name': 'INST2/procedures/new_script.py', 'log': 'DEFAULT/tool_logs/sr/20250116/2025_01_16_17_46_22_sr_new_script.txt', 'start': '2025-01-16 17:46:22 +0000'}, ...]   ","version":"次へ","tagName":"h3"},{"title":"Script Runner 設定​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script-runner-設定","content":" これらのメソッドを使用すると、ユーザーはさまざまなScript Runner設定を制御できます。  ","version":"次へ","tagName":"h2"},{"title":"set_line_delay​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#set_line_delay","content":" このメソッドはスクリプトランナーの行遅延を設定します。  Ruby / Python 構文：  set_line_delay(&lt;Delay&gt;)   パラメータ\t説明Delay\tスクリプトを実行するときにスクリプトランナーが行間で待機する時間（秒）。 ≥ 0.0でなければなりません  Ruby / Python の例：  set_line_delay(0.0)   ","version":"次へ","tagName":"h3"},{"title":"get_line_delay​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_line_delay","content":" このメソッドはスクリプトランナーが現在使用している行遅延を取得します。  Ruby / Python の例：  curr_line_delay = get_line_delay()   ","version":"次へ","tagName":"h3"},{"title":"set_max_output​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#set_max_output","content":" このメソッドは、切り捨てる前にScript Runner出力に表示する最大文字数を設定します。デフォルトは50,000文字です。  Ruby / Python 構文：  set_max_output(&lt;Characters&gt;)   パラメータ\t説明Characters\t切り捨てる前に出力する文字数  Ruby / Python の例：  set_max_output(100)   ","version":"次へ","tagName":"h3"},{"title":"get_max_output​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_max_output","content":" このメソッドは、切り捨てる前にScript Runner出力に表示する最大文字数を取得します。デフォルトは50,000文字です。  Ruby / Python の例：  print(get_max_output()) #=&gt; 50000   ","version":"次へ","tagName":"h3"},{"title":"disable_instrumentation​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#disable_instrumentation","content":" コードブロックの計装（行の強調表示と例外のキャッチ）を無効にします。これは特に、行が計装されていると非常に遅くなるループを高速化するのに役立ちます。 このようなコードを別のファイルに分割して、require/loadを使用してファイルを読み込むことで、同じ効果を得ながらスクリプトでエラーをキャッチできるようにすることを検討してください。  注意して使用してください 計装を無効にすると、無効中に発生したエラーによって、スクリプトが完全に停止します。  Ruby の例：  disable_instrumentation do 1000.times do # 1000回強調表示する必要がないようにする end end   Python の例：  with disable_instrumentation(): for x in range(1000): # 1000回強調表示する必要がないようにする   ","version":"次へ","tagName":"h3"},{"title":"Script Runner スイート​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#script-runner-スイート","content":" Script Runnerスイートの作成には、定義されたスイートにグループを追加するAPIを利用します。詳細についてはスクリプトスイートの実行を参照してください。  ","version":"次へ","tagName":"h2"},{"title":"add_group, add_group_setup, add_group_teardown, add_script​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#add_group-add_group_setup-add_group_teardown-add_script","content":" グループのメソッドをスイートに追加します。add_groupメソッドは、setup、teardown、および 'script_' または 'test_' で始まるすべてのメソッドを含むグループメソッド全体を追加します。add_group_setupメソッドは、グループクラスで定義されたsetupメソッドのみを追加します。add_group_teardownメソッドは、グループクラスで定義されたteardownメソッドのみを追加します。add_scriptメソッドは、個々のメソッドをスイートに追加します。注意：add_scriptは、'script_' または 'test_' という名前が付いていないメソッドを含む任意のメソッドを追加できます。  Ruby / Python 構文：  add_group(&lt;Group Class&gt;) add_group_setup(&lt;Group Class&gt;) add_group_teardown(&lt;Group Class&gt;) add_script(&lt;Group Class&gt;, &lt;Method&gt;)   パラメータ\t説明Group Class\tOpenC3 Groupクラスを継承する、以前に定義されたクラスの名前。Ruby APIはグループの名前を持つ文字列を渡します。Python APIはGroupクラスを直接渡します。 Method\tOpenC3 Groupクラスのメソッドの名前。Ruby APIはメソッドの名前を持つ文字列を渡します。Python APIはGroupクラスを直接渡します。  Ruby の例：  load 'openc3/script/suite.rb' class ExampleGroup &lt; OpenC3::Group def script_1 # テストコードをここに挿入... end end class WrapperGroup &lt; OpenC3::Group def setup # テストコードをここに挿入... end def my_method # テストコードをここに挿入... end def teardown # テストコードをここに挿入... end end class MySuite &lt; OpenC3::Suite def initialize super() add_group('ExampleGroup') add_group_setup('WrapperGroup') add_script('WrapperGroup', 'my_method') add_group_teardown('WrapperGroup') end end   Python の例：  from openc3.script import * from openc3.script.suite import Group, Suite class ExampleGroup(Group): def script_1(self): # テストコードをここに挿入... pass class WrapperGroup(Group): def setup(self): # テストコードをここに挿入... pass def my_method(self): # テストコードをここに挿入... pass def teardown(self): # テストコードをここに挿入... pass class MySuite(Suite): def __init__(self): super().__init__() self.add_group(ExampleGroup) self.add_group_setup(WrapperGroup) self.add_script(WrapperGroup, 'my_method') self.add_group_teardown(WrapperGroup)   ","version":"次へ","tagName":"h3"},{"title":"タイムライン​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#タイムライン","content":" タイムラインAPIを使用すると、カレンダータイムラインを操作できます。カレンダーはCOSMOS Enterpriseツールです。  ","version":"次へ","tagName":"h2"},{"title":"list_timelines​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#list_timelines","content":" すべてのタイムラインをハッシュの配列/辞書のリストとして返します。  Ruby の例：  timelines = list_timelines() #=&gt; # [{&quot;name&quot;=&gt;&quot;Mine&quot;, &quot;color&quot;=&gt;&quot;#e67643&quot;, &quot;execute&quot;=&gt;true, &quot;shard&quot;=&gt;0, &quot;scope&quot;=&gt;&quot;DEFAULT&quot;, &quot;updated_at&quot;=&gt;1737124024123643504}]   Python の例：  timelihes = list_timelines() #=&gt; # [{'name': 'Mine', 'color': '#e67643', 'execute': True, 'shard': 0, 'scope': 'DEFAULT', 'updated_at': 1737124024123643504}]   ","version":"次へ","tagName":"h3"},{"title":"create_timeline​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#create_timeline","content":" アクティビティを保持できるカレンダーに新しいタイムラインを作成します。  Ruby 構文：  create_timeline(name, color: nil)   Python 構文：  create_timeline(name, color=None)   パラメータ\t説明name\tタイムラインの名前 color\tタイムラインの色。16進値として指定する必要があります（例：#FF0000）。デフォルトはランダムな色です。  Ruby の例：  tl = create_timeline(&quot;Mine&quot;) #=&gt; # {&quot;name&quot;=&gt;&quot;Mine&quot;, &quot;color&quot;=&gt;&quot;#e67643&quot;, &quot;execute&quot;=&gt;true, &quot;shard&quot;=&gt;0, &quot;scope&quot;=&gt;&quot;DEFAULT&quot;, &quot;updated_at&quot;=&gt;1737124024123643504}   Python の例：  tl = create_timeline(&quot;Other&quot;, color=&quot;#FF0000&quot;) #=&gt; # {'name': 'Other', 'color': '#FF0000', 'execute': True, 'shard': 0, 'scope': 'DEFAULT', 'updated_at': 1737126348971941923}   ","version":"次へ","tagName":"h3"},{"title":"get_timeline​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_timeline","content":" 既存のタイムラインに関する情報を取得します。  Ruby / Python 構文：  get_timeline(name)   パラメータ\t説明name\tタイムラインの名前  Ruby の例：  tl = get_timeline(&quot;Mine&quot;) #=&gt; # {&quot;name&quot;=&gt;&quot;Mine&quot;, &quot;color&quot;=&gt;&quot;#e67643&quot;, &quot;execute&quot;=&gt;true, &quot;shard&quot;=&gt;0, &quot;scope&quot;=&gt;&quot;DEFAULT&quot;, &quot;updated_at&quot;=&gt;1737124024123643504}   Python の例：  tl = get_timeline(&quot;Other&quot;) #=&gt; # {'name': 'Other', 'color': '#FF0000', 'execute': True, 'shard': 0, 'scope': 'DEFAULT', 'updated_at': 1737126348971941923}   ","version":"次へ","tagName":"h3"},{"title":"set_timeline_color​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#set_timeline_color","content":" 既存のタイムラインの表示色を設定します。  Ruby / Python 構文：  set_timeline_color(name, color)   パラメータ\t説明name\tタイムラインの名前 color\tタイムラインの色。16進値として指定する必要があります（例：#FF0000）。  Ruby / Python の例：  set_timeline_color(&quot;Mine&quot;, &quot;#4287f5&quot;)   ","version":"次へ","tagName":"h3"},{"title":"delete_timeline​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#delete_timeline","content":" 既存のタイムラインを削除します。アクティビティを持つタイムラインは、force = true を渡すことでのみ削除できます。  Ruby 構文：  delete_timeline(name, force: false)   Python 構文：  delete_timeline(name, force=False)   パラメータ\t説明name\tタイムラインの名前 force\tタイムラインにアクティビティがある場合に削除するかどうか。デフォルトは false です。  Ruby の例：  delete_timeline(&quot;Mine&quot;, force: true)   Python の例：  delete_timeline(&quot;Other&quot;, force=True)   ","version":"次へ","tagName":"h3"},{"title":"create_timeline_activity​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#create_timeline_activity","content":" 既存のタイムラインにアクティビティを作成します。アクティビティは COMMAND、SCRIPT、または RESERVE のいずれかです。アクティビティには開始時間と終了時間があり、コマンドとスクリプトは実行するコマンドまたはスクリプトに関するデータを取ります。  Ruby 構文：  create_timeline_activity(name, kind:, start:, stop:, data: {})   Python 構文：  create_timeline_activity(name, kind, start, stop, data={})   パラメータ\t説明name\tタイムラインの名前 kind\tアクティビティの種類。COMMAND、SCRIPT、またはRESERVEのいずれか。 start\tアクティビティの開始時間。Time / datetimeインスタンス。 stop\tアクティビティの終了時間。Time / datetimeインスタンス。 data\tCOMMANDまたはSCRIPT型のデータのハッシュ/辞書。デフォルトは空のハッシュ/辞書です。  Ruby の例：  now = Time.now() start = now + 3600 stop = start + 3600 act = create_timeline_activity(&quot;RubyTL&quot;, kind: &quot;RESERVE&quot;, start: start, stop: stop) #=&gt; # { &quot;name&quot;=&gt;&quot;RubyTL&quot;, &quot;updated_at&quot;=&gt;1737128705034982375, &quot;start&quot;=&gt;1737132303, &quot;stop&quot;=&gt;1737135903, # &quot;kind&quot;=&gt;&quot;reserve&quot;, &quot;data&quot;=&gt;{&quot;username&quot;=&gt;&quot;operator&quot;}, # &quot;scope&quot;=&gt;&quot;DEFAULT&quot;, &quot;fulfillment&quot;=&gt;false, &quot;uuid&quot;=&gt;&quot;5f373846-eb6c-43cd-97bd-cca19a8ffb04&quot;, # &quot;events&quot;=&gt;[{&quot;time&quot;=&gt;1737128705, &quot;event&quot;=&gt;&quot;created&quot;}], &quot;recurring&quot;=&gt;{}} act = create_timeline_activity(&quot;RubyTL&quot;, kind: &quot;COMMAND&quot;, start: start, stop: stop, data: {command: &quot;INST COLLECT with TYPE NORMAL, DURATION 5, TEMP 10&quot;}) #=&gt; # { &quot;name&quot;=&gt;&quot;RubyTL&quot;, &quot;updated_at&quot;=&gt;1737128761316084471, &quot;start&quot;=&gt;1737132303, &quot;stop&quot;=&gt;1737135903, # &quot;kind&quot;=&gt;&quot;command&quot;, &quot;data&quot;=&gt;{&quot;command&quot;=&gt;&quot;INST COLLECT with TYPE NORMAL, DURATION 5, TEMP 10&quot;, &quot;username&quot;=&gt;&quot;operator&quot;}, # &quot;scope&quot;=&gt;&quot;DEFAULT&quot;, &quot;fulfillment&quot;=&gt;false, &quot;uuid&quot;=&gt;&quot;cdb661b4-a65b-44e7-95e2-5e1dba80c782&quot;, # &quot;events&quot;=&gt;[{&quot;time&quot;=&gt;1737128761, &quot;event&quot;=&gt;&quot;created&quot;}], &quot;recurring&quot;=&gt;{}} act = create_timeline_activity(&quot;RubyTL&quot;, kind: &quot;SCRIPT&quot;, start: start, stop: stop, data: {environment: [{key: &quot;USER&quot;, value: &quot;JASON&quot;}], script: &quot;INST/procedures/checks.rb&quot;}) #=&gt; # { &quot;name&quot;=&gt;&quot;RubyTL&quot;, &quot;updated_at&quot;=&gt;1737128791047885970, &quot;start&quot;=&gt;1737135903, &quot;stop&quot;=&gt;1737139503, # &quot;kind&quot;=&gt;&quot;script&quot;, &quot;data&quot;=&gt;{&quot;environment&quot;=&gt;[{&quot;key&quot;=&gt;&quot;USER&quot;, &quot;value&quot;=&gt;&quot;JASON&quot;}], &quot;script&quot;=&gt;&quot;INST/procedures/checks.rb&quot;, &quot;username&quot;=&gt;&quot;operator&quot;}, # &quot;scope&quot;=&gt;&quot;DEFAULT&quot;, &quot;fulfillment&quot;=&gt;false, &quot;uuid&quot;=&gt;&quot;70426e3d-6313-4897-b159-6e5cd94ace1d&quot;, # &quot;events&quot;=&gt;[{&quot;time&quot;=&gt;1737128791, &quot;event&quot;=&gt;&quot;created&quot;}], &quot;recurring&quot;=&gt;{}}   Python の例：  now = datetime.now(timezone.utc) start = now + timedelta(hours=1) stop = start + timedelta(hours=1) act = create_timeline_activity(&quot;PythonTL&quot;, kind=&quot;RESERVE&quot;, start=start, stop=stop) #=&gt; # {'name': 'PythonTL', 'updated_at': 1737129305507111708, 'start': 1737132902, 'stop': 1737136502, # 'kind': 'reserve', 'data': {'username': 'operator'}, # 'scope': 'DEFAULT', 'fulfillment': False, 'uuid': '46328378-ed78-4719-ad70-e84951a196fd', # 'events': [{'time': 1737129305, 'event': 'created'}], 'recurring': {}} act = create_timeline_activity(&quot;PythonTL&quot;, kind=&quot;COMMAND&quot;, start=start, stop=stop, data={'command': &quot;INST COLLECT with TYPE NORMAL, DURATION 5, TEMP 10&quot;}) #=&gt; # {'name': 'PythonTL', 'updated_at': 1737129508886643928, 'start': 1737133108, 'stop': 1737136708, # 'kind': 'command', 'data': {'command': 'INST COLLECT with TYPE NORMAL, DURATION 5, TEMP 10', 'username': 'operator'}, # 'scope': 'DEFAULT', 'fulfillment': False, 'uuid': 'cddbf034-ccdd-4c36-91c2-2653a39b06a5', # 'events': [{'time': 1737129508, 'event': 'created'}], 'recurring': {}} start = now + timedelta(hours=2) stop = start + timedelta(hours=1) act = create_timeline_activity(&quot;PythonTL&quot;, kind=&quot;SCRIPT&quot;, start=start, stop=stop, data={'environment': [{'key': &quot;USER&quot;, 'value': &quot;JASON&quot;}], 'script': &quot;INST2/procedures/checks.py&quot;}) #=&gt; # {'name': 'PythonTL', 'updated_at': 1737129509288571345, 'start': 1737136708, 'stop': 1737140308, # 'kind': 'script', 'data': {'environment': [{'key': 'USER', 'value': 'JASON'}], 'script': 'INST2/procedures/checks.py', 'username': 'operator'}, # 'scope': 'DEFAULT', 'fulfillment': False, 'uuid': '4f8d791b-b138-4383-b5ec-85c28b2bea20', # 'events': [{'time': 1737129509, 'event': 'created'}], 'recurring': {}}   ","version":"次へ","tagName":"h3"},{"title":"get_timeline_activity​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_timeline_activity","content":" 既存のタイムラインアクティビティを取得します。  Ruby / Python 構文：  get_timeline_activity(name, start, uuid)   パラメータ\t説明name\tタイムラインの名前 start\tアクティビティの開始時間。Time / datetimeインスタンス。 uuid\tアクティビティのUUID  Ruby の例：  act = get_timeline_activity(&quot;RubyTL&quot;, 1737132303, &quot;cdb661b4-a65b-44e7-95e2-5e1dba80c782&quot;) #=&gt; # { &quot;name&quot;=&gt;&quot;RubyTL&quot;, &quot;updated_at&quot;=&gt;1737128761316084471, &quot;start&quot;=&gt;1737132303, &quot;stop&quot;=&gt;1737135903, # &quot;kind&quot;=&gt;&quot;command&quot;, &quot;data&quot;=&gt;{&quot;command&quot;=&gt;&quot;INST COLLECT with TYPE NORMAL, DURATION 5, TEMP 10&quot;, &quot;username&quot;=&gt;&quot;operator&quot;}, # &quot;scope&quot;=&gt;&quot;DEFAULT&quot;, &quot;fulfillment&quot;=&gt;false, &quot;uuid&quot;=&gt;&quot;cdb661b4-a65b-44e7-95e2-5e1dba80c782&quot;, # &quot;events&quot;=&gt;[{&quot;time&quot;=&gt;1737128761, &quot;event&quot;=&gt;&quot;created&quot;}], &quot;recurring&quot;=&gt;{}}   Python の例：  act = get_timeline_activity(&quot;PythonTL&quot;, 1737133108, &quot;cddbf034-ccdd-4c36-91c2-2653a39b06a5&quot;) #=&gt; # {'name': 'PythonTL', 'updated_at': 1737129508886643928, 'start': 1737133108, 'stop': 1737136708, # 'kind': 'command', 'data': {'command': 'INST COLLECT with TYPE NORMAL, DURATION 5, TEMP 10', 'username': 'operator'}, # 'scope': 'DEFAULT', 'fulfillment': False, 'uuid': 'cddbf034-ccdd-4c36-91c2-2653a39b06a5', # 'events': [{'time': 1737129508, 'event': 'created'}], 'recurring': {}}   ","version":"次へ","tagName":"h3"},{"title":"get_timeline_activities​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_timeline_activities","content":" 開始時間と終了時間の間のタイムラインアクティビティの範囲を取得します。開始/終了時間なしで呼び出された場合、デフォルトは「現在」の1週間前から「現在」の1週間後までです（合計2週間）。  Ruby 構文：  get_timeline_activities(name, start: nil, stop: nil, limit: nil)   Python 構文：  get_timeline_activities(name, start=None, stop=None, limit=None)   パラメータ\t説明name\tタイムラインの名前 start\tアクティビティの開始時間。Time / datetimeインスタンス。デフォルトは7日前。 stop\tアクティビティの終了時間。Time / datetimeインスタンス。デフォルトは今から7日後。 limit\t返すアクティビティの最大数。デフォルトは時間範囲の1分あたり1つです。  Ruby の例：  acts = get_timeline_activities(&quot;RubyTL&quot;, start: Time.now() - 3600, stop: Time.now(), limit: 1000) #=&gt; # [{ &quot;name&quot;=&gt;&quot;RubyTL&quot;, ... }, { &quot;name&quot;=&gt;&quot;RubyTL&quot;, ... }]   Python の例：  now = datetime.now(timezone.utc) acts = get_timeline_activities(&quot;PythonTL&quot;, start=now - timedelta(hours=2), stop=now, limit=1000) #=&gt; # [{ &quot;name&quot;=&gt;&quot;PythonTL&quot;, ... }, { &quot;name&quot;=&gt;&quot;PythonTL&quot;, ... }]   ","version":"次へ","tagName":"h3"},{"title":"delete_timeline_activity​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#delete_timeline_activity","content":" 既存のタイムラインアクティビティを削除します。  Ruby / Python 構文：  delete_timeline_activity(name, start, uuid)   パラメータ\t説明name\tタイムラインの名前 start\tアクティビティの開始時間。Time / datetimeインスタンス。 uuid\tアクティビティのUUID  Ruby の例：  delete_timeline_activity(&quot;RubyTL&quot;, 1737132303, &quot;cdb661b4-a65b-44e7-95e2-5e1dba80c782&quot;)   Python の例：  delete_timeline_activity(&quot;PythonTL&quot;, 1737133108, &quot;cddbf034-ccdd-4c36-91c2-2653a39b06a5&quot;)   ","version":"次へ","tagName":"h3"},{"title":"メタデータ​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#メタデータ","content":" メタデータを使用すると、COSMOSに記録された通常のターゲット/パケットデータに独自のフィールドをマークできます。このメタデータは、他のCOSMOSツールを使用する際に検索したり、データをフィルタリングしたりするために使用できます。  ","version":"次へ","tagName":"h2"},{"title":"metadata_all​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#metadata_all","content":" 以前に設定されたすべてのメタデータを返します。  Ruby / Python 構文：  metadata_all()   パラメータ\t説明limit\t返すメタデータ項目の数。デフォルトは100です。  Ruby の例：  metadata_all(limit: 500)   Python の例：  metadata_all(limit='500')   ","version":"次へ","tagName":"h3"},{"title":"metadata_get​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#metadata_get","content":" 以前に設定されたメタデータを返します  Ruby / Python 構文：  metadata_get(start)   パラメータ\t説明start\t名前付きパラメータ、エポックからの整数秒としてメタデータを取得する時間  Ruby の例：  metadata_get(start: 500)   Python の例：  metadata_get(start='500')   ","version":"次へ","tagName":"h3"},{"title":"metadata_set​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#metadata_set","content":" 以前に設定されたメタデータを返します  Ruby / Python 構文：  metadata_set(&lt;Metadata&gt;, start, color)   パラメータ\t説明Metadata\tメタデータとして保存するキーと値のペアのハッシュまたは辞書。 start\t名前付きパラメータ、メタデータを保存する時間。デフォルトは現在です。 color\t名前付きパラメータ、カレンダーにメタデータを表示する色。デフォルトは #003784 です。  Ruby の例：  metadata_set({ 'key' =&gt; 'value' }) metadata_set({ 'key' =&gt; 'value' }, color: '#ff5252')   Python の例：  metadata_set({ 'key': 'value' }) metadata_set({ 'key': 'value' }, color='ff5252')   ","version":"次へ","tagName":"h3"},{"title":"metadata_update​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#metadata_update","content":" 以前に設定されたメタデータを更新します  Ruby / Python 構文：  metadata_update(&lt;Metadata&gt;, start, color)   パラメータ\t説明Metadata\tメタデータとして更新するキーと値のペアのハッシュまたは辞書。 start\t名前付きパラメータ、メタデータを更新する時間。デフォルトは最新のメタデータです。 color\t名前付きパラメータ、カレンダーにメタデータを表示する色。デフォルトは #003784 です。  Ruby の例：  metadata_update({ 'key' =&gt; 'value' })   Python の例：  metadata_update({ 'key': 'value' })   ","version":"次へ","tagName":"h3"},{"title":"metadata_input​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#metadata_input","content":" ユーザーに既存のメタデータ値を設定するか、新しい値を作成するように促します。  Ruby / Python の例：  metadata_input()   ","version":"次へ","tagName":"h3"},{"title":"設定​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#設定","content":" COSMOSには、通常、Admin Settingsタブを通じてアクセスされるいくつかの設定があります。これらのAPIを使用すると、同じ設定にプログラムでアクセスできます。  ","version":"次へ","tagName":"h2"},{"title":"list_settings​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#list_settings","content":" 現在のCOSMOS設定名をすべて返します。これらは他のAPIで使用する名前です。 Ruby の例：  puts list_settings() #=&gt; [&quot;pypi_url&quot;, &quot;rubygems_url&quot;, &quot;source_url&quot;, &quot;version&quot;]   Python の例：  print(list_settings()) #=&gt; ['pypi_url', 'rubygems_url', 'source_url', 'version']   ","version":"次へ","tagName":"h3"},{"title":"get_all_settings​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_all_settings","content":" 現在のCOSMOS設定とその値をすべて返します。  Ruby の例：  settings = get_all_settings() #=&gt; # { &quot;version&quot;=&gt;{&quot;name&quot;=&gt;&quot;version&quot;, &quot;data&quot;=&gt;&quot;5.11.4-beta0&quot;, &quot;updated_at&quot;=&gt;1698074299509456507}, # &quot;pypi_url&quot;=&gt;{&quot;name&quot;=&gt;&quot;pypi_url&quot;, &quot;data&quot;=&gt;&quot;https://pypi.org/simple&quot;, &quot;updated_at&quot;=&gt;1698026776574347007}, # &quot;rubygems_url&quot;=&gt;{&quot;name&quot;=&gt;&quot;rubygems_url&quot;, &quot;data&quot;=&gt;&quot;https://rubygems.org&quot;, &quot;updated_at&quot;=&gt;1698026776574105465}, # &quot;source_url&quot;=&gt;{&quot;name&quot;=&gt;&quot;source_url&quot;, &quot;data&quot;=&gt;&quot;https://github.com/OpenC3/cosmos&quot;, &quot;updated_at&quot;=&gt;1698026776573904132} }   Python の例：  settings = get_all_settings() #=&gt; # { 'version': {'name': 'version', 'data': '5.11.4-beta0', 'updated_at': 1698074299509456507}, # 'pypi_url': {'name': 'pypi_url', 'data': 'https://pypi.org/simple', 'updated_at': 1698026776574347007}, # 'rubygems_url': {'name': 'rubygems_url', 'data': 'https://rubygems.org', 'updated_at': 1698026776574105465}, # 'source_url': {'name': 'source_url', 'data': 'https://github.com/OpenC3/cosmos', 'updated_at': 1698026776573904132} }   ","version":"次へ","tagName":"h3"},{"title":"get_setting, get_settings​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#get_setting-get_settings","content":" 指定されたCOSMOS設定からデータを返します。設定が存在しない場合は、nil（Ruby）またはNone（Python）を返します。  Ruby / Python 構文：  get_setting(&lt;Setting Name&gt;) get_settings(&lt;Setting Name1&gt;, &lt;Setting Name2&gt;, ...)   パラメータ\t説明Setting Name\t返す設定の名前  Ruby の例：  setting = get_setting('version') #=&gt; &quot;5.11.4-beta0&quot; setting = get_settings('version', 'rubygems_url') #=&gt; [&quot;5.11.4-beta0&quot;, &quot;https://rubygems.org&quot;]   Python の例：  setting = get_setting('version') #=&gt; '5.11.4-beta0' setting = get_setting('version', 'rubygems_url') #=&gt; ['5.11.4-beta0', 'https://rubygems.org']   ","version":"次へ","tagName":"h3"},{"title":"set_setting​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#set_setting","content":" 指定された設定値を設定します。  管理者パスワードが必要 このAPIは外部からのみアクセス可能（Script Runner内ではない）で、管理者パスワードが必要です。  Ruby / Python 構文：  set_setting(&lt;Setting Name&gt;, &lt;Setting Value&gt;)   パラメータ\t説明Setting Name\t変更する設定の名前 Setting Value\t設定する値  Ruby の例：  set_setting('rubygems_url', 'https://mygemserver')   Python の例：  set_setting('pypi_url', 'https://mypypiserver')   ","version":"次へ","tagName":"h3"},{"title":"構成​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#構成","content":" 多くのCOSMOSツールには、構成をロードして保存する機能があります。これらのAPIを使用すると、構成をプログラムでロードして保存できます。  ","version":"次へ","tagName":"h2"},{"title":"config_tool_names​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#config_tool_names","content":" 他のAPIの最初のパラメータとして使用されるすべての構成ツール名をリストします。  Ruby の例：  names = config_tool_names() #=&gt; [&quot;telemetry_grapher&quot;, &quot;data_viewer&quot;]   Python の例：  names = config_tool_names() #=&gt; ['telemetry_grapher', 'data_viewer']   ","version":"次へ","tagName":"h3"},{"title":"list_configs​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#list_configs","content":" 指定されたツール名の下に保存されているすべての構成名をリストします。  Ruby / Python 構文：  list_configs(&lt;Tool Name&gt;)   パラメータ\t説明Tool Name\t構成名を取得するツールの名前  Ruby の例：  configs = list_configs('telemetry_grapher') #=&gt; ['adcs', 'temps']   Python の例：  configs = list_configs('telemetry_grapher') #=&gt; ['adcs', 'temps']   ","version":"次へ","tagName":"h3"},{"title":"load_config​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#load_config","content":" 特定のツール構成をロードします。  ツール構成 ツール構成は完全に文書化されておらず、リリース間で変更される可能性があります。load_configによって返される値のみを変更し、キーは変更しないでください。  Ruby / Python 構文：  load_config(&lt;Tool Name&gt;, &lt;Configuration Name&gt;)   パラメータ\t説明Tool Name\tツールの名前 Configuration Name\t構成の名前  Ruby / Python の例：  config = load_config('telemetry_grapher', 'adcs') #=&gt; # [ { # &quot;items&quot;: [ # { # &quot;targetName&quot;: &quot;INST&quot;, # &quot;packetName&quot;: &quot;ADCS&quot;, # &quot;itemName&quot;: &quot;CCSDSVER&quot;, # ...   ","version":"次へ","tagName":"h3"},{"title":"save_config​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#save_config","content":" 特定のツール構成を保存します。  Ruby / Python 構文：  save_config(&lt;Tool Name&gt;, &lt;Configuration Name&gt;, local_mode)   パラメータ\t説明Tool Name\tツールの名前 Configuration Name\t構成の名前 local_mode\t構成をローカルモードで保存するかどうか  Ruby / Python の例：  save_config('telemetry_grapher', 'adcs', config)   ","version":"次へ","tagName":"h3"},{"title":"delete_config​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#delete_config","content":" 特定のツール構成を削除します。 Ruby / Python 構文：  delete_config(&lt;Tool Name&gt;, &lt;Configuration Name&gt;, local_mode)   パラメータ\t説明Tool Name\tツールの名前 Configuration Name\t構成の名前 local_mode\t構成をローカルモードで削除するかどうか  Ruby / Python の例：  delete_config('telemetry_grapher', 'adcs')   ","version":"次へ","tagName":"h3"},{"title":"オフラインアクセス​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#オフラインアクセス","content":" COSMOS Enterpriseでスクリプトを実行するには、オフラインアクセストークンが必要です。これらのメソッドは、offline_access_tokenのクライアント側での作成、テスト、および設定をサポートします。  ","version":"次へ","tagName":"h2"},{"title":"initialize_offline_access​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#initialize_offline_access","content":" ユーザー用のオフラインアクセストークンを作成して設定します。注意：このメソッドは、script_run（Enterprise限定）のようなオフラインアクセストークンを必要とするAPIメソッドを実行する前に呼び出す必要があります。このメソッドは、最初にスクリプトを開始するために必要なため、ScriptRunnerの外部で呼び出す必要があります。  Ruby の例：  # 最初に環境変数を設定します。examples/external_script.rbを参照してください initialize_offline_access() script_run(&quot;INST/procedures/collect.rb&quot;)   Python の例：  # 最初に環境変数を設定します。examples/external_script.pyを参照してください initialize_offline_access() script_run(&quot;INST2/procedures/collect.py&quot;)   ","version":"次へ","tagName":"h3"},{"title":"offline_access_needed​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#offline_access_needed","content":" ユーザーがオフラインアクセストークンを生成する必要がある場合はtrueを返します。注意：これは、ユーザーがスクリプトを表示する権限を少なくとも持っている場合にのみtrueになります。それ以外の場合、ユーザーがscript_view権限を持っていなければ、常にfalseになります。  Ruby の例：  result = offline_access_needed() #=&gt; true   Python の例：  result = offline_access_needed() #=&gt; False   ","version":"次へ","tagName":"h3"},{"title":"set_offline_access​","type":1,"pageTitle":"スクリプティング API ガイド","url":"/ja/docs/guides/scripting-api#set_offline_access","content":" バックエンドでオフラインアクセストークンを設定します。注意：initialize_offline_access()によって呼び出されるため、このメソッドを直接呼び出す必要はおそらくありません。  Ruby / Python 構文：  set_offline_access(offline_access_token)   パラメータ\t説明offline_access_token\toffline_access openidスコープを含むKeycloakによって生成されたリフレッシュトークン  Ruby / Python の例：  set_offline_access(offline_access_token)  ","version":"次へ","tagName":"h3"}],"options":{"id":"default"}}