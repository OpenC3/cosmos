---
sidebar_position: 7
title: プロトコル
description: 作成方法を含むCOSMOS組み込みプロトコル
sidebar_custom_props:
  myEmoji: 💡
---

プロトコルは[インターフェース](interfaces)の代わりにデータを処理します。書き込まれるデータ、読み取られるデータ、またはその両方を変更することができます。プロトコルはパケットをリアルタイムではなく保存済みとしてマークすることもでき、これによりCOSMOSはパケットデータで現在の値テーブルを更新しません。プロトコルは階層化することができ、順序通りに処理されます。例えば、より高レベルのバッファ長プロトコルを処理する前に最初に削除する必要がある低レベルの暗号化層がある場合などです。

:::info プロトコル実行順序
読み取りプロトコルは指定された順序で実行されます（最初に指定されたものが最初に実行されます）。書き込みプロトコルは逆順で実行されます（最後に指定されたものが最初に実行されます）。
:::

プロトコルは一般的に、パケットを区切るロジックを定義し、インターフェースとの間でデータの読み書きを操作するために使用されます。COSMOSには、TCP/IPクライアント、TCP/IPサーバー、UDPクライアント/サーバー、およびシリアル接続のインターフェースが含まれています。ユースケースの99％では、これらのインターフェースはこれらの種類の接続からの読み書きの低レベルの詳細を普遍的に処理するため、変更を必要としません。すべての独自の動作は、現在プロトコルで定義する必要があります。

最低限、バイトストリームベースのインターフェースにはパケットを区切るためのプロトコルが必要です。TCP/IPとシリアルは、バイトストリームベースのインターフェースの例です。バイトストリームは単純なバイトのストリームであり、そのためストリーム内のパケットの開始と終了を知る方法が必要です。

TCP/IPはフレンドリーなバイトストリームです。非常に貧弱に書かれたシステムを扱っていない限り、TCP/IP接続で受信された最初のバイトは常にパケットの開始になります。また、TCP/IPは信頼性の高い接続であり、すべてのデータが正しい順序で受信され、データが失われず、データが破損しないことを保証します（TCP/IPはCRC32で保護されており、認識されないデータ破損を避けるのに非常に効果的です）。

シリアルは、はるかに扱いにくいバイトストリームです。シリアル接続では、シリアルポートを開いてデータの受信を開始すると、メッセージの途中から受信する可能性が非常に高いです（この問題は、コマンドに応答してのみシリアルポートに書き込むシステムとインターフェースする場合にのみ回避されます）。このため、同期パターンはシリアルインターフェースに非常に有益です。さらに、シリアルインターフェースは、認識されないデータ破損から保護するためにいくつかの方法（チェックサム、CRCなど）を使用することがあります。

UDPは本質的にパケットベースの接続です。UDPソケットから読み取ると、常に完全なパケットが返されます。最良のUDPベースのプロトコルはこの事実を活用しています。一部の実装ではUDPをバイトストリームのように動作させようとしますが、これはプロトコルの誤用であり、データを失う可能性が非常に高く、回復する方法がありません。

プロトコルがインターフェースとアクセサーにどのように適合するかについての詳細情報は、[標準なしの相互運用性](https://www.openc3.com/news/interoperability-without-standards)を参照してください。

## パケット区切りプロトコル

COSMOSは以下のパケット区切りプロトコルを提供しています：COBS、SLIP、Burst、Fixed、Length、Template（非推奨）、TerminatedおよびPreidentified。これらの各プロトコルの主な目的は、バイトストリームからパケットを分離することです。

COSMOS Enterpriseは以下のパケット区切りプロトコルを提供しています：CCSDS CLTU（BCHエンコード付き）、CCSDS TCTF（ランダマイザー付き）、CCSDS TMTF（ランダマイザー付き）、およびGEMS。

すべてのプロトコルは「Allow Empty Data」と呼ばれる最終パラメータを取ることに注意してください。これは、プロトコルが空の文字列を後続のプロトコルに渡すことを許可するかどうかを示します（:STOPを返す代わりに）。true、false、またはnilが可能で、nilはプロトコルがチェーンの最後のプロトコルでない限りtrueとして解釈されます。プロトコルのエンドユーザーはほとんどの場合、このパラメータを省略します。詳細については、[カスタムプロトコル](protocols.md#カスタムプロトコル)のドキュメントを参照してください。

PROTOCOLキーワードの後の最初のパラメータは、プロトコルの適用方法を示します：READ、WRITE、またはREAD_WRITE。Readは入力パケット（テレメトリ）にプロトコルを適用し、writeは出力パケット（コマンド）に適用します。次のパラメータはプロトコルのファイル名またはクラス名です。その他のパラメータはプロトコル固有のものです。

### COBSプロトコル

Consistent Overhead Byte Stuffing（COBS）プロトコルは、パケットの内容に関係なく、効率的で信頼性が高く、明確なパケットフレーミングを実現するデータバイトをエンコードするアルゴリズムです。これにより、受信アプリケーションが不正な形式のパケットから回復することが容易になります。パケットの区切り文字（パケット間の境界を示す特別な値）として機能するゼロバイト値を使用します。このアルゴリズムは、各ゼロデータバイトを非ゼロの値で置き換えるため、パケット内にゼロデータバイトが現れず、パケット境界として誤解釈されることがありません（詳細は https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing を参照）。

### SLIPプロトコル

Serial Line IP（SLIP）プロトコルは、シリアル回線上でIPパケットをフレーム化する文字シーケンスを定義します。ENDとESCという2つの特殊文字を定義します。ENDは0xC0で、ESCは0xDBです。パケットを送信するために、SLIPホストは単にパケット内のデータの送信を開始します。データバイトがEND文字と同じコードである場合、代わりにESCと0xDCの2バイトシーケンスが送信されます。データバイトがESC文字と同じである場合、代わりにESCと0xDDの2バイトシーケンスが送信されます。パケット内の最後のバイトが送信されると、END文字が送信されます（詳細は https://datatracker.ietf.org/doc/html/rfc1055 を参照）。

| パラメータ           | 説明                                       | 必須 | デフォルト          |
| --------------------- | ---------------------------------------------- | -------- | ------------------ |
| Start Char            | フレームの先頭に配置する文字                | いいえ    | nil（文字なし）    |
| Read Strip Characters | 読み取りからstart_charとend_charを削除する | いいえ    | true               |
| Read Enable Escaping  | 読み取り時に文字エスケープを有効にするかどうか | いいえ    | true               |
| Write Enable Escaping | 書き込み時に文字エスケープを有効にするかどうか | いいえ    | true               |
| End Char              | フレームの末尾に配置する文字              | いいえ    | 0xC0               |
| Esc Char              | エスケープ文字                           | いいえ    | 0xDB               |
| Escape End Char       | End文字をエスケープするための文字         | いいえ    | 0xDC               |
| Escape Esc Char       | Esc文字をエスケープするための文字         | いいえ    | 0xDD               |

### バーストプロトコル

バーストプロトコルは、データをCOSMOSパケットとして返す前に、インターフェースからできるだけ多くのデータを読み取ります（読み取られたデータの各バーストに対してパケットを返します）。このプロトコルは時間で区切られた定期的なデータバーストに依存しているため、非常に堅牢ではありません。ただし、必要に応じて再同期を可能にする同期パターンを利用できます。また、同期パターンを削除するために、受信データからバイトを破棄することもできます。最後に、インターフェースから書き出されるデータに同期パターンを追加することもできます。

| パラメータ           | 説明                                                                                                                                         | 必須 | デフォルト          |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------ |
| Discard Leading Bytes | 読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンから始まるバイトに適用されることに注意してください。 | いいえ    | 0（バイトを破棄しない） |
| Sync Pattern          | 生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます     | いいえ    | nil（同期パターンなし） |
| Fill Fields           | 送信パケットに同期パターンを入力するかどうか                                                                                                | いいえ    | false                   |

### 固定プロトコル

固定プロトコルは、インターフェースを使用して定義されたすべてのパケットを適切に識別するために必要な、事前に設定された最小量のデータを読み取ります。その後、パケットを識別し、パケットを作成するために必要なだけのデータをインターフェースから読み取り、それを返します。このプロトコルは、インターフェース上のすべてのパケットが固定長であることに依存しています。例えば、インターフェースを使用するすべてのパケットは固定サイズであり、32ビットの同期パターンに続いて16ビットのIDを含む単純なヘッダーが含まれています。固定プロトコルは、最小読み取りサイズが6バイトであるこのケースをエレガントに処理します。固定プロトコルは、バーストプロトコルと同様に、同期パターン、先頭バイトの破棄、同期パターンの入力もサポートしています。

| パラメータ           | 説明                                                                                                                                          | 必須 | デフォルト              |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- | -------- | -------------------------- |
| Minimum ID Size       | パケットを識別するために必要な最小バイト数。すべてのパケット定義は、この指定されたバイト数内でID_ITEMを宣言する必要があります。             | はい     |                          |
| Discard Leading Bytes | 読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンから始まるバイトに適用されることに注意してください。  | いいえ    | 0（バイトを破棄しない）   |
| Sync Pattern          | 生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます。     | いいえ    | nil（同期パターンなし）   |
| Telemetry             | データがテレメトリかどうか                                                                                                                  | いいえ    | true（falseはコマンドを意味） |
| Fill Fields           | 送信パケットに同期パターンを入力するかどうか                                                                                               | いいえ    | false                     |
| Unknown Raise         | 不明なパケットに対して例外を発生させるかどうか                                                                                             | いいえ    | false                     |

### 長さプロトコル

長さプロトコルは、インターフェースを使用する定義されたパケット内の固定位置にある長さフィールドに依存します。十分なデータを読み取って長さフィールドを取得し、それをデコードし、パケットの残りの長さを読み取ります。例えば、インターフェースを使用するすべてのパケットには、長さフィールドを持つCCSDSヘッダーが含まれています。長さプロトコルは、長さフィールドや、CCSDSが使用する長さオフセットも処理するように設定できます。長さプロトコルは、バーストプロトコルと同様に、同期パターン、先頭バイトの破棄、長さと同期パターンの入力もサポートしています。

| パラメータ                  | 説明                                                                                                                                                                                                                                                                                                                     | 必須 | デフォルト             |
| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------ |
| Length Bit Offset            | パケットの先頭から長さフィールドまでのビットオフセット。このインターフェースを使用するすべてのパケットは、長さフィールドが同じ場所で同じサイズになるような同じ構造を持っている必要があります。この値に同期パターンの長さを考慮することを忘れないでください（存在する場合）。                              | いいえ    | 0ビット                 |
| Length Bit Size              | 長さフィールドのビットサイズ                                                                                                                                                                                                                                                                                           | いいえ    | 16ビット                |
| Length Value Offset          | 長さフィールド値に適用するオフセット。長さフィールドの実際の値にこのオフセットを加えると、パケットのすべてのデータ（長さフィールド自体、同期パターンなどを含む）を読み取るために必要な正確なバイト数と等しくなる必要があります。例えば、長さフィールドがパケット長から1を引いた値を示す場合、この値は1になります。この値に同期パターンの長さを考慮することを忘れないでください（存在する場合）。 | いいえ    | 0                       |
| Bytes per Count              | 各長さフィールドの「カウント」あたりのバイト数。これは、長さフィールドの単位がバイト以外の場合（例えば、長さフィールドのカウントがワード単位の場合）に使用されます。                                                                                                                                          | いいえ    | 1バイト                 |
| Length Endianness            | 長さフィールドのエンディアン。「BIG_ENDIAN」または「LITTLE_ENDIAN」のいずれかでなければなりません。                                                                                                                                                                                                                   | いいえ    | 'BIG_ENDIAN'            |
| Discard Leading Bytes        | 読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンを含むバイトに適用されることに注意してください。破棄は最後のステップの1つであるため、上記のサイズとオフセットは破棄前のすべてのデータを考慮する必要があります。                                         | いいえ    | 0（バイトを破棄しない） |
| Sync Pattern                 | 生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます。                                                                                                                                                                 | いいえ    | nil（同期パターンなし） |
| Max Length                   | 長さフィールドで許可される最大値                                                                                                                                                                                                                                                                                     | いいえ    | nil（最大長なし）       |
| Fill Length and Sync Pattern | このフラグをtrueに設定すると、送信パケットに長さフィールドと同期パターン（存在する場合）が自動的に入力されます。                                                                                                                                                                                                   | いいえ    | false                   |

長さプロトコルの最も混乱する側面は、Length Value Offsetの計算です。これは、よく使用されるCCSDS宇宙パケットプロトコルで特に当てはまります。これを説明する最良の方法は例を使用することです。同期パターン0x1ACFFC1Dが前に付いたCCSDS宇宙パケットがあるとします。これは次のようになります：

| 同期（4バイト） | ヘッダー（4バイト） | 長さ（2バイト） | データ（4バイト） |
| -------------- | ---------------- | -------------- | -------------- |
| 0x1ACFFC1D     | 0x0001CADB       | 0x0003         | 0xDEADBEEF     |

この場合、パケットの合計長は14バイトです：**4 + 4 + 2 + 4 = 14**。データが4バイトの場合、CCSDSでは長さフィールドは（データ長 - 1）として計算されるため、長さフィールドは3になります。では、Length Value Offsetをどのように計算すればよいでしょうか？COSMOSはパケット内のすべてのバイト（同期パターンを含む）を読み取るため、合計長は14バイトです。長さフィールドは3なので、Length Value Offset（長さフィールド値に適用するオフセット）は11であるべきです（**3 + 11 = 14**）。

### 終端プロトコル

終端プロトコルは、各パケットの末尾にある終端文字を使用してパケットを区切ります。終端文字が見つかるまで継続的にデータを読み取り、その時点でパケットデータを返します。例えば、インターフェースを使用するすべてのパケットの後に0xABCDが続きます。このデータは、保持される各パケットの一部であるか、または終端プロトコルだけが知っていて単に捨てられるものであるかのいずれかです。

| パラメータ                  | 説明                                                                                                                                         | 必須 | デフォルト              |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------------------ |
| Write Termination Characters | コマンドパケットを書き込んだ後に書き込むデータ。0xABCDなどの16進文字列として指定します。                                                  | はい     |                        |
| Read Termination Characters  | テレメトリパケットの終わりを示す文字。0xABCDなどの16進文字列として指定します。                                                            | はい     |                        |
| Strip Read Termination       | テレメトリパケットを返す前に読み取り終端文字を削除するかどうか                                                                            | いいえ    | true                    |
| Discard Leading Bytes        | 読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンを含むバイトに適用されることに注意してください。 | いいえ    | 0（バイトを破棄しない） |
| Sync Pattern                 | 生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます。     | いいえ    | nil（同期パターンなし） |
| Fill Fields                  | 送信パケットに同期パターンを入力するかどうか                                                                                               | いいえ    | false                   |

### GEMSプロトコル（Enterprise）

GEMSプロトコルは、地上機器監視サービスプロトコルを実装しています。これは、「|END」を使用してパケットを区切るTerminatedProtocolと一緒に追加されます。GEMSインターフェースは現在Rubyでのみ実装されています。

GEMSプロトコルはパラメータを取りませんが、TerminatedProtocolとCmdResponseProtocolの後にインターフェースに追加する必要があります。

plugin.txt Rubyの例：

```ruby
INTERFACE GEMS_INT tcpip_client_interface.rb openc3-operator 8080 8080 10.0 nil nil
  # TerminatedProtocol 0x7C454E44 0x7C454E44 false 0       0x7C47454D53 false ... の意味：
  #                    wtc        rtc        strip discard sync         fill
  # wtc = 書き込み終端文字、gemsプロトコルの終わり：0x7C454E44 == '|END'
  #       rtc = 読み取り終端文字、gemsプロトコルの終わり：0x7C454E44 == '|END'
  #       strip = 読み取り終端を削除（false）
  #       discard = 0バイト
  #       sync pattern = GEMSプロトコルの始まり：0x7C47454D53 == '|GEMS'
  #       fill = 同期パターンを入力するかどうか（cmd/tlm定義でfillを指定するのでfalse）
  PROTOCOL READ TerminatedProtocol 0x7C454E44 0x7C454E44 false 0 0x7C47454D53 false
  # CmdResponseProtocol 5.0 0.2 true の意味：
  #   5秒応答タイムアウト、0.2秒応答ポーリング、
  #   そしてプロトコルエラーが発生したときに例外を発生させるためのtrue
  PROTOCOL READ_WRITE CmdResponseProtocol 5.0 0.2 true
  PROTOCOL READ_WRITE GemsProtocol
```

完全な例については、COSMOS Enterprise Pluginsの[openc3-cosmos-gems-interface](https://github.com/OpenC3/cosmos-enterprise-plugins/tree/main/openc3-cosmos-gems-interface)を参照してください。

### CCSDS CLTUプロトコル（Enterprise）

CCSDS CLTUプロトコルは、コマンドストリーム用のCLTU（通信リンク転送ユニット）を処理します。これは送信メッセージをBCHエンコーディングでエンコードし、データにヘッダーとフッターを適用します。

| パラメータ | 説明                          | 必須 | デフォルト          |
| ---------- | ----------------------------- | ---- | ------------------- |
| Header     | BCHエンコードデータの前のヘッダー | いいえ | 0xEB90              |
| Footer     | BCHエンコードデータの後のフッター | いいえ | 0xC5C5C5C5C5C5C579  |
| Fill Byte  | BCHエンコーディングのフィルバイト | いいえ | 0x55                |

完全な例については、COSMOS Enterprise Pluginsの[openc3-cosmos-ccsds-protocols](https://github.com/OpenC3/cosmos-enterprise-plugins/tree/main/openc3-cosmos-ccsds-protocols)を参照してください。

### CCSDS TCTFプロトコル（Enterprise）

CCSDS TCTFプロトコルは、コマンドストリーム用のテレコマンド転送フレームを処理します。

| パラメータ     | 説明                                                             | 必須 | デフォルト |
| ------------- | --------------------------------------------------------------- | ---- | ---------- |
| Randomization | 転送フレームをエンコードし、ランダム化するかどうか                    | いいえ | true       |
| Error Control | フレームエラー制御フィールドを使用し、16ビットCRCを適用するかどうか    | いいえ | false      |
| Bypass        | バイパスビット（0はType-A、1はType-B（フレーム受け入れチェックをバイパス）） | いいえ | 1          |
| SCID          | 宇宙機識別子（10ビット）                                          | いいえ | 0          |
| VCID          | 仮想チャネル識別子（6ビット）                                     | いいえ | 0          |

完全な例については、COSMOS Enterprise Pluginsの[openc3-cosmos-ccsds-protocols](https://github.com/OpenC3/cosmos-enterprise-plugins/tree/main/openc3-cosmos-ccsds-protocols)を参照してください。

### CCSDS TMTFプロトコル（Enterprise）

CCSDS TMTFプロトコルは、テレメトリストリーム用のテレメトリ転送フレームを処理します。VCID、MC_FRM_CNT、VC_FRM_CNTをextraに追加し、これらはDecomデータに含まれます。

| パラメータ            | 説明                                                                                                                                                      | 必須 | デフォルト             |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- | ---------------------- |
| SCID                  | 宇宙機識別子（10ビット）                                                                                                                                  | はい |                       |
| Frame Length          | フレーム長                                                                                                                                               | いいえ | 2048                   |
| Randomization         | 転送フレームがエンコードされ、ランダム化されたかどうか                                                                                                    | いいえ | true                   |
| Discard Leading Bytes | 読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンを含むバイトに適用されることに注意してください。           | いいえ | 0（バイトを破棄しない） |
| Sync Pattern          | 生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます。                | いいえ | 0x1ACFFC1D             |
| Fill Fields           | 送信パケットに同期パターンを入力するかどうか                                                                                                              | いいえ | true                   |

完全な例については、COSMOS Enterprise Pluginsの[openc3-cosmos-ccsds-protocols](https://github.com/OpenC3/cosmos-enterprise-plugins/tree/main/openc3-cosmos-ccsds-protocols)を参照してください。

### テンプレートプロトコル（非推奨）

このプロトコルは、COSMOS生ログにおいて元のSCPIメッセージをキャプチャできないため、現在は非推奨です。代わりにTemplateAccessorとCmdResponseProtocolを使用してください。

テンプレートプロトコルは、SCPI（プログラム可能な機器用標準コマンド）などのテキストベースのコマンドおよび応答タイプのインターフェース用に設計されている点を除いて、終端プロトコルと非常によく似ています。各パケットが行と呼ばれる（通常は各行にテキスト行が含まれるため）ことを除いて、終端プロトコルと同じ方法でパケットを区切ります。送信パケットの場合、パケット内にCMD_TEMPLATEフィールドが存在することが期待されます。このフィールドには、HTMLタグスタイルの括弧`"<EXAMPLE>"`内で区切られた、埋め込むべき項目を含むテンプレート文字列が含まれています。テンプレートプロトコルはパケット内から名前付き項目を読み取り、CMD_TEMPLATEに入力します。このように入力された文字列は、元々渡されたパケットではなく送信されます。同様に、応答が期待される場合、送信パケットにはRSP_TEMPLATEおよびRSP_PACKETフィールドを含める必要があります。RSP_TEMPLATEは応答文字列からデータを抽出し、対応するRSP_PACKETを構築するために使用されます。使用例については、COSMOSデモ設定内のTEMPLATEターゲットを参照してください。

| パラメータ                  | 説明                                                                                                                                                | 必須 | デフォルト               |
| ---------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- | ---- | ------------------------ |
| Write Termination Characters | コマンドパケットを書き込んだ後に書き込むデータ。0xABCDなどの16進文字列として指定します。                                                          | はい |                        |
| Read Termination Characters  | テレメトリパケットの終わりを示す文字。0xABCDなどの16進文字列として指定します。                                                                     | はい |                        |
| Ignore Lines                 | 無視する応答行の数（完全に削除）                                                                                                                   | いいえ | 0行                     |
| Initial Read Delay           | 接続後の初期遅延時間。この後、インターフェースは空になるまで読み取られ、データは破棄されます。接続ヘッダーと初期プロンプトを破棄するのに役立ちます。 | いいえ | nil（初期読み取りなし）  |
| Response Lines               | 期待される応答を構成する行数                                                                                                                      | いいえ | 1行                     |
| Strip Read Termination       | テレメトリパケットを返す前に読み取り終端文字を削除するかどうか                                                                                     | いいえ | true                    |
| Discard Leading Bytes        | 読み取り後にバイナリデータから破棄するバイト数。同期パターンが使用されている場合、これは同期パターンを含むバイトに適用されることに注意してください。    | いいえ | 0（バイトを破棄しない）  |
| Sync Pattern                 | 生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンを含むすべての検出データが返されます。         | いいえ | nil（同期パターンなし）  |
| Fill Fields                  | 送信パケットに同期パターンを入力するかどうか                                                                                                       | いいえ | false                   |
| Response Timeout             | 応答がタイムアウトするまでの待機秒数                                                                                                              | いいえ | 5.0                     |
| Response Polling Period      | 応答のポーリング間の待機秒数                                                                                                                      | いいえ | 0.02                    |
| Raise Exceptions             | タイムアウトや予期しない応答などのエラーが発生した場合に例外を発生させるかどうか                                                                   | いいえ | false                   |

### 事前識別プロトコル（内部）

事前識別プロトコルは、カスタムCOSMOSヘッダーを使用してパケットを区切ります。この内部プロトコルは、ツールが接続してパケットストリーム全体を受信できるようにするために作成されました。また、複数のCOSMOSインスタンスを連結するためにも使用できますが、新しいウェブネイティブ実装ではほとんど必要ありません。

| パラメータ    | 説明                                                                                                                                                      | 必須 | デフォルト             |
| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- | ---------------------- |
| Sync Pattern  | 生データ内で検索されるバイトパターンを表す16進文字列。このパターンはパケット区切り文字を表し、同期パターンの後にあるすべてのデータが返されます。同期パターン自体は破棄されます。 | いいえ | nil（同期パターンなし） |
| Max Length    | 長さフィールドで許可される最大値                                                                                                                         | いいえ | nil（最大長なし）     |
| Mode          | サポートする事前識別プロトコルのバージョン（2または4）                                                                                                   | いいえ | 4                     |

## ヘルパープロトコル

COSMOSは以下のヘルパープロトコルを提供しています：CmdResponse、Crc、およびIgnore。これらのプロトコルはインターフェースにヘルパー機能を提供します。

### CmdResponseプロトコル

CmdResponseプロトコルは、定義された応答パケットを持つコマンドの応答を待ちます。

| パラメータ               | 説明                                                                           | 必須 | デフォルト |
| ----------------------- | ------------------------------------------------------------------------------ | ---- | --------- |
| Response Timeout        | 応答を待つ際にタイムアウトするまでの秒数                                       | いいえ | 5        |
| Response Polling Period | 応答のポーリング間の待機秒数                                                   | いいえ | 0.02     |
| Raise Exceptions        | 予期しない応答や応答タイムアウトなどのプロトコルでエラーが発生した場合に例外を発生させるかどうか | いいえ | false    |

#### パケット定義

CmdResponseProtocolは、コマンド定義内の[RESPONSE](../configuration/command#response)キーワードを使用して、指定されたコマンドが送信されたときに期待されるテレメトリパケットを決定します。

```
COMMAND SCPI_PS GET_STATUS BIG_ENDIAN "Gets status"
  ACCESSOR TemplateAccessor
  TEMPLATE ":MEAS:VOLT? (@1:2)"
  RESPONSE SCPI_PS STATUS
```

応答パケット（STATUS）は、応答データを含むように定義する必要があります。

```
TELEMETRY SCPI_PS STATUS BIG_ENDIAN "Status"
  ACCESSOR TemplateAccessor
  TEMPLATE "<MEAS_VOLTAGE_1>,<MEAS_VOLTAGE_2>"
  APPEND_ITEM MEAS_VOLTAGE_1 32 FLOAT "Voltage Reading for Channel 1"
    UNITS VOLTS V
    FORMAT_STRING %0.3f
  APPEND_ITEM MEAS_VOLTAGE_2 32 FLOAT "Voltage Reading for Channel 2"
    UNITS VOLTS V
    FORMAT_STRING %0.3f
```

完全な例については、COSMOS Enterprise Pluginsの[openc3-cosmos-scpi-power-supply](https://github.com/OpenC3/cosmos-enterprise-plugins/tree/main/openc3-cosmos-scpi-power-supply)を参照してください。

### CRCプロトコル

CRCプロトコルは、送信コマンドにCRCを追加し、受信テレメトリパケットのCRCを検証できます。

| パラメータ      | 説明                                                                                                           | 必須 | デフォルト                                                                                     |
| -------------- | -------------------------------------------------------------------------------------------------------------- | ---- | --------------------------------------------------------------------------------------------- |
| Write Item Name | 送信パケットの計算済みCRC値で埋めるアイテム（nil = 埋めない）                                                   | いいえ | nil                                                                                            |
| Strip CRC       | 受信パケットからCRCを削除するかどうか                                                                          | いいえ | false                                                                                         |
| Bad Strategy    | 受信パケットのCRCエラーを処理する方法。ERROR = エラーのみをログに記録、DISCONNECT = インターフェースを切断     | いいえ | "ERROR"                                                                                       |
| Bit Offset      | データ内のCRCのビットオフセット。負の値はパケットの末尾からの距離を示します                                    | いいえ | -32                                                                                           |
| Bit Size        | CRCのビットサイズ - 16、32、または64でなければなりません                                                      | いいえ | 32                                                                                            |
| Endianness      | CRCのエンディアン（BIG_ENDIAN/LITTLE_ENDIAN）                                                                 | いいえ | "BIG_ENDIAN"                                                                                  |
| Poly            | CRCを計算する際に使用する多項式（整数として表現）                                                             | いいえ | nil（デフォルトの多項式を使用 - 16ビット=0x1021、32ビット=0x04C11DB7、64ビット=0x42F0E1EBA9EA3693） |
| Seed            | 計算を開始するシード値                                                                                        | いいえ | nil（デフォルトのシードを使用 - 16ビット=0xFFFF、32ビット=0xFFFFFFFF、64ビット=0xFFFFFFFFFFFFFFFF）   |
| Xor             | CRC結果を0xFFFFとXOR演算するかどうか                                                                          | いいえ | nil（デフォルト値を使用 - 16ビット=false、32ビット=true、64ビット=true）                          |
| Reflect         | CRCを計算する前にデータの各バイトのビットを反転するかどうか                                                   | いいえ | nil（デフォルト値を使用 - 16ビット=false、32ビット=true、64ビット=true）                          |

### パケット無視プロトコル

パケット無視プロトコルは、COSMOSによって送信された特定のコマンドパケットまたは受信テレメトリパケットを破棄します。

| パラメータ   | 説明                           | 必須 | デフォルト |
| ----------- | ------------------------------ | ---- | --------- |
| Target Name | 無視するパケットのターゲット名 | はい  | nil       |
| Packet Name | 無視するパケットのパケット名   | はい  | nil       |

## カスタムプロトコル

カスタムプロトコルの作成は簡単で、COSMOSインターフェースをカスタマイズするためのデフォルトの解決策であるべきです（新しいインターフェースクラスを作成するのではなく）。ただし、カスタムインターフェースを作成することは、ターゲットに対して常に固定されている値にパラメータをデフォルト設定し、必要なプロトコルを含めるのにも役立ちます。基本COSMOSインターフェースは多くのパラメータを取り、エンドユーザーにとって混乱する可能性があります。したがって、これらの値をハードコードし、利用可能なパラメータをホスト名や接続ポートなどに絞り込むためだけにカスタムインターフェースを作成することをお勧めします。

すべてのカスタムプロトコルは、Protocolクラス[openc3/interfaces/protocols/protocol.rb](https://github.com/OpenC3/cosmos/blob/main/openc3/lib/openc3/interfaces/protocols/protocol.rb)（Ruby）および[openc3/interfaces/protocols/protocol.py](https://github.com/OpenC3/cosmos/blob/main/openc3/python/openc3/interfaces/protocols/protocol.py)（Python）から派生する必要があります。このクラスは、独自のプロトコルを作成するための9つのメソッドを定義しています。各メソッドの基本クラス実装と、それらのメソッドを独自のプロトコルでどのようにオーバーライドして使用するかについての説明が以下に含まれています。

:::info Ruby プロトコルAPI
プロトコルはCOSMOSインターフェースの一部であるため、`require 'openc3/script'`を使用すべきではありません。代わりに、[System](https://github.com/OpenC3/cosmos/blob/main/openc3/lib/openc3/system/system.rb)、[Packet](https://github.com/OpenC3/cosmos/blob/main/openc3/lib/openc3/packets/packet.rb)、[Bucket](https://github.com/OpenC3/cosmos/blob/main/openc3/lib/openc3/utilities/bucket.rb)、[BinaryAccessor](https://github.com/OpenC3/cosmos/blob/main/openc3/lib/openc3/accessors/binary_accessor.rb)などのCOSMOSライブラリコードを直接使用する必要があります。不明な点がある場合は、既存のCOSMOSの[プロトコル](https://github.com/OpenC3/cosmos/tree/main/openc3/lib/openc3/interfaces/protocols)クラスを参照してください。
:::

:::info Python プロトコルAPI
プロトコルはCOSMOSインターフェースの一部であるため、`from openc3.script import *`を使用すべきではありません。代わりに、[System](https://github.com/OpenC3/cosmos/blob/main/openc3/python/openc3/system/system.py)、[Packet](https://github.com/OpenC3/cosmos/blob/main/openc3/python/openc3/packets/packet.py)、[Bucket](https://github.com/OpenC3/cosmos/blob/main/openc3/python/openc3/utilities/bucket.py)、[BinaryAccessor](https://github.com/OpenC3/cosmos/blob/main/openc3/python/openc3/accessors/binary_accessor.py)などのCOSMOSライブラリコードを直接使用する必要があります。不明な点がある場合は、既存のCOSMOSの[プロトコル](https://github.com/OpenC3/cosmos/tree/main/openc3/python/openc3/interfaces/protocols)クラスを参照してください。
:::

プロトコルがどのように機能するかを本当に理解するためには、まず基本インターフェースクラスの読み取りと書き込みのメソッド内のロジックを理解する必要があります。

まず、readメソッドについて説明しましょう。

:::info Rubyのシンボル、Pythonの文字列
以下の説明では、大文字の単語はRubyではシンボル、Pythonでは文字列を表します。したがって、STOPへの参照はRubyでは:STOP、Pythonでは"STOP"を意味します。
:::

![Interface Read Logic](/img/interface_read_logic.png)

readが_毎回_呼び出されるたびに、空の文字列""が最初に、インターフェースの`read_interface()`メソッドを使用して新しい生データの読み取りが試みられる_前に_、各読み取りプロトコルの`read_data()`メソッドに渡されます。これは、複数のパケット分のデータをキャッシュしているプロトコルに対して、インターフェースから新しいデータが読み取られる前にそれらのキャッシュされたパケットを出力するよう指示する信号です。通常、データはキャッシュされず、プロトコルの`read_data()`メソッドの1つが空の文字列に応答してSTOPを返し、パケットを生成するためにはさらにデータが必要であることを示します。各プロトコルの`read_data()`メソッドは、次の3つのいずれかを返すことができます：追加のプロトコルに渡されるか、パケットに変換されるデータ、プロトコルを続行するためにインターフェースからさらにデータが必要であることを意味するSTOP、またはインターフェースの切断（およびデフォルトでは再接続を試みる）が必要な何かが起こったことを意味するDISCONNECT。各プロトコルの`read_data()`メソッドには、最終的にパケットに変換されるデータが渡され、おそらく修正されたデータのセットが返されます。データがすべてのプロトコルの`read_data()`メソッドを通過すると、インターフェースのconvert_data_to_packet()メソッドを使用してCOSMOSパケットに変換されます。このパケットは同様の方法で各読み取りプロトコルのread_packet()メソッドを通過します。このメソッドは基本的に同じ戻り値の可能性を持っています：パケット（`read_data()`のデータではなく）、STOP、またはDISCONNECT。パケットがすべてのread_packet()メソッドを通過すると、インターフェースのパケット読み取りカウンターがインクリメントされ、パケットがインターフェースに返されます。

![Interface Write Logic](/img/interface_write_logic.png)

インターフェースのwrite()メソッドは、readと非常に似た働きをします。（デフォルトでは、書き込みプロトコルは読み取りプロトコルの逆順で実行されることに注意してください。これは、読み取り時にはデータの層を取り除き、書き込み時には逆順で層を追加するのが一般的なため理にかなっています。）

まず、パケット書き込みカウンターがインクリメントされます。次に、各書き込みプロトコルは、そのwrite_packet()メソッドが呼び出されることによってパケットを変更する機会が与えられます。このメソッドは、潜在的に修正されたパケット、STOP、またはDISCONNECTのいずれかを返すことができます。書き込みプロトコルがSTOPを返す場合、データはインターフェースに書き込まれず、最終的なパケットを出力する前にさらにパケットが必要であると想定されます。DISCONNECTはインターフェースを切断します。パケットがすべての書き込みプロトコルのwrite_packet()メソッドを通過すると、インターフェースのconvert_packet_to_data()メソッドを使用してバイナリデータに変換されます。次に、各書き込みプロトコルのwrite_data()メソッドが呼び出され、低レベルのデータを変更する機会が与えられます。COSMOSパケットではなくRuby文字列のデータが返される点を除いて、同じ戻りオプションが利用可能です。データがすべてのwrite_data()メソッドを通過すると、write_interface()メソッドを使用してインターフェースに書き込まれます。その後、各プロトコルのpost_write_interface()メソッドが、最終的に変更されたパケットと、インターフェースに実際に書き込まれたデータの両方で呼び出されます。このメソッドは、メッセージを書き出した後の応答を待つなどのフォローアップを可能にします。

## メソッドの説明

### initialize または **init**

これはカスタムプロトコルのコンストラクタです。基本プロトコルクラスを初期化するために、常にsuper(allow_empty_data)を呼び出す必要があります。

基本クラスのRuby実装:

```ruby
# @param allow_empty_data [true/false] 空データでSTOPを返すべきかどうか
def initialize(allow_empty_data = false)
  @interface = nil
  @allow_empty_data = ConfigParser.handle_true_false(allow_empty_data)
  reset()
end
```

基本クラスのPython実装:

```python
def __init__(self, allow_empty_data=None):
    self.interface = None
    self.allow_empty_data = ConfigParser.handle_true_false_none(allow_empty_data)
    self.reset()
```

ご覧のように、すべてのプロトコルは少なくとも2つの項目に関して状態を維持しています。interface変数は、プロトコルが関連付けられているインターフェースクラスのインスタンスを保持しています。これは、インターフェースだけが知っている詳細を内省するために時々必要です。allow_empty_dataは、この文書の後半で説明する`read_data(data)`メソッドで使用されるフラグです。

### reset

resetメソッドは、インターフェースが接続および/または切断されたときに内部プロトコル状態をリセットするために使用されます。このメソッドは共通のリセットロジックに使用されるべきです。接続と切断の特定のロジックは、次の2つのメソッドで処理されます。

基本クラスのRuby実装:

```ruby
def reset
end
```

基本クラスのPython実装:

```python
def reset(self):
    pass
```

ご覧のように、基本クラスのreset実装は何も行いません。

### connect_reset

connect_resetメソッドは、インターフェースが接続されるたびに内部プロトコル状態をリセットするために使用されます。

基本クラスのRuby実装:

```ruby
def connect_reset
  reset()
end
```

基本クラスのPython実装:

```python
def connect_reset(self):
    self.reset()
```

基本クラスのconnect_reset実装は、共通のリセットロジックが実行されることを確実にするために、単にresetメソッドを呼び出します。

### disconnect_reset

disconnect_resetメソッドは、インターフェースが切断されるたびに内部プロトコル状態をリセットするために使用されます。

基本クラスのRuby実装:

```ruby
def disconnect_reset
  reset()
end
```

基本クラスのPython実装:

```python
def disconnect_reset(self):
    self.reset()
```

基本クラスのdisconnect_reset実装は、共通のリセットロジックが実行されることを確実にするために、単にresetメソッドを呼び出します。

### read_data

read_dataメソッドは、インターフェースによって読み取られた生データを分析し、潜在的に変更するために使用されます。分析されるデータの現在の状態として1つのパラメータを取ります。データの文字列、STOP、またはDISCONNECTのいずれかを返すことができます。文字列を返す場合、データが完全なパケットになる準備ができていて、後続のプロトコルによる処理の準備ができていると考えられます。STOPが返された場合、プロトコルは完全なパケットを完成させるためにさらにデータが必要だと考えています。DISCONNECTが返された場合、プロトコルはインターフェースを切断すべき（そして通常は自動的に再接続を試みる）と考えています。

基本クラスのRuby実装:

```ruby
def read_data(data)
  if (data.length <= 0)
    if @allow_empty_data.nil?
      if @interface and @interface.read_protocols[-1] == self # 自動@allow_empty_dataを持つチェーン内の最後の読み取りインターフェース
        return :STOP
      end
    elsif !@allow_empty_data # @allow_empty_dataがfalseの場合はSTOP
      return :STOP
    end
  end
  data
end
```

基本クラスのPython実装:

```python
def read_data(self, data, extra=None):
    if len(data) <= 0:
        if self.allow_empty_data is None:
            if self.interface and self.interface.read_protocols[-1] == self:
                # 自動self.allow_empty_dataを持つチェーン内の最後の読み取りインターフェース
                return ("STOP", extra)
        elif self.allow_empty_data:
            # self.allow_empty_dataがfalseの場合はSTOP
            return ("STOP", extra)
    return (data, extra)
```

基本クラスの実装は、与えられたデータを返すこと以外は何もしません。唯一の例外は空の文字列を処理する場合です。allow_empty_dataフラグがfalseである場合、またはnilであり、プロトコルがチェーン内の最後である場合、基本実装はSTOPを返し、インターフェースの`read_interface()`メソッドを呼び出してさらにデータを取得する時であることを示します。空の文字列は、キャッシュされたパケットを返す機会があることをプロトコルに通知するために使用されます。

### read_packet

read_packetメソッドは、インターフェースによって返される前にCOSMOSパケットを分析し、潜在的に変更するために使用されます。分析されるパケットの現在の状態として1つのパラメータを取ります。COSMOSパケット、STOP、またはDISCONNECTのいずれかを返すことができます。COSMOSパケットを返す場合、パケットが有効であり、返されるべきであり、後続のプロトコルによる処理の準備ができていると考えられます。STOPが返された場合、プロトコルはパケットを静かに破棄すべきだと考えています。DISCONNECTが返された場合、プロトコルはインターフェースを切断すべき（そして通常は自動的に再接続を試みる）と考えています。このメソッドは、パケットがリアルタイムテレメトリではなく保存されたテレメトリであるとプロトコルが判断した場合に、パケットにstoredフラグを設定する場所です。

基本クラスのRuby実装:

```ruby
def read_packet(packet)
  return packet
end
```

基本クラスのPython実装:

```python
def read_packet(self, packet):
    return packet
```

基本クラスは常に与えられたパケットをそのまま返します。

### write_packet

write_packetメソッドは、インターフェースによって出力される前にCOSMOSパケットを分析し、潜在的に変更するために使用されます。分析されるパケットの現在の状態として1つのパラメータを取ります。COSMOSパケット、STOP、またはDISCONNECTのいずれかを返すことができます。COSMOSパケットを返す場合、パケットが有効であり、インターフェースに書き出されるべきであり、後続のプロトコルによる処理の準備ができていると考えられます。STOPが返された場合、プロトコルはパケットを静かに破棄すべきだと考えています。DISCONNECTが返された場合、プロトコルはインターフェースを切断すべき（そして通常は自動的に再接続を試みる）と考えています。

基本クラスのRuby実装:

```ruby
def write_packet(packet)
  return packet
end
```

基本クラスのPython実装:

```python
def write_packet(self, packet):
    return packet
```

基本クラスは常に与えられたパケットをそのまま返します。

### write_data

write_dataメソッドは、インターフェースによって書き込まれる前にデータを分析し、潜在的に変更するために使用されます。分析および送信されるデータの現在の状態として1つのパラメータを取ります。データの文字列、STOP、またはDISCONNECTのいずれかを返すことができます。データの文字列を返す場合、データが有効であり、インターフェースに書き出されるべきであり、後続のプロトコルによる処理の準備ができていると考えられます。STOPが返された場合、プロトコルはデータを静かに破棄すべきだと考えています。DISCONNECTが返された場合、プロトコルはインターフェースを切断すべき（そして通常は自動的に再接続を試みる）と考えています。

基本クラスのRuby実装:

```ruby
def write_data(data)
  return data
end
```

基本クラスのPython実装:

```python
def write_data(self, data, extra=None):
    return (data, extra)
```

基本クラスは常に与えられたデータをそのまま返します。

### post_write_interface

post_write_interfaceメソッドは、データがインターフェースに書き込まれた後に呼び出されます。このメソッドの典型的な使用法は、コマンドに対して常に即時の応答が期待されるコマンド/レスポンスタイプのインターフェースを実装するためのフックを提供することです。`write_packet()`によるすべての変更後のパケットと、インターフェースに実際に書き込まれたデータという2つのパラメータを取ります。同じパケット/データのペア、STOP、またはDISCONNECTのいずれかを返すことができます。パケット/データのペアを返す場合、それらは他のプロトコルに渡されます。STOPが返された場合、インターフェースのwrite()呼び出しが完了し、それ以上のプロトコルの`post_write_interface()`メソッドは呼び出されません。DISCONNECTが返された場合、プロトコルはインターフェースを切断すべき（そして通常は自動的に再接続を試みる）と考えています。戻り値の最初のパラメータ「packet」だけがSTOPまたはDISCONNECTとしてチェックされることに注意してください。

基本クラスのRuby実装:

```ruby
def post_write_interface(packet, data)
  return packet, data
end
```

基本クラスのPython実装:

```python
def post_write_interface(self, packet, data, extra=None):
    return (packet, data, extra)
```

基本クラスは常に与えられたパケット/データをそのまま返します。

### protocol_cmd

protocol_cmdメソッドは、プロトコル自体にコマンドを送信するために使用されます。これは実行時にプロトコルの動作を変更するのに役立ちます。詳細については[interface_protocol_cmd](../guides/scripting-api#interface_protocol_cmd)を参照してください。

基本クラスのRuby実装:

```ruby
def protocol_cmd(cmd_name, *cmd_args)
  # デフォルトでは何もしない - サブクラスによって実装される
  return false
end
```

基本クラスのPython実装:

```python
def protocol_cmd(self, cmd_name, *cmd_args):
    # デフォルトでは何もしない - サブクラスによって実装される
    return False
```

これはサブクラスによって実装される特別な機能であるため、基本クラスは何も行いません。

## 例

上記のメソッドの実際の例については、リンクされている[Ruby Protocol](https://github.com/OpenC3/cosmos/blob/main/openc3/lib/openc3/interfaces/protocols)および[Python Protocol](https://github.com/OpenC3/cosmos/blob/main/openc3/python/openc3/interfaces/protocols)コードを参照してください。
